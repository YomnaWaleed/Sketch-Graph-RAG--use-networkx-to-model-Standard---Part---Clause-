{
  "0": {
    "node_id": "22b8dced-c322-4338-905e-be2a91bd84ea",
    "title": "Supplier Monitoring",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "1": {
    "node_id": "b813312d-2cb9-4142-9ddf-7d708098ad0a",
    "title": "Technical Requirements",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "2": {
    "node_id": "1fea0d31-246e-472c-af47-17d4879e172f",
    "title": "Legal and Administrative",
    "level": 2,
    "type": "clause",
    "content": "Requirements",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "3": {
    "node_id": "06de20ea-a428-4283-ad01-c2a75fe5db06",
    "title": "Project Requirements",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "4": {
    "node_id": "c3e502a7-1f8c-40f7-91d7-efe8c07f0666",
    "title": "Request for Proposals",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "5": {
    "node_id": "7eb67fc7-c5fa-4446-b838-ea755f5f9961",
    "title": "Supplier Qualification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "6": {
    "node_id": "ad724873-b308-4726-856f-82e22d91743b",
    "title": "Supplier Tendering",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "7": {
    "node_id": "110523ae-50e9-4ebb-9d33-4963dc4d8ca5",
    "title": "Product Release",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "8": {
    "node_id": "19adbacd-1c65-4dfb-b179-31f03cefd99d",
    "title": "Quality Assurance",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "9": {
    "node_id": "620c6609-bf16-42e5-8934-56467d1fd2eb",
    "title": "Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "10": {
    "node_id": "89a172b7-6d62-46b7-b8ca-f920ccd6a788",
    "title": "Joint Review",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "11": {
    "node_id": "0b4f6630-5b9e-4781-a5b9-dcc3ab68a06c",
    "title": "Documentation",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "12": {
    "node_id": "4e72e1e5-6075-4895-8a69-121e4db50066",
    "title": "Configuration",
    "level": 2,
    "type": "clause",
    "content": "Management",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "13": {
    "node_id": "968fe30e-0c4c-4f7e-8cae-962282a90cd5",
    "title": "Problem Resolution",
    "level": 2,
    "type": "clause",
    "content": "Management",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "14": {
    "node_id": "05d4ac2d-1b76-479a-8318-bf3e046c1835",
    "title": "Change Request",
    "level": 2,
    "type": "clause",
    "content": "Management",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "15": {
    "node_id": "94ac2b30-041e-4aa0-93ae-bd449c79dae6",
    "title": "Project Management",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "16": {
    "node_id": "05adefd9-7b64-4fdd-995c-0783ef27b1d1",
    "title": "Risk Management",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "17": {
    "node_id": "851ead0c-7a7b-4c02-bd14-23983c8046cd",
    "title": "Measurement",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "18": {
    "node_id": "534fa13c-d145-43e9-b67b-6790067cb518",
    "title": "Contract Agreement",
    "level": 2,
    "type": "clause",
    "content": "Process Improvement \nProcess Group (PIM)",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "19": {
    "node_id": "0fefbfe6-5684-4056-8131-9fdb05a5b6bd",
    "title": "Process Improvement",
    "level": 2,
    "type": "clause",
    "content": "Reuse Process Group \n(REU)",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "20": {
    "node_id": "fb575bfa-51db-41e8-871a-ac6952e8111b",
    "title": "Reuse Program",
    "level": 2,
    "type": "clause",
    "content": "Management\nSystem Engineering Process Group (SYS)",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "21": {
    "node_id": "ebd04b60-10e9-4336-8cc5-6e7e2576780b",
    "title": "Requirements Elicitation",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "22": {
    "node_id": "279c62f3-237c-47a3-a295-ed52da412750",
    "title": "System Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "23": {
    "node_id": "37988e5a-5450-4f5c-b094-9f3e9974ef12",
    "title": "System Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "24": {
    "node_id": "5c063070-0583-492d-beb3-2992423bd25d",
    "title": "System Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "25": {
    "node_id": "b395c8c4-95f5-4de4-b9ef-d621cd59c715",
    "title": "System Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "Software Engineering Process Group (SWE)",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "26": {
    "node_id": "9f5b5a46-39e2-4b5e-83cb-4de4b3058d5f",
    "title": "Software Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "27": {
    "node_id": "2113a10a-5b79-46b9-8976-f309446b343b",
    "title": "Software Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "28": {
    "node_id": "dc74a236-5b52-45bc-aa97-249daf33af37",
    "title": "Software Detailed Design",
    "level": 2,
    "type": "clause",
    "content": "and Unit Construction",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "29": {
    "node_id": "dade1af1-80c0-42c8-9236-aed7e9a2d1cd",
    "title": "Software Unit Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "30": {
    "node_id": "f2ea4a8a-6117-45c2-975b-a33cf26838cb",
    "title": "Software Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "31": {
    "node_id": "e558967b-c0cc-4fbf-928b-8165e804b424",
    "title": "Software Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "Primary Life Cycle Processes Supporting Life Cycle ProcessesOrganizational Life Cycle Processes \n  \nFigure 2 — Automotive SPICE process reference model - Overview \n  \n\n  \n \n \n \n© VDA Quality Management Center 13\n\n### Primary life cycle processes category\n\nThe primary life cycle processes category consists of processes that may be used by the customer \nwhen acquiring products from a supplier, and by the supplier when responding and delivering \nproducts to the customer including the engineering processes needed for specification, design, \ndevelopment, integration and testing. \nThe primary life cycle processes category consists of the following groups: \n• the Acquisition process group;  \n• the Supply process group;  \n• the System engineering process group; \n• the Software engineering process group. \nThe Acquisition process group (ACQ) consists of processes that are performed by the customer, or \nby the supplier when acting as a customer for its own suppliers, in order to acquire a product and/or \nservice.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "32": {
    "node_id": "c1599a08-f0e8-4e41-8ab3-6dd2968727dc",
    "title": "Contract Agreement",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "33": {
    "node_id": "937087b8-51ba-42cb-87f0-c19799f4f43b",
    "title": "Supplier Monitoring",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "34": {
    "node_id": "7a31b94d-e22e-4355-b2ad-b715016f6b41",
    "title": "Technical Requirements",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "35": {
    "node_id": "3641b6f7-b942-4d8d-9fed-66f9a43b2339",
    "title": "Legal and Administrative Requirements",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "36": {
    "node_id": "524702e3-5b59-4762-92f6-6c7e82b3ce40",
    "title": "Project Requirements",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "37": {
    "node_id": "7fa843ad-d701-4a28-9f84-7e492116cbb4",
    "title": "Request for Proposals",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "38": {
    "node_id": "da62274d-bb67-49f3-85c5-033a15dbce2d",
    "title": "Supplier Qualification",
    "level": 2,
    "type": "clause",
    "content": "Table 2 — Primary life cycle processes – ACQ process group \nThe Supply process group (SPL) consists of processes performed by the supplier in order to supply \na product and/or a service.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "39": {
    "node_id": "3bb2b0e4-65e9-4329-9072-75ceb70d7f38",
    "title": "Supplier Tendering",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "40": {
    "node_id": "1f668c76-1d01-45c0-9ea7-e341c1ac7b41",
    "title": "Product Release",
    "level": 2,
    "type": "clause",
    "content": "Table 3 — Primary life cycle processes – SPL process group \nThe System Engineering process group (SYS) consists of processes addressing the elicitation and \nmanagement of customer and internal requirements, the definition of the system architecture and \nthe integration and testing on the system level.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "41": {
    "node_id": "f64f4a72-2bac-4e87-8b66-c35a3b621d0c",
    "title": "Requirements Elicitation",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "42": {
    "node_id": "7529d06f-dfe2-41ef-b1ca-c6ed9d9b8959",
    "title": "System Requirements Analysis",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "43": {
    "node_id": "7461643d-2141-46b9-a48c-1680c1e69568",
    "title": "System Architectural Design",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "44": {
    "node_id": "8571f2c8-7113-4ded-be5c-93bb4a44c4c1",
    "title": "System Integration and Integration Test",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "45": {
    "node_id": "db4c52ac-016f-46db-b352-50d65858c3df",
    "title": "System Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "Table 4 — Primary life cycle processes – SYS process group \nThe Software Engineering process group (SWE) consists of processes addressing the management \nof software requirements derived from the system requirements, the development of the \n\n  \n \n \n \n© VDA Quality Management Center 14 \n \n \ncorresponding software architecture and design as well as the implementation,  integration and \ntesting of the software.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "46": {
    "node_id": "f1e6f115-d2cc-402a-a05b-fb87cc83f888",
    "title": "Software Requirements Analysis",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "47": {
    "node_id": "ebda8e04-5e02-4bb0-b9f8-b3125f207cd3",
    "title": "Software Architectural Design",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "48": {
    "node_id": "43e619fb-166f-4adb-95dc-17f281e8aa80",
    "title": "Software Detailed Design and Unit Construction",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "49": {
    "node_id": "618e4395-a3b2-4986-82ae-efb673a3b599",
    "title": "Software Unit Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "50": {
    "node_id": "aa6174aa-b347-43b5-9564-a1fc059e2dde",
    "title": "Software Integration and Integration Test",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "51": {
    "node_id": "b03b03f7-8719-42df-95a9-53ed5acc1157",
    "title": "Software Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "Table 5 — Primary life cycle processes – SWE process group\n\n### Supporting life cycle processes category\n\nThe supporting life cycle processes category consists of processes that may be employed by any of \nthe other processes at various points in the life cycle.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "52": {
    "node_id": "2c5353d2-473f-4cb4-a695-02fa660ec476",
    "title": "Quality Assurance",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "53": {
    "node_id": "1a4692b8-f3d0-48c2-b6f2-74f533756f35",
    "title": "Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "54": {
    "node_id": "f8dc7657-e799-481e-9954-e5f10ce1573f",
    "title": "Joint Review",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "55": {
    "node_id": "cd15b045-d4fb-4de3-80fb-8c0f0bc742ea",
    "title": "Documentation",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "56": {
    "node_id": "578636bd-dae0-469b-bb38-54e7abf4ea5e",
    "title": "Configuration Management",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "57": {
    "node_id": "897bacb1-c42b-4c8b-8cc8-a1aeb1d2e65d",
    "title": "Problem Resolution Management",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "58": {
    "node_id": "4dbda624-8b9e-4b69-b266-4ea13eb2e748",
    "title": "Change Request Management",
    "level": 2,
    "type": "clause",
    "content": "Table 6 — Supporting life cycle processes - SUP process group\n\n### Organizational life cycle processes category\n\nThe o rganizational life cycle processes  category consists of processes that develop process, \nproduct, and resource assets which, when used by projects in the organization, will help the \norganization achieve its business goals. \nThe organizational life cycle processes category consists of the following groups: \n• the Management process group;  \n• the Process Improvement process group;  \n• the Reuse process group. \nThe Management process group (MAN) consists of processes that may be used by anyone who \nmanages any type of project or process within the life cycle.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "59": {
    "node_id": "d20f9f8c-8e96-4877-b2c1-f0339b8c641d",
    "title": "Project Management",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "60": {
    "node_id": "6e3058b0-f959-4ec9-9e4f-318e27766c66",
    "title": "Risk Management",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "61": {
    "node_id": "54a61545-70ac-4dbc-bdd6-9b7b70742aaa",
    "title": "Measurement",
    "level": 2,
    "type": "clause",
    "content": "Table 7 — Organizational life cycle processes - MAN process group \n\n  \n \n \n \n© VDA Quality Management Center 15 \n \n \nThe Process Improvement process group (PIM) covers one process that contains practices to \nimprove the processes performed in the organizational unit.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "62": {
    "node_id": "b9844d41-5711-4af0-b30f-78d865240d95",
    "title": "Process Improvement",
    "level": 2,
    "type": "clause",
    "content": "Table 8 — Organizational life cycle processes - PIM process group \nThe Reuse process group (REU) covers one process to systematically exploit reuse opportunities in \norganization’s reuse programs.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "63": {
    "node_id": "b166f07d-3b8b-43e7-84f1-edc1ab1bfe77",
    "title": "Reuse Program Management",
    "level": 2,
    "type": "clause",
    "content": "Table 9 — Organizational life cycle processes - REU process group\n\n## Measurement framework\n\nThe m easurement f ramework provides the necessary requirements and rules for the capability \ndimension. It defines a schema which enables an assessor to determine the capability level of a \ngiven process. These capability levels are defined as part of the measurement framework. \nTo enable the rating, the measurement framework provides process attributes defining a measurable \nproperty of process capability. Each process attribute is assigned to a specific capability level. The \nextent of achievement of a certain process attribute is represented by means of a rating based on a \ndefined rating scale. The rules from which an assessor can derive a final capability level for a given \nprocess are represented by a process capability level model. \nAutomotive SPICE 3.1 uses the measurement framework defined in ISO/IEC 33020:2015. \nNOTE: Text incorporated from ISO/IEC 33020 within this chapter is written in italic font and marked with a \nleft side bar.\n\n### Process capability levels and process attributes\n\nThe process capability levels and process attributes are identical to those defined in ISO/IEC 33020 \nclause 5.2. The detailed descriptions of the capability levels and the corresponding process attributes \ncan be found in chapter 5. \nProcess attributes are  features of a process that can be evaluated on a scale of achievement, \nproviding a measure of the capability of the process. They are applicable to all processes. \nA capability level is a set of process attribute(s) that work together to provide a major enhancement \nin the capability to perform a process. Each attribute addresses a specific aspect of the capability \nlevel. The levels constitute a rational way of progressing through improvement of the capability of \nany process. \nAccording to ISO/IEC 33020 there are six capability levels, incorporating nine process attributes: \nLevel 0: \nIncomplete process \nThe process is not implemented, or fails to achieve its process \npurpose. \nLevel 1: \nPerformed process \nThe implemented process achieves its process purpose \nLevel 2: \nManaged process \nThe previously described performed process is now implemented in a \nmanaged fashion (planned, monitored and adjusted) and its work \nproducts are appropriately established, controlled and maintained. \n\n  \n \n \n \n© VDA Quality Management Center 16 \n \n \nLevel 3: \nEstablished process \nThe previously described managed process is now implemented using \na defined process that is capable of achieving its process outcomes. \nLevel 4: \nPredictable process \nThe previously described established process now operates \npredictively within defined limits to achieve its process outcomes. \nQuantitative management needs are identified, measurement data are \ncollected and analyzed to identify assignable causes of variation. \nCorrective action is taken to address assignable causes of variation. \nLevel 5: \nInnovating process \nThe previously described predictable process is now continually \nimproved to respond to organizational change. \nTable 10 — Process capability levels according to ISO/IEC 33020 \nWithin this process assessment model, the determination of capability is based upon the nine \nprocess attributes (PA) defined in ISO/IEC 33020 and listed in Table 11. \nAttribute ID Process Attributes \nLevel 0: Incomplete process \nLevel 1: Performed process \nPA 1.1 Process performance process attribute \nLevel 2: Managed process \nPA 2.1 Performance management process attribute \nPA 2.2 Work product management process attribute \nLevel 3: Established process \nPA 3.1 Process definition process attribute \nPA 3.2 Process deployment process attribute \nLevel 4: Predictable process \nPA 4.1 Quantitative analysis process attribute \nPA 4.2 Quantitative control process attribute \nLevel 5: Innovating process \nPA 5.1 Process innovation process attribute \nPA 5.2 Process innovation implementation process attribute \nTable 11 — Process attributes according to ISO/IEC 33020\n\n### Process attribute rating\n\nTo support the rating of process attributes, the ISO/IEC 33020 measurement framework provides a \ndefined rating scale with an option for refinement, different rating methods and different aggregation \nmethods depending on the class of the assessment (e.g. required for organizational maturity \nassessments). \nRating scale \nWithin this process measurement framework, a process attribute is a m easureable property of \nprocess capability. A process attribute rating is a judgement of the degree of achievement of the \nprocess attribute for the assessed process. \n \nThe rating scale is defined by ISO/IEC 33020 as shown in table 12. \n\n  \n \n \n \n© VDA Quality Management Center 17 \n \n \nN Not achieved There is little or no evidence of achievement of the defined process \nattribute in the assessed process. \nP Partially achieved \nThere is some evidence of an approach to, and some achievement of, \nthe defined process attribute in the assessed process. Some aspects \nof achievement of the process attribute may be unpredictable. \nL Largely achieved \nThere is evidence of a systematic approach to, and significant \nachievement of, the defined process attribute in the assessed process. \nSome weaknesses related to this process att ribute may exist in the \nassessed process. \nF Fully achieved \nThere is evidence of a complete and systematic approach to, and full \nachievement of, the defined process attribute in the assessed process. \nNo significant weaknesses related to this process attribute exist in the \nassessed process. \nTable 12 — Rating scale according to ISO/IEC 33020 \nThe ordinal scale defined above shall be understood in terms of percentage achievement of a \nprocess attribute. \nThe corresponding percentages shall be: \n \nN Not achieved 0 to ≤ 15% achievement \nP Partially achieved > 15% to ≤ 50% achievement \nL Largely achieved > 50% to ≤ 85% achievement \nF Fully achieved > 85% to ≤ 100% achievement \nTable 13 — Rating scale percentage values according to ISO/IEC 33020 \nThe ordinal scale may be further refined for the measures P and L as defined below. \n \nP- Partially achieved: There is some evidence of an approach to, and some achievement of, \nthe defined process attribute in the assessed process. Many aspects of \nachievement of the process attribute may be unpredictable. \nP+ Partially achieved: There is some evidence of an approach to, and some achievement of, \nthe defined process attribute in the assessed process. Some aspects of \nachievement of the process attribute may be unpredictable. \nL- Largely achieved: There is evidence of a systematic approach to, and significant \nachievement of, the defined process attribute in the assessed process. \nMany weaknesses related t o this process attribute may exist in the \nassessed process. \nL+ Largely achieved: There is evidence of a systematic approach to, and significant \nachievement of, the defined process attribute in the assessed process. \nSome weaknesses related to this process attribute may exist in the \nassessed process. \nTable 14 — Refinement of rating scale according to ISO/IEC 33020 \n  \n\n  \n \n \n \n© VDA Quality Management Center 18 \n \n \nThe corresponding percentages shall be: \n \nP- Partially achieved - > 15% to ≤ 32.5% achievement \nP+ Partially achieved + > 32.5 to ≤ 50% achievement \nL- Largely achieved - > 50% to ≤ 67.5% achievement \nL+ Largely achieved + > 67.5% to ≤ 85% achievement \nTable 15 — Refined rating scale percentage values according to ISO/IEC 33020 \nRating and aggregation method \nISO/IEC 33020 provides the following definitions: \nA process outcome is the observable result of successful achievement of the process purpose. \nA process attribute outcome is the observable result of achievement of a specified process \nattribute. \nProcess outcomes and process attribute outcomes may be characterised as an intermediate step \nto providing a process attribute rating. \nWhen performing rating, the rating method employed shall be specified relevant to the class of \nassessment. The following rating methods are defined. \nThe use of rating method may vary according to the class, scope and context of an assessment. \nThe lead assessor shall decide which (if any) rating method to use. The selected rating method(s) \nshall be specified in the assessment input and referenced in the assessment report. \n \nISO/IEC 33020 provides the following 3 rating methods: \nRating method R1 \nThe approach to process attribute rating shall satisfy the following conditions: \na) Each process outcome of each process within the scope of the assessment shall be \ncharacterized for each process instance, based on validated data; \nb) Each process attribute outcome of each process attribute for each process within the scope of \nthe assessment shall be characterised for each process instance, based on validated data; \nc) Process outcome characterisations for all assessed process instances shall be aggregated to \nprovide a process performance attribute achievement rating; \nd) Process attribute outcome characterisations for all assessed process insta nces shall be \naggregated to provide a process attribute achievement rating. \nRating method R2 \nThe approach to process attribute rating shall satisfy the following conditions: \na) Each process attribute for each process within the scope of the assessment shal l be \ncharacterized for each process instance, based on validated data; \nb) Process attribute characterisations for all assessed process instances shall be aggregated to \nprovide a process attribute achievement rating. \nRating method R3 \nProcess attribute rating across assessed process instances shall be made without aggregation. \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 19 \n \n \nIn principle the three rating methods defined in ISO/IEC 33020 depend on  \na) whether the rating is made only on process attribute level (Rating method 3 and 2) or – with \nmore level of detail – both on process attribute and process attribute outcome level (Rating \nmethod 1); and \nb) the type of aggregation ratings across the assessed process instances for each process \nIf a rating is performed for both process attributes and process attribute o utcomes (Rating method \n1), the result will be a process performance attribute outcome rating on level 1 and a process attribute \nachievement rating on higher levels. \nDepending on the class, scope and context of the assessment an aggregation within one proce ss \n(one-dimensional, vertical aggregation), across multiple process instances (one -dimensional, \nhorizontal aggregation) or both (two-dimensional, matrix aggregation) is performed. \nISO/IEC 33020 provides the following examples: \nWhen performing an assessment, ratings may be summarised across one or two dimensions. \nFor example, when rating a \n• process attribute for a given process, one may aggregate ratings of the associated process \n(attribute) outcomes – such an aggregation will be performed as a vertical aggre gation (one \ndimension). \n• process (attribute) outcome for a given process attribute across multiple process instances, \none may aggregate the ratings of the associated process instances for the given process \n(attribute) outcome such an aggregation will be per formed as a horizontal aggregation (one \ndimension) \n• process attribute for a given process, one may aggregate the ratings of all the process \n(attribute) outcomes for all the processes instances – such an aggregation will be performed \nas a matrix aggregation across the full scope of ratings (two dimensions) \n \nThe standard defines different methods for aggregation. Further information can be taken from \nISO/IEC 33020. \n  \n\n  \n \n \n \n© VDA Quality Management Center 20\n\n### Process capability level model\n\nThe process capability level achieved by a process shall be derived from the process attribute ratings \nfor that process according to the process capability level model defined in Table 16. \nThe process capability level model defines the rules how the achievement of each level depends on \nthe rating of the process attributes for the assessed and all lower levels. \nAs a general rule the achievement of a given level requires a largely achievement of the \ncorresponding process attributes and a full achievement of any lower lying process attribute. \n \nScale Process attribute Rating \nLevel 1 PA 1.1: Process Performance Largely \nLevel 2 \nPA 1.1: Process Performance \nPA 2.1: Performance Management \nPA 2.2: Work Product Management \nFully \nLargely \nLargely \nLevel 3 \nPA 1.1: Process Performance \nPA 2.1: Performance Management \nPA 2.2: Work Product Management \nPA 3.1: Process Definition \nPA 3.2: Process Deployment \nFully \nFully \nFully \nLargely \nLargely \nLevel 4 \nPA 1.1: Process Performance \nPA 2.1: Performance Management \nPA 2.2: Work Product Management \nPA 3.1: Process Definition \nPA 3.2: Process Deployment \nPA 4.1: Quantitative Analysis \nPA 4.2: Quantitative Control \nFully \nFully \nFully \nFully \nFully \nLargely \nLargely \nLevel 5 \nPA 1.1: Process Performance \nPA 2.1: Performance Management \nPA 2.2: Work Product Management \nPA 3.1: Process Definition \nPA 3.2: Process Deployment \nPA 4.1: Quantitative Analysis \nPA 4.2: Quantitative Control \nPA 5.1: Process Innovation \nPA 5.2: Process Innovation Implementation \nFully \nFully \nFully \nFully \nFully \nFully \nFully \nLargely \nLargely \nTable 16 — Process capability level model according to ISO/IEC 33020 \n  \n\n  \n \n \n \n© VDA Quality Management Center 21\n\n## Process assessment model\n\nThe process assessment model offers indicators in order to identify whether the process outcomes \nand the p rocess attribute outcomes (achievements) are present or absent in the instantiated \nprocesses of projects and organizational units. These indicators provide guidance for assessors in \naccumulating the necessary objective evidence to support judgments of capability. They are not \nintended to be regarded as a mandatory set of checklists to be followed. \nIn order to judge the presence or absence of process outcomes and process achievements an \nassessment obtains objective evidence. All such evidence comes from the examination of work \nproducts and reposit ory content of the assessed processes, and from testimony provided by the \nperformers and managers of the assessed processes. This evidence is mapped to the PAM \nindicators to allow establishing the correspondence to the relevant process outcomes and process  \nattribute achievements. \nThere are two types of indicators: \n• Process performance i ndicators, which apply exclusively to capability Level 1. They \nprovide an indication of the extent of fulfillment of the process outcomes \n \n• Process capability indicators, which apply to Capability Levels 2 to 5. They provide an \nindication of the extent of fulfillment of the process attribute achievements. \nAssessment indicators are used to confirm that certain practices were performed, as shown by \nevidence collected during an assessment. All such evidence comes either from the examination of \nwork products of the processes assessed, or from statements made by the performers and \nmanagers of the processes. The existence of base practices and work products provide evidence of \nthe performance of the processes associated with them. Similarly, the existence of process capability \nindicators provides evidence of process capability. \nThe evidence obtained should be recorded in a form that clearly relates to an associated indicator, \nin order that support for the assessor’s judgment can be confirmed or verified as required by ISO/IEC \n33002.\n\n### Process performance indicators\n\nTypes of process performance indicators are \n• Base practices (BP) \n• Work products (WP). \nBoth BPs and WPs relate to one or more process outcomes. Consequently, BPs and WPs are always \nprocess-specific and not generic. BPs represent activity-oriented indicators. WPs represent result -\noriented indicators. Both BP and WP are used for judging objective evidence that an assessor is to \ncollect, and accumulate, in the performance of an assessment . In that respect BPs and WPs are \nalternative indicator sets the assessor can use. \nThe PAM offers a set of work product characteristics (WPC, see Annex B) for each WP. These are \nmeant to offer a good practice and state-of-the-art knowledge guide for the assessor. Therefore, WP \nand WPC are supposed to be a quickly accessible information source during an assessment. In that \nrespect WPs and WPC s represent an example structure only. They are neither a \"strict must\" nor \nare they normative for organizations. Instead, the actual structure, form and content of concrete work \nproducts and documents for the implemented processes must be defined by the project and \norganization, respectively. The project and/or o rganization ensures that the work products are \nappropriate for the intended purpose and needs, and in relation to the development goals. \n\n  \n \n \n \n© VDA Quality Management Center 22\n\n### Process capability indicators\n\nTypes of process capability indicators are: \n• Generic Practice (GP) \n• Generic Resource (GR) \nBoth GPs and GRs relate to one or more PA Achievements. In contras t to process p erformance \nindicators, however, they are of generic type, i.e. they apply to any process. \nThe difference between GP and GR is that the former represent activity-oriented indicators while the \nlatter represent infrastructure- oriented indicators for judging objective evidence. An assessor has to \ncollect and accumulate evidence supporting process capability indicators during an assessment. In \nthat respect GPs and GRs are alternative indicators sets the assessor can use. \nIn spite of the fact that level 1 capability of a process is only characterized by the meas ure of the \nextent to which the process outcomes are achieved the measurement framework (see chapter 3.2) \nrequires each level to reveal a process a ttribute, and, thus, requires the  PAM to introduce at least \none process capability i ndicator. Therefore, the only process performance attribute for c apability \nLevel 1 (PA.1.1) has a single generic p ractice (GP 1.1.1) pointing as an edi torial reference to the \nrespective process performance indicators (see Figure 3). \nMeasurement framework\n(ISO/IEC 33020)\n• Capability levels\n• Process attributes\n• Rating\n• Scale\n• Rating method\n• Aggregation method\n• Process capability level model\nOutcomes of \nprocess 3\nProcess assessment model\n(Automotive SPICE)\n• Process capability indicators\n• Process performance indicators\nProcess reference model\n(Automotive SPICE)\n• Domain and scopes\n• Process purposes\n• Process outcomes\nCL 1\nCL 2\nCL 3\nCL 4\nCL 5 PA 5.2\nPA 5.1\nPA 4.2\nPA 4.1\nPA 3.2\nPA 3.1\nPA 2.2\nPA 2.1\nPA 1.1\nGPs, GRs\nGPs, GRs\nOutcomes of \nprocess 1\nOutcomes of \nprocess 2\nGP BPs, WPs and WPCs\n \nFigure 3 — Relationship between assessment indicators and process capability\n\n### Understanding the level of abstraction of a PAM\n\nThe term \"process\" can be understood at three levels of abstraction. Note that these levels of \nabstraction are not meant to define a strict black-or-white split, nor is it the aim to provide a scientific \nclassification schema – the message here is to understand that, in practice, when it comes to the \nterm \"process\" there are different abstraction levels, and that a PAM resides at the highest. \n \n\n  \n \n \n \n© VDA Quality Management Center 23 \n \n \nProcess Assessment Model(s)\nMethods\nExecution\nThe \"What\"\n(Goals of the process)\n(How to achieve the goals)\nThe \"How\"\n(Performing the tasks to achieve \nthe goals by using the methods)\nThe \"Doing\"\n• What is to be done\n• Why it has to be done\n• What are the technical dependencies\n• Methods, tools, templates, metrics\n• Definitions of logical order, concrete \nworkflows\n• Authority and competence definitions\n• Tailoring\n• Setup\n• Performance according to the tailored \nmethod\n \nFigure 4 — Possible levels of abstraction for the term \"process\" \nCapturing experience acquired during product development  (i.e. at the DO ING level) in order to \nshare this experience with others means creating a HOW level. However, a HOW is always specific \nto a particular context such as a company, an organizational unit, or a product line. For example, the \nHOW of a project, organizational unit, or company A is potentially not applicable as is to a project, \norganizational unit, or company B. However, both might be expected to adhere the principles \nrepresented by PAM indicators for process outcomes and process attribute achievements. These \nindicators are at the WHAT level while deciding on solutions for concrete templates, proceedings, \nand tooling etc. is left to the HOW level. \nProcess Assessment Model(s)MethodsExecution\nPerforming interviews on the actual \"Doing\", \nInvestigating work products and tool \nrepositories, …\nReading through the defined \"How\"\n1\n2\n3\n… mapping the information to the indicators ...\n… and determine the capability profile.\n \nFigure 5 — Performing a process assessment for determining process capability \n\n  \n \n \n \n© VDA Quality Management Center 24\n\n# Process reference model and performance indicators (Level 1)\n\nThe processes in the process dimension can be drawn from the Automotive SPICE process \nreference model, which is incorporated in the tables below indicated by a red bar at the left side. \nEach table related to one process in the process dimension contains the process reference model \n(indicated by a red bar) and the process performance i ndicators necessary to define the process \nassessment model. The process performance indicators consist of base practices (indicated by a \ngreen bar) and output work products (indicated by a blue bar). \n \nProcess \nreference \nmodel Process ID The individual proce sses are describ ed in terms of \nprocess name, p rocess purpose, and p rocess \noutcomes to define the Automotive SPICE process \nreference model. Additional ly a process i dentifier is \nprovided. \nProcess name \nProcess purpose \nProcess outcomes \nProcess \nperformance \nindicators \nBase practices A set of base practices for the process providing a \ndefinition of the tasks and activities needed to \naccomplish the process purpose and fulfill the process \noutcomes \nOutput work \nproducts \nA number of output work products associated with \neach process \nNOTE: Refer to Annex B for the characteristics \nassociated with each work product. \nTable 17 — Template for the process description \n  \n\n  \n \n \n \n© VDA Quality Management Center 25\n\n## Acquisition process group (ACQ)\n\n\n\n### ACQ.3 Contract Agreement\n\nProcess ID ACQ.3 \nProcess name Contract Agreement \nProcess purpose The purpose of Contract Agreement Process is to negotiate and approve \na contract/agreement with the supplier. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) a contract/agreement is negotiated, reviewed, approved and awarded \nto the supplier(s);  \n2) the contract/agreement clearly and unambiguously specifies the \nexpectations, responsibilities, work products/deliverables and liabilities \nof both the supplier(s) and the acquirer;  \n3) mechanisms for monitoring the capability and performance of the \nsupplier(s) and for mitigation of identified risks are reviewed and \nconsidered for inclusion in the contract conditions; and  \n4) proposers/tenderers are notified of the result of proposal/tender \nselection. \nBase practices ACQ.3.BP1: Negotiate the contract/agreement . Negotiate all relevant \naspects of the contract/agreement with the supplier. [OUTCOME 1] \nNOTE 1: Relevant aspects of the procurement may include \n• system requirements  \n• acceptance criteria and evaluation criteria \n• linkage between payment and successful completion of acceptance testing  \n• process requirements, process interfaces and joint processes. \nACQ.3.BP2: Specify rights and duties.  Unambiguously specify the \nexpectations, responsibilities, work products/deliverables and liabilities of \nthe parties in the contract/agreement. [OUTCOME 2]  \nACQ.3.BP3: Review contract/agreement for supplier capability \nmonitoring. Review and consider a mechanism for monitoring the \ncapability and performance  of the supplier for inclusion in the \ncontract/agreement conditions. [OUTCOME 3]  \nACQ.3.BP4: Review contract/agreement for risk mitigation actions.  \nReview and consider a mechanism for the mitigation of identified risk for \ninclusion in the contract/agreement conditions. [OUTCOME 3]  \nACQ.3.BP5: Approve contract/agreement. The contract/agreement is \napproved by relevant stakeholders. [OUTCOME 1] \nACQ.3.BP6: Award contract/agreement.  The contract/agreement is \nawarded to the successful proposer/tenderer. [OUTCOME 1]  \nACQ.3.BP7: Communicate result to tenderers. Notify the result of the \nproposal/tender selection to proposers/tenders. After contract award inform \nall tenderers of the decision. [OUTCOME 4] \nOutput work \nproducts \n02-00 Contract   → [OUTCOME 1, 2, 3] \n02-01 Commitment/agreement → [OUTCOME 1] \n\n  \n \n \n \n© VDA Quality Management Center 26 \n \n \n13-04 Communication record → [OUTCOME 4] \n13-05 Contract review record → [OUTCOME 1] \n13-09 Meeting support record → [OUTCOME 1]\n\n### ACQ.4 Supplier Monitoring\n\nProcess ID ACQ.4 \nProcess name Supplier Monitoring \nProcess purpose The purpose of the Supplier Monitoring Process is to track and assess the \nperformance of the supplier against agreed requirements. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) joint activities, as agreed between the customer and the supplier, are \nperformed as needed; \n2) all information, agreed upon for exchange, is communicated regularly \nbetween the supplier and customer; \n3) performance of the supplier is monitored against the agreements; and \n4) changes to the agreement, if needed, are negotiated between the \ncustomer and the supplier and documented in the agreement. \nBase practices ACQ.4.BP1: Agree on and maintain joint processes, joint interfaces, \nand information to be exchanged. Establish and maintain an agreement on \ninformation to be exchanged and on joint processes and joint interfaces, \nresponsibilities, type and frequency of joint activities, communications, \nmeetings, status reports and reviews. [OUTCOME 1, 2, 4] \nNOTE1: Joint processes and interfaces usually include project management, \nrequirements management, change management, configuration management, \nproblem resolution, quality assurance and customer acceptance. \nNOTE 2: Joint activities to be performed should be mutually agreed between \nthe customer and the supplier. \nNOTE 3: The term customer in this process refers to the assessed party. The \nterm supplier refers to the supplier of the assessed party. \nACQ.4.BP2: Exchange all agreed information.  Use the defined joint \ninterfaces between customer and supplier for the exchange of all agreed \ninformation. [OUTCOME 1, 2, 3] \nNOTE 4: Agreed information should include all relevant work products. \nACQ.4.BP3: Review technical development with the supplier.  Review \ndevelopment with the supp lier on the agreed regular basis, covering \ntechnical aspects, problems and risks and also track open items to closure. \n[OUTCOME 1, 3, 4]  \nACQ.4.BP4: Review progress of the supplier . Review progress of the \nsupplier regarding schedule, quality, and cost on the agreed regular basis. \nTrack open items to closure and perform risk mitigation activities. [OUTCOME \n1, 3, 4] \nACQ.4.BP5: Act to correct deviations.  Take action when agreed \nobjectives are not achieved to correct deviations from the agreed project \nplans and  to prevent reoccurrence of problems identified. Negotiate \nchanges to objectives and document them in the agreements. [OUTCOME 4] \n\n  \n \n \n \n© VDA Quality Management Center 27 \n \n \nOutput work \nproducts \n02-01 Commitment/agreement → [OUTCOME 4] \n13-01 Acceptance record  → [OUTCOME 3] \n13-04 Communication record → [OUTCOME 1, 2] \n13-09 Meeting support record → [OUTCOME 1] \n13-14 Progress status record  → [OUTCOME 2] \n13-16 Change request  → [OUTCOME 4] \n13-19 Review record   → [OUTCOME 2] \n14-02 Corrective action register → [OUTCOME 4] \n15-01 Analysis report   → [OUTCOME 3]\n\n### ACQ.11 Technical Requirements\n\nProcess ID ACQ.11 \nProcess name Technical Requirements \nProcess purpose The purpose of the Technical Requirements Process is to establish the \ntechnical requirements of the acquisition. This involves the elicitation of \nfunctional and non-functional requirements that consider the deployment \nlife cycle of the products so as to establish a technical requirement \nbaseline. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) the technical requirements, including environment effect evaluation, \nsafety and security requirements where appropriate, are defined and \ndeveloped to match needs and expectations; \n2) the current and evolving acquisition needs are gathered and defined; \n3) the requirements and potential solutions are communicated to all \naffected groups; \n4) a mechanism is established to incorporate changed or new \nrequirements into the established baseline; \n5) a mechanism for identifying and managing the impact of changing \ntechnology to the technical requirements is defined; and \n6) the requirements include compliance with relevant standards, \nincluding environment effect evaluation, safety and security standards \nwhere appropriate. \nBase practices ACQ.11.BP1: Elicit needs. Elicit the needs of all relevant user groups.  \n[OUTCOME 1] \nACQ.11.BP2: Define technical requirements.  Define and develop the \ntechnical requirements and potential solutions (where relevant), including \nenvironment effect evaluation, safety and security, performance, \nsupportability requirements to match the needs and expectations of the \nrelevant user groups. [OUTCOME 1] \nNOTE 1: This may include  \n• the categorization, prioritization and indication of requirements \n• the indication of mandatory requirements \n• classification of requirements into functional areas \n• using defined end user types to describe the functional requirements \nwithin an organization \n\n  \n \n \n \n© VDA Quality Management Center 28 \n \n \nACQ.11.BP3: Identify acquisition needs. Gather and define the current \nand evolving acquisition needs. [OUTCOME 2] \nACQ.11.BP4: Ensure consistency. Ensure consistency of the technical \nrequirements with the defined acquisition needs. [OUTCOME 2] \nACQ.11.BP5: Identify affected groups.  Identify all groups to which the \ntechnical requirements and potential solutions should be communicated.  \n[OUTCOME 3] \nACQ.11.BP6: Communicate to affected groups.  Communicate the \ntechnical requirements and potential solutions to all affected groups.  \n[OUTCOME 3] \nNOTE 2: To ensure a better understanding: \n• the requirements might be specified in business terms \n• simulation and exploratory prototyping techniques might be used \nACQ.11.BP7: Establish a change mechanism . Establish a mechanism \nto incorporate changed or new technical requirements into the established \nbaseline. [OUTCOME 4] \nNOTE 3: This may include analyzing, structuring and prioritizing technical \nrequirements according to their importance to the business. \nACQ.11.BP8: Track impact of changing technology.  Define a \nmechanism for identifying and managing the impact of changing \ntechnology to the technical requi rements and integrate the resulting \nconsequences into the technical requirements. [OUTCOME 5] \nACQ.11.BP9: Identify constraints and standards. Identify constraints \nand standards applicable to the technical requirements (e.g. open systems \nstandards). [OUTCOME 6] \nACQ.11.BP10: Ensure compliance of stated requirements. Ensure that \nthe technical requirements include compliance with identified relevant \nstandards, including environment effect evaluation, safety and security \nstandards where appropriate. [OUTCOME 6] \nOutput work \nproducts \n08-28 Change management plan → [OUTCOME 4] \n08-51 Technology monitoring plan → [OUTCOME 5] \n13-04 Communication record → [OUTCOME 3] \n13-17 Customer request  → [OUTCOME 1] \n13-21 Change control record  → [OUTCOME 2] \n13-24 Validation results  → [OUTCOME 6] \n14-01 Change history   → [OUTCOME 2] \n14-02 Corrective action register → [OUTCOME 2] \n14-50 Stakeholder groups list → [OUTCOME 1] \n17-00 Requirement specification → [OUTCOME 6] \n17-03 Customer requirements → [OUTCOME 6]\n\n### ACQ.12 Legal and Administrative Requirements\n\nProcess ID ACQ.12 \n\n  \n \n \n \n© VDA Quality Management Center 29 \n \n \nProcess name Legal and Administrative Requirements \nProcess purpose The purpose of the Legal and Administrative Requirements Process is to \ndefine the awarding aspects – expectations, liabilities, legal and other \nissues and which comply with national and international laws of contract. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) a contractual approach is defined which is compliant with relevant \nnational, international and regulatory laws, guidance and policies; \n2) an agreement, (contractual) terms and conditions are defined to \ndescribe how the supplier will meet the needs and expectations; \n3) acceptance criteria and mechanisms for handling of breaches to the \nfulfillment of contract are established; \n4) the rights of the acquirer to assume, modify or evaluate, directly or \nindirectly Intellectual Property Rights are established; \n5) warranties and service level agreements are provided for where \napplicable; \n6) provision for the suppliers to deliver other requirements (e.g. quality \nplan, escrow arrangements etc.) is defined; and \n7) recognized criteria for proprietary, regulatory and other product \nliabilities issues are established. \nBase practices ACQ.12.BP1: Identify relevant regulations. Identify relevant national, \ninternational and regulatory laws, guidance and policies. [OUTCOME 1] \nACQ.12.BP2: Consider relevant regulations . Consider identified \nrelevant laws, guidance and policy when defining a contractual approach.  \n[OUTCOME 2] \nACQ.12.BP3: Agree on (contractual) terms and conditions. \n[OUTCOME 2] \nNOTE 1: This may include \n• responsibilities of the purchaser and supplier; and the basis for payments \n• responsibility for maintenance and upgrades \n• a separate maintenance or support agreement \n• kind of payment \nACQ.12.BP4: Ensure usage of agreed terms and conditions . Ensure \nthe usage of agreed terms and conditions when describing how the supplier \nwill meet the needs and expectations. [OUTCOME 2] \nACQ.12.BP5: Establish acceptance criteria. [OUTCOME 3] \nACQ.12.BP6: Establish escalation mechanisms. Establish mechanisms \nfor handling of breaches to the fulfillment of contract. [OUTCOME 3] \nNOTE 2: This may include planning of the control of contract changes.  \nACQ.12.BP7: Establish management of intellectual property rights . \nEstablish the rights of the acquirer to assume, modify or evaluate, directly \nor indirectly, Intellectual Property Rights. [OUTCOME 4] \nACQ.12.BP8: Provide for warranties and service level agreements . \nProvide for warranties and service level agreements where applicable.  \n[OUTCOME 5] \n\n  \n \n \n \n© VDA Quality Management Center 30 \n \n \nACQ.12.BP9: Define provision for the suppliers. Define provision for the \nsuppliers to deliver other requirements such as  quality plan or escrow \narrangements. [OUTCOME 6] \nACQ.12.BP10: Establish criteria  for liability issues . Establish \nrecognized criteria for proprietary, regulatory and other product liabilit y \nissues. [OUTCOME 7] \nOutput work \nproducts \n02-00 Contract   → [OUTCOME 1-7] \n02-01 Commitment/agreement → [OUTCOME 2, 4, 5, 6, 7] \n10-00 Process description  → [OUTCOME 1, 3] \n14-02 Corrective action register → [OUTCOME 3] \n17-00 Requirement specification → [OUTCOME 1-7] \n18-01 Acceptance criteria  → [OUTCOME 3]\n\n### ACQ.13 Project Requirements\n\nProcess ID ACQ.13 \nProcess name Project Requirements \nProcess purpose The purpose of the Project Requirements Process is to specify the \nrequirements to ensure the acquisition project is performed with adequate \nplanning, staffing, directing, organizing and control over project tasks and \nactivities. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) consistency between financial, technical, contractual and project \nrequirements is established; \n2) requirements for the organizational, management, controlling, and \nreporting aspects of a project are defined; \n3) requirements for adequate staffing of projects by a competent team \n(e.g. resources with requisite legal, contractual, technical and project \ncompetence) with clear responsibilities and goals are defined; \n4) the needs for exchanging information between all affected parties are \nestablished; \n5) requirements for the completion and acceptance of interim work \nproducts and release of payments are established; \n6) potential risks are identified; \n7) requirements for ownership of interactions and relationships with \nsuppliers are defined; \n8) rights for use and distribution of the product by the customer and \nsupplier are defined; and \n9) support and maintenance requirements are established. \nBase practices ACQ.13.BP1: Identify relevant groups . Identify relevant \nparties/stakeholders and experts for financial, technical, contract and \nproject issues. [OUTCOME 1] \nACQ.13.BP2: Communicate with relevant groups . Communicate with \nthe relevant parties regarding the specification of financial, technical, \ncontract and project requirements. [OUTCOME 1] \n\n  \n \n \n \n© VDA Quality Management Center 31 \n \n \nACQ.13.BP3: Define organizational requirements. Define requirements \nfor the organizational aspect of the project. [OUTCOME 2] \nNOTE 1: Requirements for the organizational aspects refer to the organization \nof the people on the project e.g. who is responsible etc. at different levels. \nACQ.13.BP4: Define management requirements . Define requirements \nfor the management, controlling and reporting aspect s of the project.  \n[OUTCOME 2] \nNOTE 2: Requirements for the management, controlling and reporting aspects \nof the project may be \n• the necessity to structure the acquisition process in logical phases \n• the use of experience and skills of third parties \n• the sketch of a work breakdown structure \n• that all documentation conforms to appropriate standards, and should be \ncontractually agreed with the suppliers \n• requirements to supplier’s processes, process interfaces and joint \nprocesses \nACQ.13.BP5: Identify required competenc y. Identify required \ncompetency (e.g. legal, contractual, technical and pro ject competencies) \nfor key resources. [OUTCOME 3] \nACQ.13.BP6: Define responsibilities and goals . Define responsibilities \nand goals of the team members. [OUTCOME 3] \nACQ.13.BP7: Identify information needs . Identify information needs of \nthe relevant parties. [OUTCOME 4] \nACQ.13.BP8: Define exchange of information. Consider how exchange \nof information may be affected. [OUTCOME 4] \nNOTE 3: Techniques for supporting the exchange of information may include \nelectronic solutions, face-to-face interactions and decisions about the \nfrequency. \nACQ.13.BP9: Establish criteria for interim work products.  Establish \nrequirements for the completion and acceptance of interim work products. \n[OUTCOME 5] \nACQ.13.BP10: Establish payment requirements. Establish \nrequirements for the release of payments. [OUTCOME 5] \nNOTE 4: This may include for example the decision to link the major \nproportion of the supplier’s payment to successful completion of the \nacceptance test, the definition of supplier performance criteria and ways to \nmeasure, test and link them to the payment schedule or the decision that \npayments be made on agreed results. \nACQ.13.BP11: Identify risks . Identify risks associated with project life \ncycle and with suppliers. [OUTCOME 6] \nNOTE 5: Potential risk areas are for example stakeholder (customer, user, and \nsponsor), product (uncertainty, complexity), processes (acquisition, \nmanagement, support, and organization), resources (human, financial, time, \ninfrastructure), context (corporate context, project context, regulatory context, \nlocation) or supplier (process maturity, resources, experience). \nACQ.13.BP12: Communicate risks.  Assure that all identified risks are \ncommunicated to the relevant parties. [OUTCOME 6] \n\n  \n \n \n \n© VDA Quality Management Center 32 \n \n \nACQ.13.BP13: Define ownership of relationships. Define requirements \nfor ownership of interactions and relationships with suppliers. [OUTCOME 7] \nNOTE 6: This may include for example who has the lead on which type of \ninteraction, who maintains an open-issue-list, who are the contact persons for \nmanagement, technical and contractual issues, the frequency and type of \ninteraction, to whom the relevant information is distributed. \nACQ.13.BP14: Define rights for use and distribution.  Define rights for \nuse and distribution of the product by the customer and supplier. [OUTCOME \n8] \nNOTE 7: This may include unrestricted right of product use or delivery of \nsource code trial installation for \"sale or return\". \nACQ.13.BP15: Establish support and maintenance requirements. \n[OUTCOME 9] \nNOTE 8: This may include for example training requirements, the decision if \nsupport and maintenance should be conducted in-house or by a third party or \nthe establishment of service level agreements. \nOutput work \nproducts \n02-00 Contract   → [OUTCOME 1-9] \n13-19 Review record   → [OUTCOME 1] \n13-20 Risk action request  → [OUTCOME 6] \n17-00 Requirement specification → [OUTCOME 1-9]\n\n### ACQ.14 Request for Proposals\n\nProcess ID ACQ.14 \nProcess name Request for Proposals \nProcess purpose The purpose of the Request for Proposals Process is to prepare and \nissue the necessary acquisition requirements. The documentation will \ninclude, but not be limited to, the contract, project, finance and technical \nrequirements to be provided for use in the Call For Proposals (CFP) / \nInvitation To Tender (ITT). \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) rules are defined for proposal/tender invitation and evaluation which \ncomply with the acquisition policy and strategy; \n2) the baseline technical and non-technical requirements are assembled \nto accompany the CFP / ITT; \n3) the agreement (contractual) terms of reference and conditions for \nCFP / ITT are established; \n4) the financial terms of reference for costs and payments for CFP / ITT \nare defined; \n5) the project terms of reference for CFP / ITT are defined; \n6) the technical terms of reference for CFP / ITT are defined; and \n7) a CFP / ITT is prepared and issued in accordance with acquisition \npolicies and which complies with relevant national, international and \nregulatory laws, requirements, and policies. \n\n  \n \n \n \n© VDA Quality Management Center 33 \n \n \nBase practices ACQ.14.BP1: Define rules for CFP / ITT. Define rules for proposal/tender \ninvitation and evaluation which comply with the acquisition policy and \nstrategy. [OUTCOME 1] \nNOTE 1: Examples are: \n• a rule that a multiphase tendering process should be used (reasonable \nwhen uncertainty is high) \n• pre-planned interactions with suppliers \n• a rule that the supplier will be informed about the evaluation criteria \n• a rule that a timetable should be stipulated to allow suppliers specified \ntimes to respond to the call for tender \n• a rule prescribing to use a two stage evaluation process (reduce a long list \nof suppliers to a short list of suppliers who are invited to tender) \nACQ.14.BP2: Assemble requirements. Assemble the baseline technical \nand non-technical requirements to accompany the CFP / ITT. [OUTCOME 2] \nNOTE 2: The goal is to provide the supplier with an in-depth understanding of \nyour business to enable him to offer the specified solution. \nACQ.14.BP3: Establish terms and conditions for CFP  / ITT. Establish \nthe agreement (contractual) terms of reference and conditions for CFP  / \nITT. [OUTCOME 3] \nACQ.14.BP4: Define financial terms.  Define the financial terms of \nreference for costs and payments for CFP / ITT. [OUTCOME 4] \nACQ.14.BP5: Define project terms. Define the project terms of reference \nfor CFP / ITT. [OUTCOME 5] \nNOTE 3: The overall purpose of this is to communicate the documented \nbusiness requirements of the acquisition to the suppliers. \nACQ.14.BP6: Define technical terms.  Define the technical terms of \nreference for CFP / ITT. [OUTCOME 6] \nACQ.14.BP7: Identify relevant regulations. Identify international and \nregulatory laws, requirements and policies which are relevant for CFP \npreparation. [OUTCOME 7] \nACQ.14.BP8: Prepare and issue a CFP / ITT. Prepare and issue a CFP \n/ ITT in accordance with acquisition policies, which complies with relevant \nnational, international and regulatory laws, requirements and policies.  \n[OUTCOME 7] \nOutput work \nproducts \n02-01 Commitment/agreement → [OUTCOME 3] \n12-01 Request for proposal  → [OUTCOME 7] \n17-00 Requirement specification → [OUTCOME 2, 4, 5, 6] \n19-11 Validation strategy  → [OUTCOME 1] \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 34\n\n### ACQ.15 Supplier Qualification\n\nProcess ID ACQ.15 \nProcess name Supplier Qualification \nProcess purpose The purpose of the Supplier Qualification Process is to evaluate and \ndetermine if the potential supplier(s) have the required qualification for \nentering the proposal/tender evaluation process. In this process, the \ntechnical background, quality system, servicing, user support capabilities \netc. will be evaluated. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) criteria are established for qualifying suppliers; \n2) supplier capability determination is performed as necessary; \n3) the suppliers which possess required qualification are short-listed for \ntender solution(s) evaluation; \n4) any shortfalls in capability are identified and evaluated; and \n5) any corrective action required by the acquirer is evaluated and \nperformed. \nBase practices ACQ.15.BP1: Establish qualification criteria.  Establish criteria for \nqualifying suppliers. [OUTCOME 1] \nNOTE 1: This could include \n• technical background of the supplier \n• quality system on the supplier side \n• servicing \n• user support capabilities \nACQ15.BP2: Evaluate supplier. Perform supplier capability determination \nas necessary. [OUTCOME 2] \nNOTE 2: It is often required that the supplier should have an ISO 9001 and/or \nan ISO 16949 certificate. \nNOTE 3: Establish the specific target levels against which the supplier’s \ncapability will be measured. \nACQ.15.BP3: Short-list suppliers with required qualification. Short-list \nthe suppliers for tender solution(s) evaluation which possess required \nqualification. [OUTCOME 3] \nACQ.15.BP4: Evaluate an y shortfalls.  Identify and evaluate any \nshortfalls. [OUTCOME 4] \nNOTE 4: This may include developing a method for evaluating risk related to \nthe supplier or the proposed solution. \nACQ.15.BP5: Perform corrective actions.  Evaluate and perform \ncorrective action required by the acquirer. [OUTCOME 5] \nOutput work \nproducts \n14-02 Corrective action register  → [OUTCOME 5] \n14-05 Preferred suppliers register  → [OUTCOME 3] \n15-16 Improvement opportunity  → [OUTCOME 4] \n15-21 Supplier evaluation report  → [OUTCOME 2] \n18-50 Supplier qualification criteria  → [OUTCOME 1] \n\n  \n \n \n \n© VDA Quality Management Center 35\n\n## Supply process group (SPL)\n\n\n\n### SPL.1 Supplier Tendering\n\nProcess ID SPL.1 \nProcess name Supplier Tendering \nProcess purpose The purpose of the Supplier Tendering Process is to establish an \ninterface to respond to customer inquiries and requests for proposal, \nprepare and submit proposals, and confirm assignments through the \nestablishment of a relevant agreement/contract. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) a communication interface is established and maintained in order to \nrespond to customer inquiries and requests for proposal; \n2) requests for proposal are evaluated according to defined criteria to \ndetermine whether or not to submit a proposal; \n3) the need to undertake preliminary surveys or feasibility studies is \ndetermined; \n4) suitable staff are identified to perform the proposed work; \n5) a supplier proposal is prepared in response to the customer request; \nand \n6) formal confirmation of agreement is obtained. \nBase practices SPL.1.BP1: Establish communication interface.  A communication \ninterface is established and maintained in order to respond to customer \ninquiries or requests for proposal. [OUTCOME 1] \nSPL.1.BP2: Perform customer i nquiry screening.  Perform customer \nenquiry screening to ensure validity of contract, ensuring the right person \nis quickly identified to process the lead. [OUTCOME 1] \nSPL.1.BP3: Establish customer proposal evaluation criteria. Establish \nevaluation criteria to determine whether or not to submit a proposal based \non appropriate criteria. [OUTCOME 2] \nSPL.1.BP4: Evaluate customer request for proposal.  Requests for \nproposal are evaluated according to appropriate criteria. [OUTCOME 2] \nSPL.1.BP5: Determine need for preliminary pre -studies. Determine \nneed for p reliminary pre -studies to ensure that a firm quotation can be \nmade based on available requirements. [OUTCOME 3] \nSPL.1.BP6: Identify and nominate staff. Identify and nominate staff with \nappropriate competence for the assignment. [OUTCOME 4] \nSPL.1.BP7: Prepare supplier proposal response.  A supplier proposal \nresponse is prepared in response to the customer request. [OUTCOME 5] \nSPL.1.BP8: Establish confirmation of agreement. Formally confirm the \nagreement to protect the interests of customer and supplier. [OUTCOME 6] \nNOTE.1: The nature of the commitment should be agreed and evidenced in \nwriting. Only authorized signatories should be able to commit to a contract.  \nOutput work \nproducts \n02-01 Commitment/agreement → [OUTCOME 6] \n\n  \n \n \n \n© VDA Quality Management Center 36 \n \n \n08-12 Project plan    → [OUTCOME 4] \n12-04 Supplier proposal response → [OUTCOME 5] \n13-04 Communication record → [OUTCOME 1, 6] \n13-15 Proposal review record → [OUTCOME 3, 4] \n13-19 Review record   → [OUTCOME 2]\n\n### SPL.2 Product Release\n\nProcess ID SPL.2 \nProcess name Product Release \nProcess purpose The purpose of the Product Release Process is to control the release of a \nproduct to the intended customer. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) the contents of the product release are determined; \n2) the release is assembled from configured items; \n3) the release documentation is defined and produced; \n4) the release delivery mechanism and media are determined; \n5) release approval is effected against defined criteria; \n6) the product release is made available to the intended customer; and \n7) confirmation of release is obtained. \nBase practices SPL.2.BP1: Define the functional content of releases. Establish a plan \nfor releases that identifies the functionality to be included in each release. \n[OUTCOME 1, 3] \nNOTE 1: The plan should point out which application parameters influencing \nthe identified functionality are effective for which release. \nSPL.2.BP2: Define release products.  The products associated with the \nrelease are defined. [OUTCOME 1] \nNOTE 2: The release products may include programming tools where these \nare stated. In automotive terms a release may be associated with a sample \ne.g. A, B, C. \nSPL.2.BP3: Establish a product release classification and numbering \nscheme. A product release classification and numbering sch eme are \nestablished based upon the intended purpose and expectations of the \nrelease(s). [OUTCOME 2] \nNOTE 3: A release numbering implementation may include \n• the major release number \n• the feature release number \n• the defect repair number \n• the alpha or beta release \n• the iteration within the alpha or beta release \nSPL.2.BP4: Define the build activities and build environment.  A \nconsistent build process is established and maintained. [OUTCOME 2] \nNOTE 4: A specified and consistent build environment should be used by all \nparties.  \n\n  \n \n \n \n© VDA Quality Management Center 37 \n \n \nSPL.2.BP5: Build the release from configured items. The release is built \nfrom configured items to ensure integrity. [OUTCOME 2] \nNOTE 5: Where relevant the software release should be programmed onto the \ncorrect hardware revision before release. \nSPL2.BP6: Communicate the type, service level and duration of \nsupport for a release. The type, service level and duration of support for \na release are identified and communicated. [OUTCOME 3] \nSPL.2.BP7: Determine the delivery media type for the releas e. The \nmedia type for product delivery is determined in accordance with the needs \nof the customer. [OUTCOME 4] \nNOTE 6: The media type for delivery may be intermediate (placed on an \nadequate media and delivered to customer), or direct (such as delivered in \nfirmware as part of the package) or a mix of both. The release may be \ndelivered electronically by placement on a server. The release may also need \nto be duplicated before delivery. \nSPL.2.BP8: Identify the packaging for the release media.  The \npackaging for different types of media is identified. [OUTCOME 4] \nNOTE 7: The packaging for certain types of media may need physical or \nelectronic protection for instance specific encryption techniques. \nSPL.2.BP9: Define and produce the product release \ndocumentation/release notes. Ensure that all documentation to support \nthe release is produced, reviewed, approved and available. [OUTCOME 3] \nSPL.2.BP10: Ensure product release approval before delivery. Criteria \nfor the product release are satisfied before release takes pla ce. [OUTCOME \n5] \nSPL.2.BP11: Ensure consistency. Ensure consistency between software \nrelease number, paper label and EPROM-Label (if relevant). [OUTCOME 5] \nSPL.2.BP12: Provide a release note.  A release is supported by \ninformation detailing key characteristics of the release. [OUTCOME 6] \nNOTE 8: The release note may include an introduction, the environmental \nrequirements, installation procedures, product invocation, new feature \nidentification and a list of defect resolutions, known defects and workarounds.  \nSPL.2.BP13: Deliver the release to the intended customer. The product \nis delivered to the intended customer with positive confirmation of receipt.  \n[OUTCOME 6, 7] \nNOTE 9: Confirmation of receipt may be achieved by hand, electronically, by \npost, by telephone or through a distribution service provider. \nNOTE 10: These practices are typically supported by the SUP.8 Configuration \nManagement Process. \nOutput work \nproducts \n08-16 Release plan    → [OUTCOME 1, 3] \n11-03 Product release information  → [OUTCOME 1, 3, 4, 6] \n11-04 Product release package  → [OUTCOME 2, 3, 6] \n11-07 Temporary solution   → [OUTCOME 6] \n13-06 Delivery record    → [OUTCOME 6,7] \n13-13 Product release approval record → [OUTCOME 5] \n\n  \n \n \n \n© VDA Quality Management Center 38 \n \n \n15-03 Configuration status report  → [OUTCOME 2] \n18-06 Product release criteria  → [OUTCOME 5, 7]\n\n## System engineering process group (SYS)\n\n\n\n### SYS.1 Requirements Elicitation\n\nProcess ID SYS.1 \nProcess name Requirements Elicitation \nProcess purpose The purpose of the Requirements Elicitation Process is to gather, \nprocess, and track evolving stakeholder needs and requirements \nthroughout the lifecycle of the product and/or service so as to establish a \nrequirements baseline that serves as the basis for defining the needed \nwork products. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) continuing communication with the stakeholder is established; \n2) agreed stakeholder requirements are defined and baselined; \n3) a change mechanism is established to evaluate and incorporate \nchanges to stakeholder requirements into the baselined requirements \nbased on changing stakeholder needs; \n4) a mechanism is established for continuous monitoring of stakeholder \nneeds; \n5) a mechanism is established for ensuring that customers can easily \ndetermine the status and disposition of their requests; and  \n6) changes arising from changing technology and stakeholder needs are \nidentified, the associated risks assessed and their impact managed. \nBase practices SYS.1.BP1: Obtain stakeholder requirements and requests.  Obtain \nand define stakeholder requirements and requests through direct \nsolicitation of customer input and through review of customer business \nproposals (where relevant), target operating and hardware environment, \nand other documents bearing on customer requirements. [OUTCOME 1, 4] \nNOTE 1: Requirements elicitation may involve the customer and the supplier.  \nNOTE 2: The agreed stakeholder requirements and evaluation of any change \nmay be based on feasibility studies and/or cost and time analyzes.  \nNOTE 3: The information needed to keep traceability for each customer \nrequirement has to be gathered and documented.  \nSYS.1.BP2: Understand stakeholder expectations.  Ensure that both \nsupplier and customer understand each requirement in the same way. \n[OUTCOME 2]  \nNOTE 4: Reviewing the requirements and requests with the customer supports \na better understanding of customer needs and expectations. Refer to the \nprocess SUP.4 Joint Review.  \nSYS.1.BP3: Agree on requirements.  Obtain an explicit agreement from \nall relevant parties to work on these requirements. [OUTCOME 2] \n\n  \n \n \n \n© VDA Quality Management Center 39 \n \n \nSYS.1.BP4: Establish stakeholder requirements baseline.  Formalize \nthe stakeholder's requirements and establish them as a baseline for project \nuse and monitoring against stakeholder needs. The supplier should \ndetermine the requirements not s tated by the stakeholder but necessary \nfor specified and intended use and include them in the baseline. [OUTCOME \n2, 3] \nSYS.1.BP5: Manage stakeholder requirements changes.  Manage all \nchanges made to the stakeholder requirements against the stakeholder \nrequirements baseline to ensure enhancements resulting from changing \ntechnology and stakeholder needs are identified and that those who are \naffected by the changes are able to assess the impact and risks and initiate \nappropriate change control and mitigation actions. [OUTCOME 3, 6] \nNOTE 5: Requirements change may arise from different sources as for \ninstance changing technology and stakeholder needs, legal constraints.  \nNOTE 6: An information management system may be needed to manage, \nstore and reference any information gained and needed in defining agreed \nstakeholder requirements.  \nSYS.1.BP6: Establish customer -supplier query communication \nmechanism. Provide means by which the customer can be aware of the \nstatus and disposition of their requirements changes and th e supplier can \nhave the ability to communicate necessary information, including data, in a \ncustomer-specified language and format. [OUTCOME 5] \nNOTE 7: Any changes should be communicated to the customer before \nimplementation in order that the impact, in terms of time, cost and functionality \ncan be evaluated. \nNOTE 8: This may include joint meetings with the customer or formal \ncommunication to review the status for their requirements and requests; Refer \nto the process SUP.4 Joint Review. \nNOTE 9: The formats of the information communicated by the supplier may \ninclude computer-aided design data and electronic data exchange.  \nOutput work \nproducts \n08-19 Risk management plan → [OUTCOME 6] \n08-20 Risk mitigation plan  → [OUTCOME 6] \n13-04 Communication record → [OUTCOME 1, 4] \n13-19 Review record   → [OUTCOME 4, 5] \n13-21 Change control record  → [OUTCOME 3, 4] \n15-01 Analysis report   → [OUTCOME 2, 3, 6] \n17-03 Stakeholder Requirements → [OUTCOME 1, 2]\n\n### SYS.2 System Requirements Analysis\n\nProcess ID SYS.2 \nProcess name System Requirements Analysis \nProcess purpose The purpose of the System Requirements Analysis Process is to \ntransform the defined stakeholder requirements into a set of system \nrequirements that will guide the design of the system. \n\n  \n \n \n \n© VDA Quality Management Center 40 \n \n \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a defined set of system requirements is established; \n2) system requirements are categorized and analyzed for correctness \nand verifiability; \n3) the impact of system requirements on the operating environment is \nanalyzed; \n4) prioritization for implementing the system requirements is defined; \n5) the system requirements are updated as needed; \n6) consistency and bidirectional traceability are established between \nstakeholder requirements and system requirements; \n7) the system requirements are evaluated for cost, schedule and \ntechnical impact; and \n8) the system requirements are agreed and communicated to all affected \nparties. \nBase practices SYS.2.BP1: Specify system requirements.  Use the stakeholder \nrequirements and changes to the stakeholder requirements to identify the \nrequired functions and capabilities of the system. Specify functional and \nnon-functional system requirements in a system requirements \nspecification. [OUTCOME 1, 5, 7] \nNOTE 1: Application parameter influencing functions and capabilities are part \nof the system requirements.  \nNOTE 2: For changes to the stakeholder's requirements SUP.10 applies . \nSYS.2.BP2: Structure system requirements.  Structure the system \nrequirements in the system requirements specification by e.g. \n• grouping to project relevant clusters, \n• sorting in a logical order for the project, \n• categorizing based on relevant criteria for the project, \n• prioritizing according to stakeholder needs. \n[OUTCOME 2, 4] \nNOTE 3: Prioritizing typically includes the assignment of functional content to \nplanned releases. Refer to SPL.2.BP1. \nSYS.2.BP3: Analyze system requirements. Analyze the specified system \nrequirements including their interdependencies to ensure correctness, \ntechnical feasibility  and verifiability, and to support risk identification. \nAnalyze the impact on cost, schedule and the technical impact. [OUTCOME \n1, 2, 7] \nNOTE 4: The analysis of impact on cost and schedule supports the adjustment \nof project estimates. Refer to MAN.3.BP5. \nSYS.2.BP4: Analyze the impact on the operating environment. Identify \nthe interfaces between the specified system and other elements of the \noperating environment. Analyze the impact that the system requirements \nwill have on these interfaces and the operating environment. [OUTCOME 3, 7] \nSYS.2.BP5: Develop verification criteria. Develop the verification criteria \nfor each system requirement that define the qualitative and quantitative \nmeasures for the verification of a requirement. [OUTCOME 2, 7] \nNOTE 5: Verification criteria demonstrate that a requirement can be verified \nwithin agreed constraints and is typically used as the input for the development \n\n  \n \n \n \n© VDA Quality Management Center 41 \n \n \nof the system test cases or other verification measures that ensures \ncompliance with the system requirements. \nNOTE 6: Verification which cannot be covered by testing is covered by SUP.2.  \nSYS.2.BP6: Establish bidirectional traceability.  Establish bidirectional \ntraceability between stakeholder requirements and system requirements . \n[OUTCOME 6] \nNOTE 7: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSYS.2.BP7: Ensure consistency . Ensure consistency between \nstakeholder requirements and system requirements. [OUTCOME 6] \nNOTE 8: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records.  \nSYS.2.BP8: Communicate agreed system requirements. Communicate \nthe agreed system requirements and updates to system requirements to all \nrelevant parties. [OUTCOME 8] \nOutput work \nproducts \n13-04 Communication record  → [OUTCOME 8] \n13-19 Review record    → [OUTCOME 6] \n13-21 Change control record   → [OUTCOME 1] \n13-22 Traceability record   → [OUTCOME 6] \n15-01 Analysis report    → [OUTCOME 2, 3, 4, 7] \n17-08 Interface requirements  specification → [OUTCOME 1, 3] \n17-12 System requirements specification → [OUTCOME 1, 5] \n17-50 Verification criteria   → [OUTCOME 2]\n\n### SYS.3 System Architectural Design\n\nProcess ID SYS.3 \nProcess name System Architectural Design \nProcess purpose The purpose of the System Architectural Design Process is to establish a \nsystem architectural design and identify which system requirements are to \nbe allocated to which elements of the system, and to evaluate the system \narchitectural design against defined criteria. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a system architectural design is defined that identifies the elements of \nthe system; \n2) the system requirements are allocated to the elements of the system; \n3) the interfaces of each system element are defined; \n4) the dynamic behavior of the system elements is defined; \n5) consistency and bidirectional traceability are established between \nsystem requirements and system architectural design; and \n6) the system architectural design is agreed and communicated to all \naffected parties. \nBase practices SYS.3.BP1: Develop system architectural design.  Develop and \ndocument the system architectural design that specifies the elements of the \n\n  \n \n \n \n© VDA Quality Management Center 42 \n \n \nsystem with respect to functional and non-functional system requirements. \n[OUTCOME 1] \nNOTE 1: The development of system architectural design typically includes the \ndecomposition into elements across appropriate hierarchical levels. \nSYS.3.BP2: Allocate system r equirements. Allocate the system \nrequirements to the elements of the system architectural design. [OUTCOME \n2] \nSYS.3.BP3: Define interfaces of system elements. Identify, develop and \ndocument the interfaces of each system element. [OUTCOME 3] \nSYS.3.BP4: Describe dynamic behavior.  Evaluate and document the \ndynamic behavior of the interaction between system elements. [OUTCOME 4] \nNOTE 2: Dynamic behavior is determined by operating modes (e.g. start-up, \nshutdown, normal mode, calibration, diagnosis, etc.). \nSYS.3.BP5: Evaluate alternative system architectures.  Define \nevaluation criteria for the architecture. Evaluate alternative system \narchitectures according to the defined criteria. Record the rationale for the \nchosen system architecture. [OUTCOME 1] \nNOTE 3: Evaluation criteria may include quality characteristics (modularity, \nmaintainability, expandability, scalability, reliability, security realization and \nusability) and results of make-buy-reuse analysis. \nSYS.3.BP6: Establish bidirectional traceability.  Establish bidirectional \ntraceability between system requirements and elem ents of the system \narchitectural design. [OUTCOME 5] \nNOTE 4: Bidirectional traceability covers allocation of system requirements to \nthe elements of the system architectural design. \nNOTE 5: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSYS.3.BP7: Ensure consistency.  Ensure consistency between system \nrequirements and the system architectural design. [OUTCOME 1, 2, 5, 6] \nNOTE 6: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nNOTE 7: System requirements typically include system architectural \nrequirements. Refer to BP5. \nSYS.3.BP8: Communicate agreed system architectural design.  \nCommunicate the agreed system architectural design and updates to \nsystem architectural design to all relevant parties. [OUTCOME 6] \nOutput work \nproducts \n04-06 System architectural design  → [OUTCOME 1, 2, 3, 4, 5] \n13-04 Communication record  → [OUTCOME 6] \n13-19 Review record    → [OUTCOME 5] \n13-22 Traceability record   → [OUTCOME 5] \n17-08 Interface requirements specification → [OUTCOME 3] \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 43\n\n### SYS.4 System Integration and Integration Test\n\nProcess ID SYS.4 \nProcess name System Integration and Integration Test \nProcess purpose The purpose of the System Integration and Integration Test Process is to \nintegrate the system items to produce an integrated system consistent \nwith the system architectural design and to ensure that the system items \nare tested to provide evidence for compliance of the integrated system \nitems with the system architectural design, including the interfaces \nbetween system items. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a system integration strategy consistent with the project plan, the \nrelease plan and the system architectural design is developed to \nintegrate the system items; \n2) a system integration test strategy including the regression test \nstrategy is developed to test the system item interactions; \n3) a specification for system integration test according to the system \nintegration test strategy is developed that is suitable to provide \nevidence for compliance of the integrated system items with the \nsystem architectural design, including the interfaces between system \nitems; \n4) system items are integrated up to a complete integrated system \naccording to the integration strategy; \n5) test cases included in the system integration test specification are \nselected according to the system integration test strategy and the \nrelease plan; \n6) system item interactions are tested using the selected test cases and \nthe results of system integration testing are recorded; \n7) consistency and bidirectional traceability between the elements of the \nsystem architectural design and test cases included in the system \nintegration test specification and bidirectional traceability between test \ncases and test results is established; and \n8) results of the system integration test are summarized and \ncommunicated to all affected parties. \nBase practices SYS.4.BP1: Develop system integration strategy. Develop a strategy for \nintegrating the system items consistent with the project plan and the \nrelease plan. Identify system items based on the system architectural \ndesign and define a sequence for integrating them. [OUTCOME 1] \nSYS.4.BP2: Develop system inte gration test strategy including \nregression test strategy.  Develop a strategy for testing the integrated \nsystem items following the integration strategy. This includes a regression \ntest strategy for re -testing integrated system items if a system item is \nchanged. [OUTCOME 2]  \nSYS.4.BP3: Develop specification for system integration test. Develop \nthe test specification for system integration test including the test cases for \neach integration step of a system item according to the system integration \ntest strategy. The test specification shall be suitable to provide evidence for \ncompliance of the integrated system items with the system architectural \ndesign. [OUTCOME 3] \n\n  \n \n \n \n© VDA Quality Management Center 44 \n \n \nNOTE 1: The interface descriptions between system elements are an input for \nthe system integration test cases. \nNOTE 2: Compliance to the architectural design means that the specified \nintegration tests are suitable to prove that the interfaces between the system \nitems fulfill the specification given by the system architectural design. \nNOTE 3: The system integration test cases may focus on \n• the correct signal flow between system items \n• the timeliness and timing dependencies of signal flow between system \nitems  \n• the correct interpretation of signals by all system items using an interface  \n• the dynamic interaction between system items \nNOTE 4: The system integration test may be supported using simulation of the \nenvironment (e.g. Hardware-in-the-Loop simulation, vehicle network \nsimulations, digital mock-up). \nSYS.4.BP4: Integrate system items.  Integrate the sy stem items to an \nintegrated system according to the system integration strategy. [OUTCOME 4] \nNOTE 5: The system integration can be performed step wise integrating \nsystem items (e.g. the hardware elements as prototype hardware, peripherals \n(sensors and actuators), the mechanics and integrated software) to produce a \nsystem consistent with the system architectural design. \nSYS.4.BP5: Select test cases.  Select test cases from the system \nintegration test specification. The selection of test cases shall have \nsufficient coverage according to the system integration test strategy and \nthe release plan. [OUTCOME 5] \nSYS.4.BP6: Perform system integration test . Perform the system \nintegration test using the selected test cases. Record the integration test \nresults and logs. [OUTCOME 6] \nNOTE 6: See SUP.9 for handling of non-conformances.  \nSYS.4.BP7: Establish bidirectional traceability.  Establish bidirectional \ntraceability between elements of the system architectural design and test \ncases included in the system integration test specification.  \nEstablish bidirectional traceability between test cases included in the \nsystem integration test  specification and system integration test results. \n[OUTCOME 7] \nNOTE 7: Bidirectional traceability supports coverage, consistency and impact \nanalysis.  \nSYS.4.BP8: Ensure consistency. Ensure consistency between elements \nof the system architectural design an d test cases included in the system \nintegration test specification. [OUTCOME 7] \nNOTE 8: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nSYS.4.BP9: Summarize and communicate results.  Summarize the \nsystem int egration test results and communicate them to all affected \nparties. [OUTCOME 8] \nNOTE 9: Providing all necessary information from the test case execution in a \nsummary enables other parties to judge the consequences.  \n\n  \n \n \n \n© VDA Quality Management Center 45 \n \n \nOutput work \nproducts \n08-50 Test specification  → [OUTCOME 3, 5] \n08-52 Test plan   → [OUTCOME 1, 2] \n11-06 System    → [OUTCOME 4] \n13-04 Communication record → [OUTCOME 8] \n13-19 Review record   → [OUTCOME 7] \n13-22 Traceability record  → [OUTCOME 7] \n13-50 Test result   → [OUTCOME 6, 8]\n\n### SYS.5 System Qualification Test\n\nProcess ID SYS.5 \nProcess name System Qualification Test \nProcess purpose The purpose of the System Qualification Test Process is to ensure that the \nintegrated system is tested to provide evidence for compliance with the  \nsystem requirements and that the system is ready for delivery. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a system qualification test strategy including regression test strategy \nconsistent with the project plan and release plan is developed to test \nthe integrated system; \n2) a specification for system qualification test of the integrated system \naccording to the system qualification test strategy is developed that is \nsuitable to provide evidence for compliance with the system \nrequirements; \n3) test cases included in the system qualification test specification are \nselected according to the system qualification test strategy and the \nrelease plan; \n4) the integrated system is tested using the selected test cases and the \nresults of system qualification test are recorded; \n5) consistency and bidirectional traceability are established between \nsystem requirements and test cases included in the system \nqualification test specification and between test cases and test results; \nand \n6) results of the system qualification test are summarized and \ncommunicated to all affected parties. \nBase practices SYS.5.BP1: Develop system qualification test strategy including \nregression test strategy. Develop a strategy for system qualification test \nconsistent with the project plan and the release plan. This includes a \nregression test strategy for re-testing the integrated system if a system item \nis changed. [OUTCOME 1] \nSYS.5.BP2: Develop specification for system qualification test.  \nDevelop the specification for system qualification test including test cases \nbased on the verification criteria according to the system qualification test \nstrategy. The test specification shall be suitable to provide evidence for \ncompliance of the integrated system with the system requirements . \n[OUTCOME 2]  \n\n  \n \n \n \n© VDA Quality Management Center 46 \n \n \nSYS.5.BP3: Select test cases.  Select test cases from the system \nqualification test specification. The selection of test cases shall have \nsufficient coverage according to the system qualification test strategy and \nthe release plan. [OUTCOME 3] \nSYS.5.BP4: Test integrated system. Test the integrated system using the \nselected test cases. Record the system qualification test results and logs. \n[OUTCOME 4] \nNOTE 1: See SUP.9 for handling of non-conformances. \nSYS.5.BP5: Establish bidirectional tracea bility. Establish bidirectional \ntraceability between system requirements and test cases included in the \nsystem qualification test specification. Establish bidirectional traceability \nbetween test cases included in the system qualification test specification  \nand system qualification test results. [OUTCOME 5]  \nNOTE 2: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSYS.5.BP6: Ensure consistency.  Ensure consistency between system \nrequirements and test cases included in the system qualification test \nspecification. [OUTCOME 5] \nNOTE 3: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nSYS.5.BP7: Summarize and communicate results.  Summarize the \nsystem qualification test results and commun icate them to all affected \nparties. [OUTCOME 6] \nNOTE 4: Providing all necessary information from the test case execution in a \nsummary enables other parties to judge the consequences. \nOutput work \nproducts \n08-50 Test specification  → [OUTCOME 2, 3] \n08-52 Test plan   → [OUTCOME 1] \n13-04 Communication record → [OUTCOME 6] \n13-19 Review record   → [OUTCOME 5] \n13-22 Traceability record  → [OUTCOME 5] \n13-50 Test result   → [OUTCOME 4, 6] \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 47\n\n## Software engineering process group (SWE)\n\n\n\n### SWE.1 Software Requirements Analysis\n\nProcess ID SWE.1 \nProcess name Software Requirements Analysis \nProcess purpose The purpose of the Software Requirements Analysis Process is to \ntransform the software related parts of the system requirements into a set \nof software requirements. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) the software requirements to be allocated to the software elements of \nthe system and their interfaces are defined; \n2) software requirements are categorized and analyzed for correctness \nand verifiability; \n3) the impact of software requirements on the operating environment is \nanalyzed; \n4) prioritization for implementing the software requirements is defined; \n5) the software requirements are updated as needed; \n6) consistency and bidirectional traceability are established between \nsystem requirements and software requirements; and consistency and \nbidirectional traceability are established between system architectural \ndesign and software requirements; \n7) the software requirements are evaluated for cost, schedule and \ntechnical impact; and  \n8) the software requirements are agreed and communicated to all \naffected parties. \nBase practices SWE.1.BP1: Specify software requirements.  Use the system \nrequirements and the system architecture and changes to system \nrequirements and architecture to identify the required functions and \ncapabilities of the software. Specify functional and non-functional software \nrequirements in a software requirements specification. [OUTCOME 1, 5, 7] \nNOTE 1: Application parameter influencing functions and capabilities are part \nof the system requirements. \nNOTE 2: In case of software development only, the system requirements and \nthe system architecture refer to a given operating environment (see also \nnote 5). In that case, stakeholder requirements should be used as the basis for \nidentifying the required functions and capabilities of the software as well as for \nidentifying application parameters influencing software functions and \ncapabilities. \nSWE.1.BP2: Structure software requirements.  Structure the software \nrequirements in the software requirements specification by e.g. \n• grouping to project relevant clusters,  \n• sorting in a logical order for the project,  \n• categorizing based on relevant criteria for the project, \n• prioritizing according to stakeholder needs.  \n[OUTCOME 2, 4] \nNOTE 3: Prioritizing typically includes the assignment of software content to \nplanned releases. Refer to SPL.2.BP1. \n\n  \n \n \n \n© VDA Quality Management Center 48 \n \n \nSWE.1.BP3: Analyze software requirements. Analyze the specified \nsoftware requirements including their interdependencies to ensure \ncorrectness, technical feasibility and verifiability,  and to support risk \nidentification. Analyze the impact on cost, schedule and the technical \nimpact. [OUTCOME 2, 7] \nNOTE 4: The analysis of impact on cost and schedule supports the adjustment \nof project estimates. Refer to MAN.3.BP5. \nSWE.1.BP4: Analyze the impact on the operating environment.  \nAnalyze the impact that the software requirements will have on i nterfaces \nof system elements and the operating environment. [OUTCOME 3, 7] \nNOTE 5: The operating environment is defined as the system in which the \nsoftware executes (e.g. hardware, operating system, etc.). \nSWE.1.BP5: Develop verification criteria.  Develop the verification \ncriteria for each software requirement that define the qualitative and \nquantitative measures for the verification of a requirement. [OUTCOME 2, 7] \nNOTE 6: Verification criteria demonstrate that a requirement can be verified \nwithin agreed constraints and is typically used as the input for the development \nof the software test cases or other verification measures that should \ndemonstrate compliance with the software requirements. \nNOTE 7: Verification which cannot be covered by testing is covered by SUP.2. \nSWE.1.BP6: Establish bidirectional traceability. Establish bidirectional \ntraceability between system requirements and software requirements. \nEstablish bidirectional traceability between the system architecture and \nsoftware requirements. [OUTCOME 6] \nNOTE 8: Redundancy should be avoided by establishing a combination of \nthese approaches that covers the project and the organizational needs. \nNOTE 9: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSWE.1.BP7: Ensure consi stency. Ensure consistency between system \nrequirements and software requirements. Ensure consistency between the \nsystem architecture and software requirements. [OUTCOME 6] \nNOTE 10: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nNOTE 11: In case of software development only, the system requirements and \nsystem architecture refer to a given operating environment (see also note 2). \nIn that case, consistency and bidirectional traceability have to be ensured \nbetween stakeholder requirements and software requirements. \nSWE.1.BP8: Communicate agreed software requirements.  \nCommunicate the agreed software requirements and updates to software \nrequirements to all relevant parties. [OUTCOME 8] \nOutput work \nproducts \n13-04 Communication record  → [OUTCOME 8] \n13-19 Review record    → [OUTCOME 6] \n13-21 Change control record   → [OUTCOME 5, 7] \n13-22 Traceability record   → [OUTCOME 1, 6] \n15-01 Analysis report    → [OUTCOME 2, 3, 4, 7] \n\n  \n \n \n \n© VDA Quality Management Center 49 \n \n \n17-08 Interface requirements specification → [OUTCOME 1, 3] \n17-11 Software requirements specification → [OUTCOME 1] \n17-50 Verification criteria   → [OUTCOME 2]\n\n### SWE.2 Software Architectural Design\n\nProcess ID SWE.2 \nProcess name Software Architectural Design \nProcess purpose The purpose of the Software Architectural Design Process is to establish \nan architectural design and to identify which software requirements are to \nbe allocated to which elements of the software, and to evaluate the \nsoftware architectural design against defined criteria. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a software architectural design is defined that identifies the elements \nof the software; \n2) the software requirements are allocated to the elements of the \nsoftware;  \n3) the interfaces of each software element are defined; \n4) the dynamic behavior and resource consumption objectives of the \nsoftware elements are defined; \n5) consistency and bidirectional traceability are established between \nsoftware requirements and software architectural design; and \n6) the software architectural design is agreed and communicated to all \naffected parties. \nBase practices SWE.2.BP1: Develop software architectural design.  Develop and \ndocument the software architectural design that specifies the elements of \nthe software with respect to functional and non -functional software \nrequirements. [OUTCOME 1] \nNOTE 1: The software is decomposed into elements across appropriate \nhierarchical levels down to the software components (the lowest level \nelements of the software architectural design) that are described in the \ndetailed design. \nSWE.2.BP2: Allocate software requirements.  Allocate the software \nrequirements to the elements of the so ftware architectural design. \n[OUTCOME 2] \nSWE.2.BP3: Define interfaces of software elements.  Identify, develop \nand document the interfaces of each software element. [OUTCOME 3] \nSWE.2.BP4: Describe dynamic behavior.  Evaluate and document the \ntiming and dynamic interaction of software elements to meet the required \ndynamic behavior of the system. [OUTCOME 4] \nNOTE 2: Dynamic behavior is determined by operating modes (e.g. start-up, \nshutdown, normal mode, calibration, diagnosis, etc.), processes and process \nintercommunication, tasks, threads, time slices, interrupts, etc. \nNOTE 3: During evaluation of the dynamic behavior the target platform and \npotential loads on the target should be considered. \n\n  \n \n \n \n© VDA Quality Management Center 50 \n \n \nSWE.2.BP5: Define resource consumption objectives.  Determine and \ndocument the resource consumption objectives for all relevant elements of \nthe software architectural design on the appropriate hierarchical level. \n[OUTCOME 4] \nNOTE 4: Resource consumption is typically determined for resources like \nMemory (ROM, RAM, external / internal EEPROM or Data Flash), CPU load, \netc. \nSWE.2.BP6: Evaluate alternative software architectures.  Define \nevaluation criteria for the architecture. Evaluate alternative software \narchitectures according to the defined criteria. Record the rationale for the \nchosen software architecture. [OUTCOME 1, 2, 3, 4, 5] \nNOTE 5: Evaluation criteria may include quality characteristics (modularity, \nmaintainability, expandability, scalability, reliability, security realization and \nusability) and results of make-buy-reuse analysis. \nSWE.2.BP7: Establish bidirectional traceability. Establish bidirectional \ntraceability between software requirements and elements of the software \narchitectural design. [OUTCOME 5] \nNOTE 6: Bidirectional traceability covers allocation of software requirements to \nthe elements of the software architectural design.  \nNOTE 7: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSWE.2.BP8: Ensure consistency. Ensure consistency between software \nrequirements and the software architectural design. [OUTCOME 1, 2, 5, 6] \nNOTE 8: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nSWE.2.BP9: Communicate agreed software architectural design.  \nCommunicate the agreed software architectural des ign and updates to \nsoftware architectural design to all relevant parties. [OUTCOME 6] \nOutput work \nproducts \n04-04 Software architectural design  → [OUTCOME 1, 2, 3, 4, 5] \n13-04 Communication record  → [OUTCOME 6] \n13-19 Review record    → [OUTCOME 5] \n13-22 Traceability record   → [OUTCOME 5] \n17-08 Interface requirement specification  →  [OUTCOME 3]\n\n### SWE.3 Software Detailed Design and Unit Construction\n\nProcess ID SWE.3 \nProcess name Software Detailed Design and Unit Construction \nProcess purpose The purpose of the Software Detailed Design and Unit Construction \nProcess is to provide an evaluated detailed design for the software \ncomponents and to specify and to produce the software units. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a detailed design is developed that describes software units; \n2) interfaces of each software unit are defined; \n3) the dynamic behavior of the software units is defined; \n\n  \n \n \n \n© VDA Quality Management Center 51 \n \n \n4) consistency and bidirectional traceability are established between \nsoftware requirements and software units; and consistency and \nbidirectional traceability are established between software \narchitectural design and software detailed design; and consistency \nand bidirectional traceability are established between software \ndetailed design and software units;  \n5) the software detailed design and the relationship to the software \narchitectural design is agreed and communicated to all affected \nparties; and \n6) software units defined by the software detailed design are produced. \nBase practices SWE.3.BP1: Develop software detailed design.  Develop a detailed \ndesign for each software component defined in the software architectural \ndesign that specifies all software units with respect to functional and non -\nfunctional software requirements. [OUTCOME 1] \nSWE.3.BP2: Define interfaces of software units. Identify, specify and \ndocument the interfaces of each software unit. [OUTCOME 2] \nSWE.3.BP3: Describe dynamic behavior.  Evaluate and document the \ndynamic behavior of and the interaction between relevant software units. \n[OUTCOME 3]  \nNOTE 1: Not all software units have dynamic behavior to be described. \nSWE.3.BP4: Evaluate software detailed design.  Evaluate the software \ndetailed design in terms of interoperability, interaction, criticality, technical \ncomplexity, risks and testability. [OUTCOME 1,2,3,4] \nNOTE 2: The results of the evaluation can be used as input for software unit \nverification. \nSWE.3.BP5: Establish bidirectional traceability.  Establish bidirectional \ntraceability between software requirements and software units. Establish \nbidirectional traceability between the software architectural design and the \nsoftware detailed design. Establish bidirectional traceability between the \nsoftware detailed design and software units. [OUTCOME 4] \nNOTE 3: Redundancy should be avoided by establishing a combination of \nthese approaches that covers the project and the organizational needs. \nNOTE 4: Bidirectional traceability supports coverage, consistency and impact \nanalysis.  \nSWE.3.BP6: Ensure consistency. Ensure consistency between software \nrequirements and software units. Ensure consistency between the software \narchitectural design, the software detailed design and software units. \n[OUTCOME 4] \nNOTE 5: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records.  \nSWE.3.BP7: Communicate agreed software detailed design.  \nCommunicate the agreed software detailed design and updates to the \nsoftware detailed design to all relevant parties. [OUTCOME 5] \nSWE.3.BP8: Develop software units.  Develop and document the \nexecutable representations of each software unit according to the software \ndetailed design. [OUTCOME 6] \n\n  \n \n \n \n© VDA Quality Management Center 52 \n \n \nOutput work \nproducts \n04-05 Software detailed design → [OUTCOME 1, 2, 3] \n11-05 Software unit   → [OUTCOME 6] \n13-04 Communication record → [OUTCOME 5] \n13-19 Review record   → [OUTCOME 4] \n13-22 Traceability record  → [OUTCOME 4]\n\n### SWE.4 Software Unit Verification\n\nProcess ID SWE.4 \nProcess name Software Unit Verification \nProcess purpose The purpose of the Software Unit Verification Process is to verify software \nunits to provide evidence for compliance of the software units with the \nsoftware detailed design and with the non-functional software \nrequirements. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a software unit verification strategy including regression strategy is \ndeveloped to verify the software units; \n2) criteria for software unit verification are developed according to the \nsoftware unit verification strategy that are suitable to provide evidence \nfor compliance of the software units with the software detailed design \nand with the non-functional software requirements; \n3) software units are verified according to the software unit verification \nstrategy and the defined criteria for software unit verification and the \nresults are recorded; \n4) consistency and bidirectional traceability are established between \nsoftware units, criteria for verification and verification results; and \n5) results of the unit verification are summarized and communicated to \nall affected parties. \nBase practices SWE.4.BP1: Develop software unit verification strategy including \nregression strategy. Develop a strategy for verification of the software \nunits including regression strategy for re -verification if a software unit is \nchanged. The verification strategy shall define how to provide evidence for \ncompliance of the software units with the software detailed design and with \nthe non-functional requirements. [OUTCOME 1] \nNOTE 1: Possible techniques for unit verification include static/dynamic \nanalysis, code reviews, unit testing etc. \nSWE.4.BP2: Develop criteria for unit verification.  Develop criteria for \nunit verification that are suitable to provide evidence for compliance of the \nsoftware units, and their interactions within the component , with the \nsoftware detailed design and with the n on-functional requirements \naccording to the verification strategy.  For unit testing, criteria shall be \ndefined in a unit test specification. [OUTCOME 2] \nNOTE 2: Possible criteria for unit verification include unit test cases, unit test \ndata, static verification, coverage goals and coding standards such as the \nMISRA rules. \nNOTE 3: The unit test specification may be implemented e.g. as a script in an \nautomated test bench. \n\n  \n \n \n \n© VDA Quality Management Center 53 \n \n \nSWE.4.BP3: Perform static verification of software units.  Verify \nsoftware units for correctness using the defined criteria for verification . \nRecord the results of the static verification. [OUTCOME 3] \nNOTE 4: Static verification may include static analysis, code reviews, checks \nagainst coding standards and guidelines, and other techniques. \nNOTE 5: See SUP.9 for handling of non-conformances. \nSWE.4.BP4: Test software units.  Test software units using the unit test \nspecification according to the software unit verification strategy. Record the \ntest results and logs. [OUTCOME 3] \nNOTE 6: See SUP.9 for handling of non-conformances. \nSWE.4.BP5: Establish bidirectional traceability. Establish bidirectional \ntraceability between software units and static verification results. Establish \nbidirectional traceability between the software detailed design and the unit \ntest specification. Establish bidirectional traceability between the unit test \nspecification and unit test results. [OUTCOME 4] \nNOTE 7: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSWE.4.BP6: Ensure consistency.  Ensure consistency between the \nsoftware detailed design and the unit test specification. [OUTCOME 4] \nNOTE 8: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nSWE.4.BP7: Summarize and communicate results. Summarize the unit \ntest results and static verification results and communicate them to all \naffected parties. [OUTCOME 5] \nNOTE 9: Providing all necessary information from the test case execution in a \nsummary enables other parties to judge the consequences. \nOutput work \nproducts \n08-50 Test specification  → [OUTCOME 2] \n08-52 Test plan   → [OUTCOME 1] \n13-04 Communication record → [OUTCOME 5] \n13-19 Review record   → [OUTCOME 3, 4] \n13-22 Traceability record  → [OUTCOME 4] \n13-25 Verification results  → [OUTCOME 3, 5] \n13-50 Test result   → [OUTCOME 3, 5] \n15-01 Analysis report   → [OUTCOME 3] \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 54\n\n### SWE.5 Software Integration and Integration Test\n\nProcess ID SWE.5 \nProcess name Software Integration and Integration Test \nProcess purpose The purpose of the Software Integration and Integration Test Process is \nto integrate the software units into larger software items up to a complete \nintegrated software consistent with the software architectural design and \nto ensure that the software items are tested to provide evidence for \ncompliance of the integrated software items with the software \narchitectural design, including the interfaces between the software units \nand between the software items. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a software integration strategy consistent with the project plan, \nrelease plan and the software architectural design is developed to \nintegrate the software items; \n2) a software integration test strategy including the regression test \nstrategy is developed to test the software unit and software item \ninteractions; \n3) a specification for software integration test according to the software \nintegration test strategy is developed that is suitable to provide \nevidence for compliance of the integrated software items with the \nsoftware architectural design, including the interfaces between the \nsoftware units and between the software items; \n4) software units and software items are integrated up to a complete \nintegrated software according to the integration strategy; \n5) Test cases included in the software integration test specification are \nselected according to the software integration test strategy, and the \nrelease plan; \n6) integrated software items are tested using the selected test cases and \nthe results of software integration test are recorded; \n7) consistency and bidirectional traceability are established between the \nelements of the software architectural design and the test cases \nincluded in the software integration test specification and between test \ncases and test results; and \n8) results of the software integration test are summarized and \ncommunicated to all affected parties. \nBase practices SWE.5.BP1: Develop software integration strategy. Develop a strategy \nfor integrating software items consistent with the project plan and release \nplan. Identify software items based on the software architectural design and \ndefine a sequence for integrating them. [OUTCOME 1] \nSWE.5.BP2: Develop software int egration test strategy including \nregression test strategy.  Develop a strategy for testing the integrated \nsoftware items following the integration strategy. This includes a regression \ntest strategy for re -testing integrated software items if a software item  is \nchanged. [OUTCOME 2] \nSWE.5.BP3: Develop specification for software integration test.  \nDevelop the test specification for software integration test including the test \ncases according to the software integration test strategy for each integrated \nsoftware item. The test specification shall be suitable to provide evidence \n\n  \n \n \n \n© VDA Quality Management Center 55 \n \n \nfor compliance of the integrated software items with the software \narchitectural design. [OUTCOME 3] \nNOTE 1: Compliance to the architectural design means that the specified \nintegration tests are suitable to prove that the interfaces between the software \nunits and between the software items fulfill the specification given by the \nsoftware architectural design. \nNOTE 2: The software integration test cases may focus on \n• the correct dataflow between software items \n• the timeliness and timing dependencies of dataflow between software \nitems  \n• the correct interpretation of data by all software items using an interface  \n• the dynamic interaction between software items \n• the compliance to resource consumption objectives of interfaces \nSWE.5.BP4: Integrate software units and software items. Integrate the \nsoftware units to software items and software items to integrated software \naccording to the software integration strategy. [OUTCOME 4] \nSWE.5.BP5: Select test cas es. Select test cases from the software \nintegration test specification. The selection of test cases shall have \nsufficient coverage according to the software integration test strategy and \nthe release plan. [OUTCOME 5] \nSWE.5.BP6: Perform software integration  test. Perform the software \nintegration test using the selected test cases. Record the integration test \nresults and logs. [OUTCOME 6] \nNOTE 4: See SUP.9 for handling of non-conformances. \nNOTE 5: The software integration test may be supported by using hardwa re \ndebug interfaces or simulation environments (e.g. Software-in-the-Loop-\nSimulation). \nSWE.5.BP7: Establish bidirectional traceability. Establish bidirectional \ntraceability between elements of the software architectural design and test \ncases included in th e software integration test specification. Establish \nbidirectional traceability between test cases included in the software \nintegration test specification and software integration test results. [OUTCOME \n7] \nNOTE 6: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSWE.5.BP8: Ensure consistency. Ensure consistency between elements \nof the software architectural design and test cases included in the software \nintegration test specification. [OUTCOME 7] \nNOTE 7: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nSWE.5.BP9: Summarize and communicate results.  Summarize the \nsoftware integration test results and communicate them to all affected \nparties. [OUTCOME 8] \nNOTE 8: Providing all necessary information from the test case execution in a \nsummary enables other parties to judge the consequences.  \nOutput work \nproducts \n01-03 Software item   → [OUTCOME 4] \n\n  \n \n \n \n© VDA Quality Management Center 56 \n \n \n01-50 Integrated software  → [OUTCOME 4]  \n08-50 Test specification  → [OUTCOME 3, 5] \n08-52 Test plan   → [OUTCOME 1, 2] \n13-04 Communication record → [OUTCOME 8] \n13-19 Review record   → [OUTCOME 7] \n13-22 Traceability record  → [OUTCOME 7]  \n13-50 Test result   → [OUTCOME 6, 8] \n17-02 Build list   → [OUTCOME 4, 7]\n\n### SWE.6 Software Qualification Test\n\nProcess ID SWE.6 \nProcess name Software Qualification Test \nProcess purpose The purpose of the Software Qualification Test Process is to ensure that \nthe integrated software is tested to provide evidence for compliance with \nthe software requirements. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a software qualification test strategy including regression test strategy \nconsistent with the project plan and release plan is developed to test \nthe integrated software; \n2) a specification for software qualification test of the integrated software \naccording to the software qualification test strategy is developed that \nis suitable to provide evidence for compliance with the software \nrequirements; \n3) test cases included in the software qualification test specification are \nselected according to the software qualification test strategy and the \nrelease plan; \n4) the integrated software is tested using the selected test cases and the \nresults of software qualification test are recorded; \n5) consistency and bidirectional traceability are established between \nsoftware requirements and software qualification test specification \nincluding test cases and between test cases and test results; and \n6) results of the software qualification test are summarized and \ncommunicated to all affected parties. \nBase practices SWE.6.BP1: Develop software qualification test strategy including \nregression test strategy.  Develop a strategy for software qualification \ntesting consistent with the project plan and the release plan. This includes \na regression test strategy for re-testing the integrated software if a software \nitem is changed. [OUTCOME 1] \nSWE.6.BP2: Develop speci fication for software qualification test.  \nDevelop the specification for software qualification test including test cases \nbased on the verification criteria, according to the software test strategy. \nThe test specification shall be suitable to provide evidence for compliance \nof the integrated software with the software requirements. [OUTCOME 2] \n\n  \n \n \n \n© VDA Quality Management Center 57 \n \n \nSWE.6.BP3: Select test cases.  Select test cases from the software test \nspecification. The selection of test cases shall have sufficient coverage \naccording to the software test strategy and the release plan. [OUTCOME 3] \nSWE.6.BP4: Test integrated software. Test the integrated software using \nthe selected test cases. Record the software test results and logs. [OUTCOME \n4] \nNOTE 1: See SUP.9 for handling of non-conformances. \nSWE.6.BP5: Establish bidirectional traceability. Establish bidirectional \ntraceability between software requirements and test cases included in the \nsoftware qualification test specification. Establish bidirectional traceability \nbetween test cases included in the software qualification test specification \nand software qualification test results. [OUTCOME 5] \nNOTE 2: Bidirectional traceability supports coverage, consistency and impact \nanalysis. \nSWE.6.BP6: Ensure consistency. Ensure consistency between software \nrequirements and test cases included in the software qualification test \nspecification. [OUTCOME 5]  \nNOTE 3: Consistency is supported by bidirectional traceability and can be \ndemonstrated by review records. \nSWE.6.BP7: Sum marize and communicate results.  Summarize the \nsoftware qualification test results and communicate them to all affected \nparties. [OUTCOME 6] \nNOTE 4: Providing all necessary information from the test case execution in a \nsummary enables other parties to judge the consequences. \nOutput work \nproducts \n08-50 Test specification  → [OUTCOME 2, 3] \n08-52 Test plan   → [OUTCOME 1] \n13-04 Communication record → [OUTCOME 6] \n13-19 Review record   → [OUTCOME 5] \n13-22 Traceability record  → [OUTCOME 5] \n13-50 Test result   → [OUTCOME 4, 6] \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 58\n\n## Supporting process group (SUP)\n\n\n\n### SUP.1 Quality Assurance\n\nProcess ID SUP.1 \nProcess name Quality Assurance \nProcess purpose The purpose of the Quality Assurance Process is to provide independent \nand objective assurance that work products and processes comply with \npredefined provisions and plans and that non-conformances are resolved \nand further prevented. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a strategy for performing quality assurance is developed, \nimplemented, and maintained; \n2) quality assurance is performed independently and objectively without \nconflicts of interest; \n3) non-conformances of work products, processes, and process activities \nwith relevant requirements are identified, recorded, communicated to \nthe relevant parties, tracked, resolved, and further prevented; \n4) conformance of work products, processes and activities with relevant \nrequirements is verified, documented, and communicated to the \nrelevant parties; \n5) authority to escalate non-conformances to appropriate levels of \nmanagement is established; and \n6) management ensures that escalated non-conformances are resolved. \nBase practices SUP.1.BP1: Develop a project quality assurance strategy.  Develop a \nstrategy in order to ensure that work product and process quality assurance \nis performed at project level independently and objectively without conflicts \nof interest. [OUTCOME 1, 2] \nNOTE 1: Aspects of independence may be financial and/or organizational \nstructure. \nNOTE 2: Quality assurance may be coordinated with, and make use of, the \nresults of other processes such as verification, validation, joint review, audit \nand problem management. \nNOTE 3: Process quality assurance may include process assessments and \naudits, problem analysis, regular check of methods, tools, documents and the \nadherence to defined processes, reports and lessons learned that improve \nprocesses for future projects. \nNOTE 4: Work product quality assurance may include reviews, problem \nanalysis, reports and lessons learned that improve the work products for \nfurther use. \nSUP.1.BP2: Assure quality of work products.  Perform the activities \naccording to the quality assurance strategy and the project schedule to \nensure that the work products meet the defined work product requirements \nand document the results. [OUTCOME 2, 3, 4] \nNOTE 5: Relevant work product requirements may include requirements from \napplicable standards. \n\n  \n \n \n \n© VDA Quality Management Center 59 \n \n \nNOTE 6: Non-conformances detected in work products may be entered into \nthe problem resolution management process (SUP.9) to document, analyze, \nresolve, track to closure and prevent the problems. \nSUP.1.BP3: Assure quality of process activities.  Perform the activities \naccording to the quality assurance strategy and the pr oject schedule to \nensure that the processes meet their defined goals and document the \nresults. [OUTCOME 2, 3, 4] \nNOTE 7: Relevant process goals may include goals from applicable standards.  \nNOTE 8: Problems detected in the process definition or implementation may \nbe entered into a process improvement process (PIM.3) to describe, record, \nanalyze, resolve, track to closure and prevent the problems. \nSUP.1.BP4: Summarize and communicate quality assurance activities \nand results.  Regularly report performance, devi ations, and trends of \nquality assurance activities to relevant parties for information and action \naccording to the quality assurance strategy. [OUTCOME 3, 4] \nSUP.1.BP5: Ensure resolution of non -conformances. Deviations or \nnon-conformance found in process and product quality assurance activities \nshould be analyzed, tracked, corrected, and further prevented . \n[OUTCOME 3,6] \nSUP.1.BP6: Implement an escalation mechanism.  Establish and \nmaintain an escalation mechanism according to the quality assurance \nstrategy th at ensures that quality assurance may escalate problems to \nappropriate levels of management and other relevant stakeholders to \nresolve them. [OUTCOME 5, 6] \nOutput work \nproducts \n08-13 Quality plan   → [OUTCOME 1, 2] \n13-04 Communication record → [OUTCOME 3, 4, 5] \n13-07 Problem record  → [OUTCOME 3, 5] \n13-18 Quality record   → [OUTCOME 2, 3, 4] \n13-19 Review record   → [OUTCOME 2, 3, 4] \n14-02 Corrective action register → [OUTCOME 3, 5, 6] \n18-07 Quality criteria   → [OUTCOME 1]\n\n### SUP.2 Verification\n\nProcess ID SUP.2 \nProcess name Verification \nProcess purpose The purpose of the Verification Process is to confirm that each work \nproduct of a process or project properly reflects the specified \nrequirements. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) a verification strategy is developed, implemented and maintained; \n2) criteria for verification of all required work products are identified; \n3) required verification activities are performed; \n4) defects are identified, recorded and tracked; and \n5) results of the verification activities are made available to the customer \nand other involved parties. \n\n  \n \n \n \n© VDA Quality Management Center 60 \n \n \nBase practices SUP.2.BP1: Develop a verification strategy.  Develop and implement a \nverification strategy, includin g verification activities with associated \nmethods, techniques, and tools ; work product or processes under \nverification; degrees of independence for verification and schedule for \nperforming these activities. [OUTCOME 1] \nNOTE 1: Verification strategy is implemented through a plan.  \nNOTE 2: Software and system verification may provide objective evidence that \nthe outputs of a particular phase of the software development life cycle (e.g. \nrequirements, design, implementation, testing) meet all of the specified \nrequirements for that phase.  \nNOTE 3: Verification methods and techniques may include inspections, peer \nreviews (see also SUP.4), audits, walkthroughs and analysis.  \nSUP.2.BP2: Develop criteria for verification.  Develop the criteria for \nverification of all required technical work products. [OUTCOME 2]  \nSUP.2.BP3: Conduct verification.  Verify identified work products \naccording to the specified strategy and to the developed criteria to confirm \nthat the work products meet their specified requirements. The result s of \nverification activities are recorded. [OUTCOME 3]  \nSUP.2.BP4: Determine and track actions for verification results.  \nProblems identified by the verification should be entered into the problem \nresolution management process (SUP.9) to describe, record, analyze, \nresolve, track to closure and prevent the problems. [OUTCOME 4]  \nSUP.2.BP5: Report verification results.  Verification results should be \nreported to all affected parties. [OUTCOME 5] \nOutput work \nproducts \n13-04 Communication record → [OUTCOME 5] \n13-07 Problem record  → [OUTCOME 3, 4, 5] \n13-25 Verification results  → [OUTCOME 2, 3, 4, 5] \n14-02 Corrective action register → [OUTCOME 4] \n18-07 Quality criteria   → [OUTCOME 2] \n19-10 Verification strategy  → [OUTCOME 1]\n\n### SUP.4 Joint Review\n\nProcess ID SUP.4 \nProcess name Joint Review \nProcess purpose The purpose of the Joint review process is to maintain a common \nunderstanding with the stakeholders of the progress against the \nobjectives of the agreement and what should be done to help ensure \ndevelopment of a product that satisfies the stakeholders. Joint reviews \nare at both project management and technical levels and are held \nthroughout the life of the project. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) management and technical reviews are held based on the needs of \nthe project; \n\n  \n \n \n \n© VDA Quality Management Center 61 \n \n \n2) the status and products of an activity of a process are evaluated \nthrough joint review activities between the stakeholders; \n3) review results are made known to all affected parties;  \n4) action items resulting from reviews are tracked to closure; and \n5) problems are identified and recorded. \nNOTE 1: Joint review should be performed at specific milestones during \nproject/product development. The scope and the goals of joint review may be \ndifferent dependent on project/product development phase (for example, in the \nearly stage of a project joint review may be \"conceptual\" in order to analyze \nthe customer requirements; in later stages joint review may be concerned with \nthe implementation). \nNOTE 2: Joint review should be performed to verify different aspects (for \nexample: hardware resources utilization; the introduction of new requirements \nand new technologies; modification to the working team structure; technology \nchanges). \nBase practices SUP.4.BP1: Define review elements. Based on the needs of the project, \nidentify the schedule, scope and participants of management and technical \nreviews, agree all resources required to conduct the reviews (this includes \npersonnel, location and facilities) and establish review criteria for problem \nidentification, resolution and agreement. [OUTCOME 1] \nSUP.4.BP2: Establish a mechanism to handle review outcomes.  \nEstablish mechanisms to ensure that review results are made available to \nall affected parties that problems detected during the reviews are identified \nand recorded and that action items raised are recorded for action.  \n[OUTCOME 3] \nSUP.4.BP3: Prepare joint review.  Collect, plan, prepare and distribute \nreview material as appropriate in preparation for the review. [OUTCOME 1] \nNOTE 1: The following items may be addressed: Scope and purpose of the \nreview; Products and problems to be reviewed; Entry and exit criteria; Meeting \nagenda; Roles and participants; Distribution list; Responsibilities; Resource \nand facility requirements; Used tools (checklists, scenario for perspective \nbased reviews etc.). \nSUP.4.BP4: Conduct joint reviews.  Conduct joint management and \ntechnical reviews as planned. Record the review results. [OUTCOME 1, 2] \nSUP.4.BP5: Distribute the results.  Document and distribute the revi ew \nresults to all the affected parties. [OUTCOME 3] \nSUP.4.BP6: Determine actions for review results.  Analyze the review \nresults, propose actions for resolution and determine the priority for actions. \n[OUTCOME 4] \nSUP.4.BP7: Track actions for review results. Track actions for resolution \nof identified problems in a review to closure. [OUTCOME 4] \nSUP.4.BP8: Identify and record problems.  Identify and record the \nproblems detected during the reviews according to the established \nmechanism. [OUTCOME 5] \nOutput work \nproducts \n13-04 Communication record →  [OUTCOME 3] \n13-05 Contract review record →  [OUTCOME 1, 2, 3] \n\n  \n \n \n \n© VDA Quality Management Center 62 \n \n \n13-07 Problem record  →  [OUTCOME 3, 5] \n13-09 Meeting support record →  [OUTCOME 1, 2] \n13-19 Review record   →  [OUTCOME ALL] \n14-02 Corrective action register →  [OUTCOME 3, 4, 5] \n14-08 Tracking system  →  [OUTCOME 3, 4, 5] \n15-01 Analysis report   →  [OUTCOME 3, 5] \n15-13 Assessment/audit report →  [OUTCOME 1, 2] \n15-16 Improvement opportunity →  [OUTCOME 3, 4]\n\n### SUP.7 Documentation\n\nProcess ID SUP.7 \nProcess name Documentation \nProcess purpose The purpose of the Documentation Process is to develop and maintain the \nrecorded information produced by a process. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) a strategy identifying the documentation to be produced during the life \ncycle of the product or service is developed; \n2) the standards to be applied for the development of the documentation \nare identified; \n3) documentation to be produced by the process or project is identified; \n4) the content and purpose of all documentation is specified, reviewed \nand approved; \n5) documentation is developed and made available in accordance with \nidentified standards; and \n6) documentation is maintained in accordance with defined criteria. \nBase practices SUP.7.BP1: Develop a documentation management strategy. Develop \na documentation management strategy which addresses where, when and \nwhat should be documented during the life cycle of the product/service. \n[OUTCOME 1]  \nNOTE 1: A documentation management strategy may define the controls \nneeded to approve documentation for adequacy prior to issue; to review and \nupdate as necessary and re-approve documentation; to ensure that changes \nand the current revision status of documentation are identified; to ensure that \nrelevant versions of documentation are available at points of issue; to ensure \nthat documentation remain legible and readily identifiable; to ensure the \ncontrolled distribution of documentation; to prevent unintended use of obsolete \ndocumentation ; and may also specify the levels of confidentiality, copyright or \ndisclaimers of liability for the documentation. \nSUP.7.BP2: Establish standards for documentation.  Establish \nstandards for developing, modifying and maintaining documentation. \n[OUTCOME 2] \nSUP.7.BP3: Specify documentation requirements.  Specify \nrequirements for documentation such as title, date, identifier, version \nhistory, author(s), reviewer, authorizer, outline of contents, purpose, and \ndistribution list. [OUTCOME 2] \n\n  \n \n \n \n© VDA Quality Management Center 63 \n \n \nSUP.7.BP4: Identify the relevant  documentation to be produced . For \nany given development life cycle, identify the documentation to be \nproduced. [OUTCOME 3] \nSUP.7.BP5: Develop documentation.  Develop documentation at \nrequired process points according to established standards and policy, \nensuring the content and purpose is reviewed and approved as \nappropriate. [OUTCOME 4, 5] \nSUP.7.BP6: Check documentation.  Review documentation before \ndistribution, and authorize documentation as appropriate before distribution \nor release. [OUTCOME 5] \nNOTE 2: The documentation intended for use by system and software users \nshould accurately describe the system and software and how it is to be used in \nclear and useful manner for them. \nNOTE 3: Documentation should be checked through verification or validation \nprocess.  \nSUP.7.BP7: Distribute documentation.  Distribute documentation \naccording to determined modes of distribution via appropriate media to all \naffected parties, confirming delivery of documentation, where necessary. \n[OUTCOME 5] \nSUP.7.BP8: Maintain document ation. Maintain documentation in \naccordance with the determined documentation strategy. [OUTCOME 6] \nNOTE 4: If the documentation is part of a product baseline or if its control and \nstability are important, it should be modified and distributed in accordance with \nprocess SUP.8 Configuration management. \nOutput work \nproducts \n08-26 Documentation plan →  [OUTCOME 1, 2] \n13-01 Acceptance record →  [OUTCOME 4, 5] \n13-19 Review record  →  [OUTCOME 4, 5] \n14-01 Change history  →  [OUTCOME 5, 6] \n14-11 Work product list →  [OUTCOME 3]\n\n### SUP.8 Configuration Management\n\nProcess ID SUP.8 \nProcess name Configuration Management \nProcess purpose The purpose of the Configuration Management Process is to establish \nand maintain the integrity of all work products of a process or project and \nmake them available to affected parties. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a configuration management strategy is developed; \n2) all configuration items generated by a process or project are identified, \ndefined and baselined according to the configuration management \nstrategy; \n3) modifications and releases of the configuration items are controlled; \n4) modifications and releases are made available to affected parties; \n\n  \n \n \n \n© VDA Quality Management Center 64 \n \n \n5) the status of the configuration items and modifications is recorded and \nreported; \n6) the completeness and consistency of the baselines is ensured; and \n7) storage of the configuration items is controlled. \nBase practices SUP.8.BP1: Develop a configuration management strategy. Develop a \nconfiguration management strategy, including  \n• responsibilities; \n• tools and repositories; \n• criteria for configuration items; \n• naming conventions; \n• access rights; \n• criteria for baselines; \n• merge and branch strategy; \n• the revision history approach for configuration items \n[OUTCOME 1] \nNOTE 1: The configuration management strategy typically supports the \nhandling of product/software variants which may be caused by different sets of \napplication parameters or by other causes. \nNOTE 2: The branch management strategy specifies in which cases branching \nis permissible, whether authorization is required, how branches are merged, \nand which activities are required to verify that all changes have been \nconsistently integrated without damage to other changes or to the original \nsoftware. \nSUP.8.BP2: Iden tify configuration items.  Identify and document \nconfiguration items according to the configuration management strategy. \n[OUTCOME 2] \nNOTE 3: Configuration control is typically applied for the products that are \ndelivered to the customer, designated internal work products, acquired \nproducts, tools and other configuration items that are used in creating and \ndescribing these work products. \nSUP.8.BP3: Establish a configuration management system.  Establish \na configuration management system according to the configu ration \nmanagement strategy. [OUTCOME 1, 2, 3, 4, 6, 7] \nSUP.8.BP4: Establish branch management.  Establish branch \nmanagement according to the configuration management strategy where \napplicable for parallel developments that use the same base. [OUTCOME 1, \n3, 4, 6, 7] \nSUP.8.BP5: Control modifications and releases. Establish mechanisms \nfor control of the configuration items according to the configuration \nmanagement strategy, and control modifications and releases using these \nmechanisms. [OUTCOME 3, 4, 5] \nSUP.8.BP6: Establish baselines.  Establish baselines for internal \npurposes and for external delivery according to the configuration \nmanagement strategy. [OUTCOME 2] \nNOTE 4: For baseline issues refer also to the product release process SPL.2.  \nSUP.8.BP7: Report conf iguration status. Record and report status of \nconfiguration items to support project management and other relevant \nprocesses. [OUTCOME 5] \n\n  \n \n \n \n© VDA Quality Management Center 65 \n \n \nNOTE 5: Regular reporting of the configuration status (e.g. how many \nconfiguration items are currently under work, checked in, tested, released, \netc.) supports project management activities and dedicated project phases like \nsoftware integration. \nSUP.8.BP8: Verify the information about configured items.  Verify that \nthe information about configured items, and their baselines is complete and \nensure the consistency of baselines. [OUTCOME 6] \nNOTE 6: A typical implementation is performing baseline and configuration \nmanagement audits. \nSUP.8.BP9: Manage the storage of configuration items and baselines. \nEnsure the integrity and availability of configuration items and baselines \nthrough appropriate scheduling and resourcing of storage, archiving (long \nterm storage) and backup of the used CM systems. [OUTCOME 4, 5, 6, 7] \nNOTE 7: Backup, storage and archiving may need to extend beyond the \nguaranteed lifetime of available storage media. Relevant configuration items \naffected may include those referenced in note 2 and note 3. Availability may be \nspecified by contract requirements. \nOutput work \nproducts \n06-02 Handling and storage guide  → [OUTCOME 3, 4, 5, 7] \n08-04 Configuration management plan → [OUTCOME 1, 2, 7] \n08-14 Recovery plan    → [OUTCOME 1, 7] \n13-08 Baseline    → [OUTCOME 2, 3, 4, 5, 6] \n13-10 Configuration management record → [OUTCOME 2, 5, 7] \n14-01 Change history    → [OUTCOME 3] \n16-03 Configuration management system → [OUTCOME 1, 3, 4]\n\n### SUP.9 Problem Resolution Management\n\nProcess ID SUP.9 \nProcess name Problem Resolution Management \nProcess purpose The purpose of the Problem Resolution Management Process is to \nensure that problems are identified, analyzed, managed and controlled to \nresolution. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a problem resolution management strategy is developed; \n2) problems are recorded, uniquely identified and classified; \n3) problems are analyzed and assessed to identify an appropriate \nsolution; \n4) problem resolution is initiated; \n5) problems are tracked to closure; and \n6) the status of problems and their trend are known. \nBase practices SUP.9.BP1: D evelop a problem resolution management strategy.  \nDevelop a problem resolution management strategy, including problem \nresolution activities, a status model for the problems, alert notifications, \nresponsibilities for performing these activities and an urgent  resolution \n\n  \n \n \n \n© VDA Quality Management Center 66 \n \n \nstrategy. Interfaces to affected parties are defined and definitions are \nmaintained. [OUTCOME 1] \nNOTE 1: Problem resolution activities can be different during the product life \ncycle, e.g. during prototype construction and series development.  \nSUP.9.BP2: Identify and record the problem. Each problem is uniquely \nidentified, described and recorded. Supporting information should be \nprovided to reproduce and diagnose the problem. [OUTCOME 2] \nNOTE 2: Supporting information typically includes the origin of the problem, \nhow it can be reproduced, environmental information, by whom it has been \ndetected, etc. \nNOTE 3: Unique identification supports traceability to changes made. \nSUP.9.BP3: Record the status of problems.  A status according to the \nstatus model is assigned to each problem to facilitate tracking. [OUTCOME 6] \nSUP.9.BP4: Diagnose the cause and determine the impact of the \nproblem. Investigate the problem and determine its cause and impact in \norder to categorize the problem and to determine appropria te actions . \n[OUTCOME 2, 3] \nNOTE 4: Problem categorization (e.g. A, B, C, light, medium, severe) may be \nbased on severity, impact, criticality, urgency, relevance for the change \nprocess, etc. \nSUP.9.BP5: Authorize urgent resolution action.  If according to the \nstrategy a problem requires an urgent resolution, authorization shall be \nobtained for immediate action also according to the strategy. [OUTCOME 4] \nSUP.9.BP6: Raise alert notifications.  If according to the strategy the \nproblem has a hig h impact on other systems or other affected parties, an \nalert notification needs to be raised also according to the strategy. \n[OUTCOME 4] \nSUP.9.BP7: Initiate problem resolution.  Initiate appropriate actions \naccording to the strategy to resolve the problem including review of those \nactions, or initiate a change request. [OUTCOME 4] \nNOTE 5: Appropriate actions may include the initiating of a change request. \nSee SUP.10 for managing of change requests. \nNOTE 6: The implementation of process improvements (to prevent problems) \nis done in the process improvement process (PIM.3).The implementation of \ngeneric project management improvements (e.g. lessons learned) are part of \nthe project management process (MAN.3). The implementation of generic \nwork product related improvements are part of the quality assurance process \n(SUP.1). \nSUP.9.BP8: Track problems to closure. Track the status of problems to \nclosure including all related change requests. A formal acceptance has to \nbe authorized before closing the problem. [OUTCOME 5, 6] \nSUP.9.BP9: Analyze problem trends.  Collect and analyze problem \nresolution management data, identify trends, and initiate project related \nactions, according to the strategy. [OUTCOME 6] \n\n  \n \n \n \n© VDA Quality Management Center 67 \n \n \nNOTE 7: Collected data typically contains information about where the \nproblems occurred, how and when they were found, what were their impacts, \netc. \n \nOutput work \nproducts \n08-27 Problem management plan → [OUTCOME 1] \n13-07 Problem record  → [OUTCOME 2, 3, 4, 5] \n15-01 Analysis report   → [OUTCOME 3] \n15-05 Evaluation report  → [OUTCOME 3] \n15-12 Problem status report  → [OUTCOME 6]\n\n### SUP.10 Change Request Management\n\nProcess ID SUP.10 \nProcess name Change Request Management \nProcess purpose The purpose of the Change Request Management Process is to ensure \nthat change requests are managed, tracked and implemented. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) a change request management strategy is developed; \n2) requests for changes are recorded and identified; \n3) dependencies and relationships to other change requests are \nidentified; \n4) criteria for confirming implementation of change requests are defined; \n5) requests for change are analyzed, and resource requirements are \nestimated; \n6) changes are approved and prioritized on the basis of analysis results \nand availability of resources; \n7) approved changes are implemented and tracked to closure; \n8) the status of all change requests is known; and \n9) bi-directional traceability is established between change requests and \naffected work products. \nBase practices SUP.10.BP1: Develop a change request management strategy.  \nDevelop a change request management strategy, including change request \nactivities, a status model for the change requests, analysis criteria, and \nresponsibilities for performing these activities. Interfaces to affected parties \nare defined and maintained. [OUTCOME 1] \nNOTE 1: A status model for change requests may contain: open, under \ninvestigation, approved for implementation, allocated, implemented, fixed, \nclosed, etc. \nNOTE 2: Typical analysis criteria are: resource requirements, scheduling \nissues, risks, benefits, etc. \nNOTE 3: Change request activities ensure that change requests are \nsystematically identified, described, recorded, analyzed, implemented, and \nmanaged. \n\n  \n \n \n \n© VDA Quality Management Center 68 \n \n \nNOTE 4: The change request management strategy may cover different \nproceedings across the product life cycle, e.g. during prototype construction \nand series development.  \nSUP.10.BP2: Identify and record the change requests.  Each change \nrequest is uniquely identified, described, and recorded  according to the \nstrategy, including the initiator and reason of the change request. [OUTCOME \n2, 3] \nSUP.10.BP3: Record the status of change requests. A status according \nto the status model is assigned to each change request to facilitate tracking. \n[OUTCOME 8] \nSUP.10.BP4: Analyze and assess change requests.  Change requests \nare analyzed according to the strategy including their dependencies to \naffected work products and other change requests. Assess the impact of \nthe change requests and establish criteria fo r confirming implementation. \n[OUTCOME 3, 4, 5, 9] \nSUP.10.BP5: Approve change requests before implementation.  \nChange requests are prioritized based on analysis results and availability \nof resources before implementation and approved according to the \nstrategy. [OUTCOME 6] \nNOTE 5: A Change Control Board (CCB) is a common mechanism used to \napprove change requests. \nNOTE 6: Prioritization of change requests may be done by allocation to \nreleases. \nSUP.10.BP6: Review the implementation of change requests.   \nThe implementation of change requests is reviewed before closure to \nensure that their criteria for confirming implementation are satisfied, and \nthat all relevant processes have been applied. [OUTCOME 7, 8] \nSUP.10.BP7: Track change requests to closure.  Change requests are \ntracked until closure. Feedback to the initiator is provided. [OUTCOME 7, 8] \nSUP.10.BP8: Establish bidirectional traceability. Establish bidirectional \ntraceability between change requests and work products affected by the \nchange requests. In case that the change request is initiated by a problem, \nestablish bidirectional traceability between change requests and the \ncorresponding problem reports. [OUTCOME 9] \nNOTE 7: Bidirectional traceability supports consistency, completeness and \nimpact analysis. \nOutput work \nproducts \n08-28 Change management plan → [OUTCOME 1] \n13-16 Change request  → [OUTCOME 2, 3, 4, 5, 6, 7] \n13-19 Review record   → [OUTCOME 7] \n13-21 Change control record  → [OUTCOME 8, 9] \n \n  \n\n  \n \n \n \n© VDA Quality Management Center 69\n\n## Management process group (MAN)\n\n\n\n### MAN.3 Project Management\n\nProcess ID MAN.3 \nProcess name Project Management \nProcess purpose The purpose of the Project Management Process is to identify, establish, \nand control the activities and resources necessary for a project to produce \na product, in the context of the project’s requirements and constraints. \nProcess \noutcomes \nAs a result of successful implementation of this process: \n1) the scope of the work for the project is defined; \n2) the feasibility of achieving the goals of the project with available \nresources and constraints is evaluated; \n3) the activities and resources necessary to complete the work are sized \nand estimated; \n4) interfaces within the project, and with other projects and \norganizational units, are identified and monitored; \n5) plans for the execution of the project are developed, implemented and \nmaintained; \n6) progress of the project is monitored and reported; and \n7) corrective action is taken when project goals are not achieved, and \nrecurrence of problems identified in the project is prevented. \nBase practices MAN.3.BP1: Define the scope of work.  Identify the project's goals, \nmotivation and boundaries. [OUTCOME 1] \nMAN.3.BP2: Define project life cycle. Define the life cycle for the project, \nwhich is appropriate to the scope, context, magnitude and complexity of the \nproject. [OUTCOME 2] \nNOTE 1: This typically means that the project life cycle and the customer's \ndevelopment process are consistent with each other. \nMAN.3.BP3: Evaluate feasibility of the project.  Evaluate the feasibility \nof achieving the goals of the p roject in terms of technical feasibility within \nconstraints with respect to time, project estimates, and available resources. \n[OUTCOME 2] \nMAN.3.BP4: Define, monitor and adjust project activities.  Define, \nmonitor and adjust project activities and their depe ndencies according to \ndefined project life cycle and estimations. Adjust activities and their \ndependencies as required. [OUTCOME 3, 5, 7] \nNOTE 2: A structure and a manageable size of the activities and related work \npackages support an adequate progress monitoring.  \nNOTE 3: Project activities typically cover engineering, management and \nsupporting processes. \nMAN.3.BP5: Define, monitor and adjust project estimates and \nresources. Define, monitor and adjust project estimates of effort and \nresources based on project's goals, project risks, motivation and \nboundaries. [OUTCOME 2, 3, 7] \nNOTE 4: Appropriate estimation methods should be used. \n\n  \n \n \n \n© VDA Quality Management Center 70 \n \n \nNOTE 5: Examples of necessary resources are people, infrastructure (such as \ntools, test equipment, communication mechanisms...) and hardware/materials. \nNOTE 6: Project risks (using MAN.5) and quality criteria (using SUP.1) may be \nconsidered. \nNOTE 7: Estimations and resources typically include engineering, \nmanagement and supporting processes. \nMAN.3.BP6: Ensure required skills, knowledge, and experience.  \nIdentify the required skills, knowledge, and experience for the project in line \nwith the estimates and make sure the selected individuals and teams either \nhave or acquire these in time. [OUTCOME 3, 7] \nNOTE 8: In the case of deviations from required skills and knowledge trainings \nare typically provided. \nMAN.3.BP7: Identify, monitor and adjust project interfaces and agreed \ncommitments. Identify and agree interfaces of the project with other (sub-\n) projects, organizational units and other affected stakeholders and monitor \nagreed commitments. [OUTCOME 4, 7] \nNOTE 9: Project interfaces relate to engineering, management and supporting \nprocesses. \nMAN.3.BP8: Define, monitor and a djust project schedule.  Allocate \nresources to activities, and schedule each activity of the whole project. The \nschedule has to be kept continuously updated during lifetime of the project. \n[OUTCOME 3, 5, 7] \nNOTE 10: This relates to all engineering, management and supporting \nprocesses. \nMAN.3.BP9: Ensure consistency. Ensure that estimates, skills, activities, \nschedules, plans, interfaces, and commitments for the project are \nconsistent across affected parties. [OUTCOME 3, 4, 5, 7] \nMAN.3.BP10: Review and report progress of the project.  Regularly \nreview and r eport the status of the project  and the fulfillment of activities \nagainst estimated effort and duration to all affected parties. Prevent \nrecurrence of problems identified. [OUTCOME 6, 7] \nNOTE 11: Project reviews may be executed at regular intervals by the \nmanagement. At the end of a project, a project review contributes to identifying  \ne.g. best practices and lessons learned.  \nOutput work \nproducts \n08-12 Project plan   → [OUTCOME 1, 3, 4, 5] \n13-04 Communication record → [OUTCOME 4, 6] \n13-16 Change request  → [OUTCOME 7] \n13-19 Review record   → [OUTCOME 2, 7] \n14-02 Corrective action register → [OUTCOME 7] \n14-06 Schedule   → [OUTCOME 3, 5] \n14-09 Work breakdown structure → [OUTCOME 3, 4, 5] \n14-50 Stakeholder groups list → [OUTCOME 4] \n15-06 Project status report  → [OUTCOME 4, 6] \n\n  \n \n \n \n© VDA Quality Management Center 71\n\n### MAN.5 Risk Management\n\nProcess ID MAN.5 \nProcess name Risk Management \nProcess purpose The purpose of the Risk Management Process is to identify, analyze, treat \nand monitor the risks continuously. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) the scope of the risk management to be performed is determined; \n2) appropriate risk management strategies are defined and \nimplemented; \n3) risks are identified as they develop during the conduct of the project; \n4) risks are analyzed and the priority in which to apply resources to \ntreatment of these risks is determined; \n5) risk measures are defined, applied, and assessed to determine \nchanges in the status of risk and the progress of the treatment \nactivities; and \n6) appropriate treatment is taken to correct or avoid the impact of risk \nbased on its priority, probability, and consequence or other defined \nrisk threshold. \nBase practices MAN.5.BP1: Establish risk management scope. Determine the scope of \nrisk management to be performed for the project, in accordance with \norganizational risk management policies. [OUTCOME 1] \nNOTE 1: Risks may include technical, economic and timing risks. \nMAN.5.BP2: Define risk management strateg ies. Define appropriate \nstrategies to identify risks, mitigate risks and set acceptability levels for \neach risk or set of risks, both at the project and organizational level. \n[OUTCOME 2] \nMAN.5.BP3: Identify risks. Identify risks to the project both initially within \nthe project strategy and as they develop during the conduct of the project, \ncontinuously looking for risk factors at any occurrence of technical or \nmanagerial decisions. [OUTCOME 2, 3] \nNOTE 2: Examples of risk areas that are typically analyzed for potential risk \nreasons or risks factors include: cost, schedule, effort, resource, and technical. \nNOTE 3: Examples of risk factors may include: unsolved and solved trade-offs, \ndecisions of not implementing a project feature, design changes, lack of \nexpected resources. \nMAN.5.BP4: Analyze risks.  Analyze risks to determine the priority in \nwhich to apply resources to mitigate these risks. [OUTCOME 4] \nNOTE 4: Risks are normally analyzed to determine their probability, \nconsequence and severity. \nNOTE 5: Different techniques may be used to analyze a system in order to \nunderstand if risks exist, for example, functional analysis, simulation, FMEA, \nFTA etc. \nMAN.5.BP5: Define risk treatment actions. For each risk (or set of risks) \ndefine, perform and track the  selected actions to keep/reduce the risks to \nacceptable level. [OUTCOME 5, 6] \n\n  \n \n \n \n© VDA Quality Management Center 72 \n \n \nMAN5.BP6: Monitor risks. For each risk (or set of risks) define measures \n(e.g. metrics) to determine changes in the status of a risk and to evaluate \nthe progress of the of mitig ation activities. Apply and assess these risk \nmeasures. [OUTCOME 5, 6] \nNOTE 6: Major risks may need to be communicated to and monitored by \nhigher levels of management. \nMAN.5.BP7: Take corrective action.  When expected progress in risk \nmitigation is not achi eved, take appropriate corrective action to reduce or \navoid the impact of risk. [OUTCOME 6] \nNOTE 7: Corrective actions may involve developing and implementing new \nmitigation strategies or adjusting the existing strategies. \nOutput work \nproducts \n07-07 Risk measure   → [OUTCOME 5] \n08-14 Recovery plan   → [OUTCOME 4, 6] \n08-19 Risk management plan → [OUTCOME ALL] \n08-20 Risk mitigation plan  → [OUTCOME 3, 4, 5, 6] \n13-20 Risk action request  → [OUTCOME 1, 2, 6] \n14-02 Corrective action register → [OUTCOME 6] \n14-08 Tracking system  → [OUTCOME 5, 6] \n15-08 Risk analysis report   → [OUTCOME 4] \n15-09 Risk status report  → [OUTCOME 4, 5]\n\n### MAN.6 Measurement\n\nProcess ID MAN.6 \nProcess name Measurement \nProcess purpose The purpose of the Measurement Process is to collect and analyze data \nrelating to the products developed and processes implemented within the \norganization and its projects, to support effective management of the \nprocesses and to objectively demonstrate the quality of the products. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) organizational commitment is established and sustained to implement \nthe measurement process; \n2) the measurement information needs of organizational and \nmanagement processes are identified; \n3) an appropriate set of measures, driven by the information needs are \nidentified and/or developed; \n4) measurement activities are identified and performed; \n5) the required data is collected, stored, analyzed, and the results \ninterpreted; \n6) information products are used to support decisions and provide an \nobjective basis for communication; and  \n7) the measurement process and measures are evaluated and \ncommunicated to the process owner. \n\n  \n \n \n \n© VDA Quality Management Center 73 \n \n \nBase practices MAN.6.BP1: Establish organizational commitment for measurement. \nA commitment of management and staff to measurement is established \nand communicated to the organizational unit. [OUTCOME 1] \nMAN.6.BP2: Develop measurement strategy.  Define an appropriate \nmeasurement strategy to identify, perform  and evaluate measurement \nactivities and results, based on organizational and project needs.  \n[OUTCOME 1] \nMAN.6.BP3: Identify measurement information needs.  Identify the \nmeasurement information needs of organizational and management \nprocesses. [OUTCOME 2] \nMAN.6.BP4: Specify measures. Identify and develop an appropriate set \nof measures based on measurement information needs. [OUTCOME 3] \nMAN.6.BP5: Perform measurement activities.  Identify and perform \nmeasurements activities. [OUTCOME 4] \nMAN.6.BP6: Retrieve measurement data. Collect and store data of both \nbase and derived measures, including any context information necessary \nto verify, understand, or evaluate the data. [OUTCOME 5] \nMAN.6.BP7: Analyze measures.  Analyze and interpret measurement \ndata and develop information products. [OUTCOME 5] \nMAN.6.BP8: Use measurement information for decision-making. Make \naccurate and current measurement information accessible for any \ndecision-making processes for which it is relevant. [OUTCOME 6] \nMAN.6.BP9: Communicate measure s. Disseminate measurement \ninformation to all affected parties who will be using them and collect \nfeedback to evaluate appropriateness for intended use. [OUTCOME 5, 6] \nMAN.6.BP10: Evaluate information products and measurement \nactivities. Evaluate informati on products and measurement activities \nagainst the identified information needs and measurement strategy. \nIdentify potential improvements. [OUTCOME 7] \nNOTE 1: Information products are produced as a result analysis of data in \norder to summarize and communicate information. \nMAN.6.BP11: Communicate potential improvements. Communicate to \nthe affected people the identified potential improvements concerning the \nprocesses they are involved in. [OUTCOME 7] \nOutput work \nproducts \n02-01 Commitment/agreement  → [OUTCOME 1] \n03-03 Benchmarking data   → [OUTCOME 5] \n03-04 Customer satisfaction data  → [OUTCOME 5] \n03-06 Process performance data  → [OUTCOME 6] \n07-01 Customer satisfaction survey  → [OUTCOME 3, 7] \n07-02 Field measure    → [OUTCOME 3, 7] \n07-03 Personnel performance measure → [OUTCOME 3, 4, 7] \n07-04 Process measure   → [OUTCOME 3, 4, 7] \n07-05 Project measure   → [OUTCOME 3, 4, 7] \n07-06 Quality measure   → [OUTCOME 3, 4, 7] \n\n  \n \n \n \n© VDA Quality Management Center 74 \n \n \n07-07 Risk measure    → [OUTCOME 3, 4, 7] \n07-08 Service level measure   → [OUTCOME 3, 4, 7] \n15-01 Analysis report    → [OUTCOME 2, 5] \n15-05 Evaluation report   → [OUTCOME 5, 7] \n15-18 Process performance report  → [OUTCOME 5, 7]\n\n## Process improvement process group (PIM)\n\n\n\n### PIM.3 Process Improvement\n\nProcess ID PIM.3 \nProcess name Process Improvement \nProcess purpose The purpose of the Process Improvement Process is to continually \nimprove the organization’s effectiveness and efficiency through the \nprocesses used and aligned with the business need. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) commitment is established to provide resources to sustain \nimprovement actions; \n2) issues arising from the organization's internal/external environment \nare identified as improvement opportunities and justified as reasons \nfor change; \n3) analysis of the current status of the existing process is performed, \nfocusing on those processes from which improvement stimuli arise; \n4) improvement goals are identified and prioritized, and consequent \nchanges to the process are defined, planned and implemented; \n5) the effects of process implementation are monitored, measured and \nconfirmed against the defined improvement goals; \n6) knowledge gained from the improvement is communicated within the \norganization; and \n7) the improvements made are evaluated and consideration given for \nusing the solution elsewhere within the organization.  \nBase practices PIM.3.BP1: Establish commitment.  Commitment is established to \nsupport the process group, to provide resources and further enablers \n(trainings, methods, infrastructure, etc.) to sustain improvement actions. \n[OUTCOME 1] \nNOTE 1: The process improvement process is a generic process, which can \nbe used at all levels (e.g. organizational level, process level, project level, etc.) \nand which can be used to improve all other processes.  \nNOTE 2: Commitment at all levels of management may support process \nimprovement. Personal goals may be set for the relevant managers to enforce \nmanagement commitment. \nPIM.3.BP2: Identify issues.  Processes and int erfaces are continuously \nanalyzed to identify issues arising from the organization’s internal/external \nenvironment as improvement opportunities, and with justified reasons for \nchange. This includes issues and improvement suggestions addressed by \nthe customer. [OUTCOME 2, 3] \n\n  \n \n \n \n© VDA Quality Management Center 75 \n \n \nNOTE 3: Continuous analysis may include problem report trend analysis (see \nSUP.9), analysis from Quality Assurance and Verification results and records \n(see SUP.1 – SUP.2), validation results and records, and product quality \nmeasures like ppm and recalls. \nNOTE 4: Information sources providing input for change may include: process \nassessment results, audits, customer's satisfaction reports, organizational \neffectiveness/efficiency, cost of quality. \nPIM.3.BP3: Establish process improvement g oals. Analysis of the \ncurrent status of the existing process is performed, focusing on those \nprocesses from which improvement stimuli arise, resulting in improvement \nobjectives for the processes being established. [OUTCOME 3] \nNOTE 5: The current status of processes may be determined by process \nassessment. \nPIM.3.BP4: Prioritize improvements.  The improvement objectives and \nimprovement activities are prioritized. [OUTCOME 4] \nPIM.3.BP5: Plan process changes. Consequent changes to the process \nare defined and planned. [OUTCOME 4] \nNOTE 6: Process changes may only be possible if the complete supply chain \nimproves (all relevant parties). \nNOTE 7: Traditionally process changes are mostly applied to new projects. \nWithin the automotive industry, changes could be implemented per project \nphase (e.g. product sample phases A, B, C), yielding a higher improvement \nrate. Also, the principle of low hanging fruit (that is implementing easy \nimprovements first) may be considered when planning process changes.  \nNOTE 8: Improvements may be planned in continuous incremental small \nsteps. Also, improvements are usually piloted before roll out at the \norganization. \nPIM.3.BP6: Implement process changes.  The improvements to the \nprocesses are implemented. Process documentation is updated and \npeople are trained. [OUTCOME 4] \nNOTE 9: This practice includes defining the processes and making sure these \nprocesses are applied. Process application can be supported by establishing \npolicies, adequate process infrastructure (tools, templates, example artifacts, \netc.), process training, process coaching and tailoring processes to local \nneeds. \nPIM.3.BP7: Confirm process improvement.  The effects of process \nimplementation are monitored, measured and confirmed against the \ndefined improvement goals. [OUTCOME 5] \nNOTE 10: Examples of measures may be metrics for goal achievement, \nprocess definition and process adherence. \nPIM.3.BP8: Communicate results of improvement.  Knowledge gained \nfrom the improvements and progress of the improvement implementation \nis communicated outside of the improvement project across relevant parts \nof the organization and to the customer (as appropriate). [OUTCOME 6] \nPIM.3.BP9: Evaluate the results of the improvement project. Evaluate \nthe results of the improvement project to check whether the solution was \nsuccessful and can be used elsewhere in the organization. [OUTCOME 7] \n\n  \n \n \n \n© VDA Quality Management Center 76 \n \n \nOutput work \nproducts \n02-01 Commitment/agreement → [OUTCOME 1] \n05-00 Goals    → [OUTCOME 4] \n06-04 Training material   → [OUTCOME 4, 6] \n07-04 Process measure   → [OUTCOME 6] \n08-00 Plan    → [OUTCOME 2, 4, 7] \n08-29 Improvement plan  → [OUTCOME 4] \n10-00 Process description  → [OUTCOME 4] \n13-04 Communication record → [OUTCOME 6] \n13-16 Change request  → [OUTCOME 2] \n15-05 Evaluation report   → [OUTCOME 2, 3, 4, 5, 7] \n15-13 Assessment/audit report → [OUTCOME 3, 5] \n15-16 Improvement opportunity → [OUTCOME 2, 3, 4, 7] \n16-06 Process repository  → [OUTCOME 4]\n\n## Reuse process group (REU)\n\n\n\n### REU.2 Reuse Program Management\n\nProcess ID REU.2 \nProcess name Reuse Program Management \nProcess purpose The purpose of the Reuse Program Management Process is to plan, \nestablish, manage, control, and monitor an organization’s reuse program \nand to systematically exploit reuse opportunities. \nProcess \noutcomes \nAs a result of successful implementation of this process:  \n1) the reuse strategy, including its purpose, scope, goals and objectives, \nis defined; \n2) each domain is assessed to determine its reuse potential; \n3) the domains in which to investigate reuse opportunities, or in which it \nis intended to practice reuse, are identified; \n4) the organization's systematic reuse capability is assessed; \n5) reuse proposals are evaluated to ensure the reuse product is suitable \nfor the proposed application; \n6) reuse is implemented according to the reuse strategy; \n7) feedback, communication, and notification mechanisms are \nestablished, that operate between affected parties; and \n8) the reuse program is monitored and evaluated. \nBase practices REU.2.BP1: Define organizational reuse strategy.  Define the reuse \nprogram and necessary supporting infrastructure for the organization. \n[Outcome 1] \nREU.2.BP2: Identify domains for potential reuse.  Identify set(s) of \nsystems and their components in terms of common properties that can be \norganized into a collection of reusable assets that may be used to construct \nsystems in the domain. [OUTCOME 2] \n\n  \n \n \n \n© VDA Quality Management Center 77 \n \n \nREU.2.BP3: Assess domains for potential reuse. Assess each domain \nto identify potential use and applications of reusable components and \nproducts. [OUTCOME 3] \nREU.2.BP4: Assess reuse maturity. Gain an understanding of the reuse \nreadiness and maturity of the organization, to provide a baseline and \nsuccess criteria for reuse program management. [OUTCOME 4] \nREU.2.BP5: Evaluate reuse proposals.  Evaluate suitability of the \nprovided reusable components and product(s) to proposed use. \n[OUTCOME 5] \nREU.2.BP6: Implement the reuse program. Perform the defined activities \nidentified in the reuse program. [OUTCOME 6] \nREU.2.BP7: Get feedback from reuse. Establish feedback, assessment, \ncommunication and notification mechanism that operate between affected \nparties to control the progress of reuse program. [OUTCOME 7, 8] \nNOTE 1: Affected parties may include reuse program administrators, asset \nmanagers, domain engineers, developers, operators, and maintenance \ngroups. \nREU.2.BP8: Monitor reuse.  Monitor the implementation of the reuse \nprogram periodically and evaluate its suitability to actual needs. \n[OUTCOME 6, 8] \nNOTE 2: The quality requirements for re-use work products should be defined. \nOutput work \nproducts \n04-02 Domain architecture  → [OUTCOME 2] \n04-03 Domain model   → [OUTCOME 2] \n08-17 Reuse plan   → [OUTCOME 5, 6] \n09-03 Reuse policy   → [OUTCOME 1] \n12-03 Reuse proposal  → [OUTCOME 4] \n13-04 Communication record → [OUTCOME 7] \n15-07 Reuse evaluation report → [OUTCOME 5, 6, 8] \n15-13 Assessment/audit report → [OUTCOME 3, 4] \n19-05 Reuse strategy   → [OUTCOME 1] \n  \n\n  \n \n \n \n© VDA Quality Management Center 78\n\n# Process capability levels and process attributes\n\nProcess capability indicators are the means of achieving the capabilities addressed by the \nconsidered process attributes. Evidence of process capability indicators supports the judgment of \nthe degree of achievement of the process attribute. \nThe capability dimension of the process assessment model consists of six capability levels matching \nthe capability levels defined in ISO/IEC 33020. The process capability indicators for the 9 process \nattributes included in the capability dimension for process capability level 1 to 5 are described.  \nEach of the process attributes in this process assessment model is identical to the process attribute \ndefined in the process measurement framework. The generic practices address the chara cteristics \nfrom each process attribute. The generic resources relate to the process attribute as a whole. \nProcess capability level 0 does not include any type of indicators, as it reflects a non -implemented \nprocess or a process which fails to partially achieve any of its outcomes. \nNOTE: ISO/IEC 33020 process attribute definitions and attribute outcomes are duplicated from ISO/IEC \n33020 in italic font and marked with a left side bar.\n\n## Process capability Level 0: Incomplete process\n\nThe process is not implemented, or fails to achieve its process purpose. At this level there is little \nor no evidence of any systematic achievement of the process purpose.\n\n## Process capability Level 1: Performed process\n\nThe implemented process achieves its process purpose. The follo wing process attribute \ndemonstrates the achievement of this level\n\n### PA 1.1 Process performance process attribute\n\nThe process performance process attribute is a measure of the extent to which the process purpose \nis achieved. As a result of full achievement of this attribute: \na) the process achieves its defined outcomes \n \nGeneric practices GP 1.1.1 Achieve the process outcomes [ACHIEVEMENT a] \nAchieve the intent of the base practices. \nProduce work products that evidence the process outcomes. \nGeneric \nresources \nResources are used to achieve the intent of process specific \nbase practices [ACHIEVEMENT a]\n\n## Process capability Level 2: Managed process\n\nThe previously described Performed process is now implemented in a managed fashion (planned, \nmonitored and adjusted) and its work products are appropriately established, controlled and \nmaintained. \nThe following process attributes, together with the previously defined process attribute, \ndemonstrate the achievement of this level: \n\n  \n \n \n \n© VDA Quality Management Center 79\n\n### PA 2.1 Performance management process attribute\n\nThe performance management process attribute is a measure of the extent to which the \nperformance of the process is managed. As a result of full achievement of this process attribute: \na) Objectives for the performance of the process are identified; \nb) Performance of the process is planned; \nc) Performance of the process is monitored; \nd) Performance of the process is adjusted to meet plans; \ne) Responsibilities and authorities for performing the process are defined, assigned and \ncommunicated; \nf) Personnel performing the process are prepared for executing their responsibilities; \ng) Resources and information necessary for performing the process are identified, made available, \nallocated and used; \nh) Interfaces between the involved parties are managed to ensure both effective communic ation \nand clear assignment of responsibility. \n \nGeneric practices GP 2.1.1 Identify the objectives for the performance of the process. \n[ACHIEVEMENT a]  \nPerformance objectives are identified based on process requirements.  \nThe scope of the process performance is defined. \nAssumptions and constraints are considered when identifying the \nperformance objectives. \nNOTE 1: Performance objectives may include  \n(1) timely production of artifacts meeting the defined quality criteria, \n(2) process cycle time or frequency \n(3) resource usage; and \n(4) boundaries of the process. \nNOTE 2: At minimum, process performance objectives for resources, effort \nand schedule should be stated.  \nGP 2.1.2 Plan the performance of the process to fulfill the identified \nobjectives. [ACHIEVEMENT b] \nPlan(s) for the performance of the process are developed.  \nThe process performance cycle is defined. \nKey milestones for the performance of the process are established. \nEstimates for process performance attributes are determined and \nmaintained. \nProcess activities and tasks are defined. \nSchedule is defined and aligned with the approach to performing the \nprocess. \nProcess work product reviews are planned. \nGP 2.1.3 Monitor the performance of the process against the plans. \n[ACHIEVEMENT c]  \n\n  \n \n \n \n© VDA Quality Management Center 80 \n \n \nThe process is performed according to the plan(s). \nProcess performance is monitored to ensure planned results are \nachieved and to identify possible deviations \nGP 2.1.4 Adjust the performance of the process. [ACHIEVEMENT d] \nProcess performance issues are identified. \nAppropriate actions are taken when planned results and objectives are \nnot achieved. \nThe plan(s) are adjusted, as necessary.  \nRescheduling is performed as necessary. \nGP 2.1.5 Define responsibilities and authorities for performing the \nprocess. [ACHIEVEMENT e] \nResponsibilities, commitments and authorities to perform the process \nare defined, assigned and communicated. \nResponsibilities and authorities to verify process work products are \ndefined and assigned. \nThe needs for process performance experience, knowledge and skills \nare defined. \nGP 2.1.6 Identify, prepare, and make available resources to \nperform the process according to plan. [ACHIEVEMENT f, g] \nThe human and infrastructure resources, necessary for performing the \nprocess are identified made available, allocated and used. \nThe individuals performing and managing the process are prepared by \ntraining, mentoring, or coaching to execute their responsibilities. \nThe information necessary to perform the process is identified and \nmade available. \nGP 2.1. 7 Manage the interfaces between involved parties. \n[ACHIEVEMENT h] \nThe individuals and groups involved in the process performance are \ndetermined. \nResponsibilities of the involved parties are assigned. \nInterfaces between the involved parties are managed. \nCommunication is assured between the involved parties. \nCommunication between the involved parties is effective. \nGeneric resources Human resources with identified objectives, responsibilities and \nauthorities [ACHIEVEMENT e, f, h] \nFacilities and infrastructure resources [ACHIEVEMENT g, h] \nProject planning, management and control tools, including time and \ncost reporting [ACHIEVEMENT a, b, c, d] \nWorkflow management system [ACHIEVEMENT d, f, g, h] \n\n  \n \n \n \n© VDA Quality Management Center 81 \n \n \nEmail and/or other communication mechanisms \n[ACHIEVEMENT b, c, d, f, g, h] \nInformation and/or experience repository [ACHIEVEMENT b, d, e] \nProblem and issues management mechanisms [ACHIEVEMENT c]\n\n### PA 2.2 Work product management process attribute\n\nThe work product management process attribute is a measure of the extent to which the work \nproducts produced by the process are appropriately managed. As a result of full achievement of \nthis process attribute: \na) Requirements for the work products of the process are defined; \nb) Requirements for documentation and control of the work products are defined; \nc) Work products are appropriately identified, documented, and controlled; \nd) Work products are reviewed in accordance with planned arrangements and adjusted as \nnecessary to meet requirements. \nNOTE 1: Requirements for documentation and control of work products may include requirements for the \nidentification of changes and revision status, approval and re-approval of work products, distribution \nof work products, and for making relevant versions of applicable work produc ts available at points \nof use. \nNOTE 2: The work products referred to in this clause are those that result from the achievement of the \nprocess purpose through the process outcomes. \n \nGeneric practices GP 2.2.1 Define the requirements for the work products. \n[ACHIEVEMENT a] \nThe requirements for the work products to be produced are defined. \nRequirements may include defining contents and structure. \nQuality criteria of the work products are identified. \nAppropriate review and approval criteria for the work products are \ndefined. \nGP 2.2.2 Define the requirements for documentation and control of \nthe work products. [ACHIEVEMENT b] \nRequirements for the documentation and control of the work products \nare defined. Such requirements may include requirements for \n(1) distribution, \n(2) identification of work products and their components and  \n(3) traceability. \nDependencies between work products are identified and understood. \nRequirements for the approval of work products to be controlled are \ndefined. \nGP 2.2.3 Identify, document and control the work products. \n[ACHIEVEMENT c] \nThe work products to be controlled are identified. \n\n  \n \n \n \n© VDA Quality Management Center 82 \n \n \nChange control is established for work products.  \nThe work products are documented and controlled in accordance with \nrequirements. \nVersions of work products are assigned to product configurations as \napplicable. \nThe work products are made available through appropriate access \nmechanisms. \nThe revision status of the work products may readily be ascertained. \nGP 2.2.4 Review and adjust work products to meet the defin ed \nrequirements. [ACHIEVEMENT d] \nWork products are reviewed against the defined requirements in \naccordance with planned arrangements. \nIssues arising from work product reviews are resolved. \nGeneric resources Requirement management method/toolset [ACHIEVEMENT a, b, c] \nConfiguration management system [ACHIEVEMENT b, c] \nDocumentation elaboration and support tool [ACHIEVEMENT b, c] \nDocument identification and control procedure [ACHIEVEMENT b, c] \nWork product review methods and experiences [ACHIEVEMENT d] \nReview management method/toolset [ACHIEVEMENT d] \nIntranets, extranets and/or other communication mechanisms \n[ACHIEVEMENT b, c] \nProblem and issue management mechanisms [ACHIEVEMENT d]\n\n## Process capability Level 3: Established process\n\nThe previously described Managed process is now implemented using a defined process that is \ncapable of achieving its process outcomes. \nThe following process attributes, together with the previously defined process attributes, \ndemonstrate the achievement of this level:\n\n### PA 3.1 Process definition process attribute\n\nThe process definition process attribute is a measure of the extent to which a standard process is \nmaintained to support the deployment of the defined process. As a result of full achievement of this \nprocess attribute: \na) A standard process, including appropriate tailoring guidelines, is defined and maintained that \ndescribes the fundamental elements that must be incorporated into a defined process; \nb) The sequence and interaction of the standard process with other processes is determined. \nc) Required competencies and roles for performing the process are identified as part of the \nstandard process; \nd) Required infrastructure and work environment for performing the process are identified as part \nof the standard process; \n\n  \n \n \n \n© VDA Quality Management Center 83 \n \n \ne) Suitable methods and measures for monitoring the effectiveness and suitability of the process \nare determined. \n \nGeneric practices GP 3.1.1 Define and maintain the standard process that will support \nthe deployment of the defined process. [ACHIEVEMENT a] \nA standard process is developed and maintained that includes the \nfundamental process elements. \nThe standard process identifies the deployment needs and deployment \ncontext. \nGuidance and/or procedures are provided to support implementation of \nthe process as needed. \nAppropriate tailoring guideline(s) are available as needed. \nGP 3.1.2 Determine the sequence and interaction between \nprocesses so that they work as an integrated system of processes. \n[ACHIEVEMENT b] \nThe standard process’s sequence and interaction with other processes \nare determined. \nDeployment of the standard process as a defined process maintains \nintegrity of processes. \nGP 3.1.3 Identify the roles and competencies, responsibilities , and \nauthorities for performing the standard process. [ACHIEVEMENT c] \nProcess performance roles are identified \nCompetencies for performing the process are identified. \nAuthorities necessary for executing responsibilities are identified. \nGP 3.1.4 Identify the required infrastructure and work environment \nfor performing the standard process. [ACHIEVEMENT d] \nProcess infrastructure components are identified (facilities, tools, \nnetworks, methods, etc.). \nWork environment requirements are identified. \nGP 3.1.5 Determine suitable methods and measures to monitor the \neffectiveness and suitability of the standard process. [ACHIEVEMENT \ne] \nMethods and measures for monitoring the effectiveness and suitability \nof the process are determined. \nAppropriate criteria and data needed to monitor the effectiveness and \nsuitability of the process are defined. \nThe need to conduct internal audit and management review is \nestablished. \nProcess changes are implemented to maintain the standard process. \nGeneric resources Process modeling methods/tools [ACHIEVEMENT a, b, c, d] \nTraining material and courses [ACHIEVEMENT a, b, c, d] \n\n  \n \n \n \n© VDA Quality Management Center 84 \n \n \nResource management system [ACHIEVEMENT d] \nProcess infrastructure [ACHIEVEMENT a, b, d] \nAudit and trend analysis tools [ACHIEVEMENT e] \nProcess monitoring method [ACHIEVEMENT e]\n\n### PA 3.2 Process deployment process attribute\n\nThe process deployment process attribute is a measure of the extent to which the standard process \nis deployed as a defined process to achieve its process outcomes. As a result of full achievement \nof this process attribute: \na) A defined process is deployed based upon an a ppropriately selected and/or tailored standard \nprocess; \nb) Required roles, responsibilities and authorities for performing the defined process are assigned \nand communicated; \nc) Personnel performing the defined process are competent on the basis of appropriate education, \ntraining, and experience; \nd) Required resources and information necessary for performing the defined process are made \navailable, allocated and used; \ne) Required infrastructure and work environment for performing the defined process are made \navailable, managed and maintained; \nf) Appropriate data are collected and analysed as a basis for understanding the behaviour of the \nprocess, to demonstrate the suitability and effectiveness of the process, and to evaluate where \ncontinual improvement of the process can be made. \n \nGeneric practices GP 3.2.1 Deploy a defined process that satisfies the context specific \nrequirements of the use of the standard process. [ACHIEVEMENT a] \nThe defined process is appropriately selected and/or tailored from the \nstandard process. \nConformance of defined process with standard process requirements is \nverified. \nGP 3.2.2 Assign and communicate roles, responsibilities and \nauthorities for performing the defined process. [ACHIEVEMENT b] \nThe roles for performing the defined process are assigned and \ncommunicated. \nThe responsibilities and authorities for performing the defined process \nare assigned and communicated. \nGP 3.2.3 Ensure necessary competencies for performing the \ndefined process. [ACHIEVEMENT c] \nAppropriate competencies for assigned personnel are identified. \nSuitable training is available for those deploying the defined process. \nGP 3.2.4 Provide resources and information to support the \nperformance of the defined process. [ACHIEVEMENT d] \n\n  \n \n \n \n© VDA Quality Management Center 85 \n \n \nRequired human resources are made available, allocated and used. \nRequired information to perform the process is made available, \nallocated and used. \nGP 3.2.5 Provide adequate process infrastructure to support the \nperformance of the defined process. [ACHIEVEMENT e] \nRequired infrastructure and work environment is available. \nOrganizational support to effectively manage and maintain the \ninfrastructure and work environment is available. \nInfrastructure and work environment is used and maintained. \nGP 3.2.6 Collect and analyze data about performance of the process \nto demonstrate its suitability and effectiveness. [ACHIEVEMENT f] \nData required to understand the behavior, suitability and effectiveness \nof the defined process are identified. \nData is collected and analyzed to understand the behavior, suitability \nand effectiveness of the defined process. \nResults of the analysis are used to identify where continual \nimprovement of the standard and/or defined process can be made. \nNOTE 1: Data about process performance may be qualitative or \nquantitative. \nGeneric resources Feedback mechanisms (customer, staff, other stakeholders) \n[ACHIEVEMENT f] \nProcess repository [ACHIEVEMENT a] \nResource management system [ACHIEVEMENT b, c, d] \nKnowledge management system [ACHIEVEMENT a, b, d, f] \nProblem and change management system [ACHIEVEMENT f] \nWorking environment and infrastructure [ACHIEVEMENT d, e] \nData collection analysis system [ACHIEVEMENT f] \nProcess assessment framework [ACHIEVEMENT f] \nAudit/review system [ACHIEVEMENT f]\n\n## Process capability Level 4: Predictable process\n\nThe previously described Established process now operates predictively within defined limits to \nachieve its process outcomes. Quantitative management needs are identified, measurement data \nare collected and analysed to identify assignable causes of variation. Corrective action is taken to \naddress assignable causes of variation. \nThe following process attributes, together with the previously defined process attributes, \ndemonstrate the achievement of this level: \n\n  \n \n \n \n© VDA Quality Management Center 86\n\n### PA 4.1 Quantitative analysis process attribute\n\nThe quantitative analysis process attribute is a measure of the extent to which information needs \nare defined, relationships between process elements are identified and data are collected. As a \nresult of full achievement of this process attribute: \na) The process is aligned with quantitative business goals; \nb) Process information needs in support of relevant defined quantitative business goals are \nestablished; \nc) Process measurement objectives are derived from process information needs; \nd) Measurable relationships between pr ocess elements that contribute to the process \nperformance are identified; \ne) Quantitative objectives for process performance in support of relevant business goals are \nestablished; \nf) Appropriate measures and frequency of measurement are identified and defined in  line with \nprocess measurement objectives and quantitative objectives for process performance; \ng) Results of measurement are collected, validated and reported in order to monitor the extent to \nwhich the quantitative objectives for process performance are met. \nNOTE 1: Information needs typically reflect management, technical, project, process or product needs.  \n \nGeneric practices GP 4.1.1 Identify business goals. [ACHIEVEMENT a] \nBusiness goals are identified that are supported by the quantitatively \nmeasured process. \nGP 4.1.2 Establish process information needs. [ACHIEVEMENT a, b]  \nStakeholders of the identified business goals and the quantitatively \nmeasured process, and their information needs are identified, defined \nand agreed. \nGP 4.1.3 Derive process measurement objectives from process \ninformation needs. [ACHIEVEMENT a, c] \nThe process measurement objectives to satisfy the established process \ninformation needs are derived. \nGP 4.1.4 Identify measurable relationships between process \nelements. [ACHIEVEMENT a, d] \nIdentify the relationships between process elements, which contribute \nto the derived measurement objectives. \nGP 4.1.5 Establish quantitative objectives. [ACHIEVEMENT a, e]  \nEstablish quantitative objectives for the identified measurable process \nelements and their relationships. Agreement with process stakeholders \nis established. \nGP 4.1.6 Identify process measures that support the achievement \nof the quantitative objectives. [ACHIEVEMENT a, f] \nDetailed measures are defined to support monitoring, analysis an d \nverification needs of the quantitative objectives. \nFrequency of data collection is defined. \n\n  \n \n \n \n© VDA Quality Management Center 87 \n \n \nAlgorithms and methods to create derived measurement results from \nbase measures are defined, as appropriate. \nVerification mechanism for base and derived measures is defined. \nNOTE 1: Typically, the standard process definition is extended to include the \ncollection of data for process measurement. \nGP 4.1.7 Collect product and process measurement results through \nperforming the defined process. [ACHIEVEMENT a, g] \nData collection mechanism is created for all identified measures. \nRequired data is collected within the defined frequency, and recorded. \nMeasurement results are analyzed, and reported to the identified \nstakeholders. \nNOTE 2: A product measure can contribute to a process measure, e.g. the \nproductivity of testing characterized by the number of defects found in a \ngiven timeframe in relation to the product defect rate in the field. \nGeneric resources Management information (cost, time, reliability, profitability, customer \nbenefits, risks etc.) [ACHIEVEMENT a, b, c, d, e, f] \nApplicable measurement techniques [ACHIEVEMENT a, d] \nProduct and Process measurement tools and results databases \n[ACHIEVEMENT a, d, e, f, g] \nProcess measurement framework  [ACHIEVEMENT a, d, e, f, g] \nTools for data analysis and measurement [ACHIEVEMENT a, b, c, d, e, f]\n\n### PA 4.2 Quantitative control process attribute\n\nThe quantitative control process attribute is a measure of the extent to which objectiv e data are \nused to manage process performance that is predictable. As a result of full achievement of this \nprocess attribute: \na) Techniques for analyzing the collected data are selected; \nb) Assignable causes of process variation are determined through analysis of the collected data; \nc) Distributions that characterize the performance of the process are established; \nd) Corrective actions are taken to address assignable causes of variation; \ne) Separate distributions are established (as necessary) for analyzing the process under the \ninfluence of assignable causes of variation. \n \nGeneric practices GP 4.2.1 Select analysis techniques. [ACHIEVEMENT a] \nAnalysis methods and techniques for control of the process \nmeasurements are defined. \nGP 4.2.2 Establish distributions that charac terize the process \nperformance. [ACHIEVEMENT c] \nExpected distributions and corresponding control limits for measurement \nresults are defined. \n\n  \n \n \n \n© VDA Quality Management Center 88 \n \n \nGP 4.2.3 Determine assignable causes of process variation. \n[ACHIEVEMENT b] \nEach deviation from the defined control limits is identified and recorded. \nDetermine assignable causes of these deviations by analyzing collected \ndata using the defined analysis techniques. \nAll deviations and assigned causes are recorded. \nGP 4.2.4 Identify and implement corrective actions to add ress \nassignable causes. [ACHIEVEMENT d] \nCorrective actions are determined, recorded, and implemented to \naddress assignable causes of variation. \nCorrective action results are monitored and evaluated to determine their \neffectiveness. \nGP 4.2.5 Establish separate distributions for analyzing the process \n[ACHIEVEMENT e] \nSeparate distributions are used to quantitatively understand the variation \nof process performance under the influence of assignable causes. \nGeneric resources Process control and analysis techniques [ACHIEVEMENT a, c] \nStatistical analysis tools/applications [ACHIEVEMENT a, b, c, e] \nProcess control tools/applications [ACHIEVEMENT d, e]\n\n## Process capability Level 5: Innovating process\n\nThe previously described Predictable process is now continually improved to respond to change \naligned with organizational goals. \nThe following process attributes, together with the previously defined process attributes, \ndemonstrate the achievement of this level:\n\n### PA 5.1 Process innovation process attribute\n\nThe process innovation process attribute is a measure of the extent to which changes to the \nprocess are identified from investigations of innovative approaches to the definition and deployment \nof the process. As a result of full achievement of this process attribute: \na) Process innovation objectives are defined that support the relevant business goals; \nb) Appropriate data are analysed to identify opportunities for innovation; \nc) Innovation opportunities derived from new technologies and process concepts are identified; \nd) An implementation strategy is established to achieve the process innovation objectives. \n \nGeneric practices GP 5.1.1 Define the process innovation objectives for the process \nthat support the relevant business goals. [ACHIEVEMENT a] \nNew business visions and goals are analyzed to give guidance for new \nprocess objectives and potential areas of process innovation. \nGP 5.1.2 Analyze data of the process to identify opportunities for \ninnovation. [ACHIEVEMENT b] \n\n  \n \n \n \n© VDA Quality Management Center 89 \n \n \nCommon causes of variation in process performance are identified and \nanalyzed to get a quantitative understanding of their impact. \nIdentify opportunities for innovation based on the quantitative \nunderstanding of the analyzed data. \nGP 5.1.3 Analyze new technologies and process concepts  to \nidentify opportunities for innovation. [ACHIEVEMENT c] \nIndustry best practices, new technologies and process concepts are \nidentified and evaluated.  \nFeedback on opportunities for innovation is actively sought. \nEmergent risks are considered in evaluating improvement opportunities. \nGP 5.1.4 Define and maintain an implementation strategy based on \ninnovation vision and objectives. [ACHIEVEMENT d] \nCommitment to innovation is demonstrated by organizational \nmanagement including the process owner(s) and other relevant \nstakeholders. \nDefine and maintain an implementation strategy to achieve identified \nopportunities for innovation and objectives. \nBased on implementation strategy process changes are planned, \nprioritized based on their impact on defined innovations. \nMeasures that validate the results of process changes are defined to \ndetermine the expected effectiveness of the process changes and the \nexpected impact on defined business objectives.           \nGeneric resources Process improvement framework [ACHIEVEMENT a, c, d] \nProcess feedback and analysis system  (measurement data, causal \nanalysis results etc.) [ACHIEVEMENT b, c] \nPiloting and trialing mechanism [ACHIEVEMENT c, d]\n\n### PA 5.2 Process innovation implementation process attribute\n\nThe process innovation process implementation attribute is a measure of the extent to which \nchanges to the definition, management and performance of the process achieves the relevant \nprocess innovation objectives. As a result of full achievement of this process attribute: \na) Impact of all proposed changes is assessed against the objectives of the defined process and \nstandard process; \nb) Implementation of all agreed changes is managed to ensure that any disruption to the process \nperformance is understood and acted upon; \nc) Effectiveness of process change on the basis of actual performance is evaluated against the \ndefined product requirements and process objectives. \n \nGeneric practices GP 5.2.1 Assess the impact of each proposed change against the \nobjectives of the defined and standard process. [ACHIEVEMENT a] \nObjective priorities for process innovation are established. \n\n  \n \n \n \n© VDA Quality Management Center 90 \n \n \nSpecified changes are assessed against product quality and process \nperformance requirements and goals. \nImpact of changes to other defined and standard processes is \nconsidered. \nGP 5.2.2. Manage the implementation of agreed  changes. \n[ACHIEVEMENT b] \nA mechanism is established for incorporating accepted changes into \nthe defined and standard process(es) effectively and completely. \nThe factors that impact the effectiveness and full deployment of the \nprocess change are identified and managed, such as: \n• Economic factors (productivity, profit, growth, efficiency, quality, \ncompetition, resources, and capacity ); \n• Human factors (job satisfaction, motivation, morale, \nconflict/cohesion, goal consensus, participation, training, span of \ncontrol); \n• Management factors (skills, commitment, leadership, knowledge, \nability, organizational culture and risks); \n• Technology factors (sophistication of system, technical expertise, \ndevelopment methodology, need of new technologies). \nTraining is provided to users of the process. \nProcess changes are effectively communicated to all affected parties. \nRecords of the change implementation are maintained. \nGP 5.2.3 Evaluate the effectiveness of process  change. \n[ACHIEVEMENT c] \nPerformance and capability of the changed process are measured and \nevaluated against process objectives and historical data. \nA mechanism is available for documenting and reporting analysis \nresults to management and owners of standard and defined process. \nMeasures are analyzed to determine whether the process performance \nhas improved with respect to common causes of variations. \nOther feedback is recorded, such as opportunities for further innovation \nof the predictable process. \nGeneric resources Change management system [ACHIEVEMENT a, b, c] \nProcess evaluation system (impact analysis, etc.) [ACHIEVEMENT a, c] \n\n  \n \n \n \n© VDA Quality Management Center 91 \n \n \nAnnex A Conformity of the process assessment and reference model  \nA.1 Introduction \nThe Automotive SPICE process assessment and process reference model are meeting the \nrequirements for conformance defined in ISO/IEC  33004. The process assessment model can be \nused in the performance of assessments that meet the requirements of ISO/IEC 33002. \nThis clause serves as the statement of conformance of the process ass essment and process \nreference models to the requirements defined in ISO/IEC 33004. \n[ISO/IEC 33004, 5.5 and 6.4] \nDue to copyright reasons each  requirement is only referred by its number . T he full text  of the \nrequirements can be drawn from ISO/IEC 33004. \nA.2 Conformance to the requirements for process reference models \nClause 5.3, \"Requirements for process reference models\" \nThe following information is provided in chapter 1 and 3 of this document: \n• the declaration of the domain of this process reference model; \n• the description  of the relationship between this  process reference model and its intended \ncontext of use; and \n• the description of the relationship between the processes defined within this process reference \nmodel. \nThe descriptions of the processes within the  scope of th is process reference model  meeting the \nrequirements of ISO/IEC 33004 clause 5.4 is provided in chapter 4 of this document. \n [ISO/IEC 33004, 5.3.1] \nThe relevant communities of  interest and their mode of use  and the consensus achieved for this  \nprocess reference model is documented in the copyright notice and the scope of this document.  \n[ISO/IEC 33004, 5.3.2] \nThe process descriptions are unique. The identification is provided by unique names and by the \nidentifier of each process of this document. \n[ISO/IEC 33004, 5.3.3] \nClause 5.4, \"Process descriptions\" \nThese requirements are met by the process descriptions in chapter 4 of this document. \n[ISO/IEC 33004, 5.4] \n  \n\n  \n \n \n \n© VDA Quality Management Center 92 \n \n \nA.3 Conformance to the requirements for process assessment models \nClause 6.1, \"Introduction\" \nThe purpose of this process assessment model is to support assessment of process capability within \nthe automotive domain using the process measurement framework defined in ISO/IEC 33020.  \n[ISO/IEC 33004, 6.1] \nClause 6.2, \"Process assessment model scope\" \nThe process scope of this process assessment model is defined in the process reference model  \nincluded in chapter 3.1 of this document. The Automotive SPICE process reference m odel is \nsatisfying the requirements of ISO/IEC 33004, clause 5 as described in Annex A.2. \nThe process capability scope of this process assessment model is defined in the process \nmeasurement framework  specified in ISO/IEC 33020 , which defines a process measurement \nframework for process capability satisfying the requirements of ISO/IEC 33003. \n[ISO/IEC 33004, 6.2] \nClause 6.3, \"Requirements for process assessment models\" \nThe Automotive SPICE process assessment model is related to process capability. \n[ISO/IEC 33004, 6.3.1] \n \nThis process assessment model incorporates the process measurement framework specified in \nISO/IEC 33020, which satisfies the requirements of ISO/IEC 33003. \n[ISO/IEC 33004, 6.3.2] \n \nThis process assessment model is based on the Automotive SPICE Reference Model included in \nthis document. \nThis process assessment model is base d on the Measurement Framework defined in ISO/IEC \n33020. \n[ISO/IEC 33004, 6.3.3] \n \nThe processes included in this  process assessment model are identical to those specified  in the \nProcess Reference Model \n[ISO/IEC 33004, 6.3.4] \n \nFor all processes in this process assessment model all levels defined in the process measurement \nframework from ISO/IEC 33020 are addressed. \n[ISO/IEC 33004, 6.3.5] \n \nThis process assessment model defines  \n• the selected process quality characteristic; \n• the selected process measurement framework; \n• the selected process reference model(s); \n• the selected processes from the process reference model(s) \n\n  \n \n \n \n© VDA Quality Management Center 93 \n \n \nin chapter 3 of this document. \n[ISO/IEC 33004, 6.3.5 a-d] \n \nIn the capability dimension, this process assessment model addresses all of the process attributes \nand capability levels defined in the process measurement framework in ISO/IEC 33020. \n[ISO/IEC 33004, 6.3.5 e] \nClause 6.3.1, \"Assessment indicators\" \nNOTE: Due to an error in numbering in the published version of ISO/IEC 33004 the following  reference \nnumbers are redundant to those stated above. To refer to the correct clauses from ISO/IEC 33004, the \ntext of clause heading is additionally specified for the following three requirements.  \nThe Automotive SPICE process assessment model provides a two-dimensional view of process \ncapability for the processes in the process reference model, through the inclusion of assessment \nindicators as defined in chapter 3.3. The assessment indicators used are: \n• Base practices and output work products \n [ISO/IEC 33004, 6.3.1 a, \"Assessment indicators\"] \n \n• Generic practices and Generic resources \n[ISO/IEC 33004, 6.3.1 b, \"Assessment indicators\"] \nClause 6.3.2, \"Mapping process assessment models to process reference models\" \nThe mapping of the assessment indicators to the purpose and process outcomes of the processes \nin the process reference model is included in each description of the base practices in chapter 4.  \nThe mapping of the assessment indicators to the process attributes in the process measurement \nframework including all of the process attribute achievements is included in each description of the \ngeneric practices in chapter 5. \nEach mapping is indicated by a reference in square brackets. \n[ISO/IEC 33004, 6.3.2, \"Mapping process assessment models\"] \nClause 6.3.3, \"Expression of assessment results\" \nThe process attributes and the process attribute ratings in this process assessment model are \nidentical to those defined in the measurement framework. As a consequence, results of assessments \nbased upon this process ass essment model are expressed directly as a set of process attribute \nratings for each process within the scope of the assessment. No form of translation or conversion is \nrequired. \n[ISO/IEC 33004, 6.3.3, \"Expression of assessment results\"] \n\n  \n \n \n \n© VDA Quality Management Center 94 \n \n \nAnnex B Work product characteristics \nWork product characteristics listed in this Annex can be used when reviewing potential outputs of \nprocess implementation. The characteristics are provided as guidance for the attributes to look for, \nin a particular sample work product, to provide objective evidence supporting the assessment of a \nparticular process. \nA documented process and assessor judgment is needed to ensure that the process context \n(application domain, business purpose, development methodology, size of the organization, etc.) is \nconsidered when using this information. \nWork products are defined using the schema in  table B.1. Work products and their characteristics \nshould be considered as a starting point for considering whether, given the  context, they are \ncontributing to the intended purpose of the process, not as a check -list of what every organization \nmust have.  \nTable B.1 — Structure of WPC tables \nWork product \nidentifier \nAn identifier number for the work product which is used to reference the work product. \nWork product \nname \nProvides an example of a typical name associated with the work product \ncharacteristics. This name is provided as an identifier of the type of work product the \npractice or process might produce. Organizations may call these work products by \ndifferent names. The name of the work product in the organization is not significant. \nSimilarly, organizations may have several equivalent work products which contain the \ncharacteristics defined in one work product type. The formats for the work products can \nvary. It is up to the assessor and the organizational unit coordinator to map the actual \nwork products produced in their organization to the examples given here.  \nWork product \ncharacteristics \nProvides examples of the potential characteristics associated with the work product \ntypes. The assessor may look for these in the samples provided by the organizational \nunit.  \nWork products (with the ID NN-00) are sets of characteristics that would be expected to be evident \nin work products  of generic types as a result of achievement of an attribute. The generic work \nproducts form the basis for the classification of specific work products defined as process \nperformance indicators.  \nSpecific work product types are typically created by process  owners and applied by process \ndeployers in order to satisfy an outcome of a particular process purpose. \nNOTE: The generic work products denoted with * are not used in the Automotive SPICE process \nassessment model but are included for completeness. \nTable B.2 — Work product characteristics \nWP ID WP Name WP Characteristics \n01-00 Configuration item \n \n• Item which is maintained under configuration control: \n- may include components, subsystems, libraries, test cases, \ncompilers, data, documentation, physical media, and external \ninterfaces \n• Version identification is maintained \n• Description of the item is available including the: \n- type of item \n- associated configuration management library, file, system \n- responsible owner \n- date when placed under configuration control \n- status information (i.e., development, baselined, released) \n- relationship to lower level configured items \n\n  \n \n \n \n© VDA Quality Management Center 95 \n \n \nWP ID WP Name WP Characteristics \n- identification of the change control records \n- identification of change history \n01-03 Software item • Integrated software consisting of: \n- source code \n- software elements \n- executable code \n- configuration files \n• Documentation, which: \n- describes and identifies source code \n- describes and identifies software elements \n- describes and identifies configuration files \n- describes and identifies executable code \n- describes software life-cycle status \n- describes archive and release criteria \n- describes compilation of software units \n- describes building of software item \n01-50 Integrated software • An aggregate of software items \n• A set of executables for a specific ECU configuration and possibly \nassociated documentation and data \n01-51 Application \nparameter \n \n• Name \n• Description \n• Value domain, threshold values, characteristic curves \n• Owner \n• Means of data application (e.g. flashing interfaces) \n• If necessary a grouping/a categorization: \n- name of the category/group/file name \n- description \n• Actual value or characteristic curve applied  \n02-00 Contract • Defines what is to be purchased or delivered \n• Identifies time frame for delivery or contracted service dates \n• Identifies any statutory requirements \n• Identifies monetary considerations \n• Identifies any warranty information \n• Identifies any copyright and licensing information \n• Identifies any customer service requirements \n• Identifies service level requirements \n• References to any performance and quality \nexpectations/constraints/monitoring  \n• Standards and procedures to be used \n• Evidence of review and approval \n• As appropriate to the contract the following are considered: \n- references to any acceptance criteria \n- references to any special customer needs (i.e., confidentiality \nrequirements, security, hardware, etc.) \n- references to any change management and problem resolution \nprocedures \n- identification of any interfaces to independent agents and \nsubcontractors \n- identification of customer's role in the development and \nmaintenance process \n- identification of resources to be provided by the customer \n02-01 Commitment / \nagreement \n• Signed off by all parties involved in the commitment/agreement \n\n  \n \n \n \n© VDA Quality Management Center 96 \n \n \nWP ID WP Name WP Characteristics \n• Establishes what the commitment is for \n• Establishes the resources required to fulfill the commitment, such as: \n- time \n- people \n- budget \n- equipment \n- facilities \n03-00 * Data • Result of applying a measure \n03-03 Benchmarking data • Results of measurement of current performance that allow comparison \nagainst historical or target values \n• Relates to key goals/process/product/market need criteria and \ninformation to be benchmarked \n03-04 Customer \nsatisfaction data \n• Determines levels of customer satisfaction with products and services \n• Mechanism to collect data on customer satisfaction: \n- results of field performance data \n- results of customer satisfaction survey \n- interview notes \n- meeting minutes from customer meetings \n03-06 Process \nperformance data \n• Data comparing process performance against expected levels \n• Defined input and output work products available \n• Meeting minutes \n• Change records \n• Task completion criteria met \n• Quality criteria met \n• Resource allocation and tracking \n04-00 * Design • Describes the overall product/system structure \n• Identifies the required product/system elements \n• Identifies the relationship between the elements \n• Consideration is given to: \n- any required performance characteristics \n- any required interfaces \n- any required security characteristics \n04-02 Domain architecture • Identified domain model(s) tailored from \n• Identified asset specifications \n• Definition of boundaries and relationships with other domains (Domain \nInterface Specification) \n• Identification of domain vocabulary \n• Identification of the domain representation standard \n• Provides an overview of the functions, features capabilities and \nconcepts in the domains \n04-03 Domain model • Must provide a clear explanation and description, on usage and \nproperties, for reuse purposes \n• Identification of the management and structures used in the model \n04-04 \n \nSoftware \narchitectural design  \n \n• Describes the overall software structure \n• Describes the operative system including task structure \n• Identifies inter-task/inter-process communication \n• Identifies the required software elements \n• Identifies own developed and supplied code \n• Identifies the relationship and dependency between software elements \n• Identifies where the data (such as application parameters or variables) \nare stored and which measures (e.g. checksums, redundancy) are \ntaken to prevent data corruption  \n\n  \n \n \n \n© VDA Quality Management Center 97 \n \n \nWP ID WP Name WP Characteristics \n• Describes how variants for different model series or configurations are \nderived \n• Describes the dynamic behavior of the software (Start-up, shutdown, \nsoftware update, error handling and recovery, etc.) \n• Describes which data is persistent and under which conditions  \n• Consideration is given to: \n- any required software performance characteristics \n- any required software interfaces \n- any required security characteristics required \n- any database design requirements \n04-05 \n \nSoftware detailed \ndesign \n• Provides detailed design (could be represented as a prototype, flow \nchart, entity relationship diagram, pseudo code, etc.) \n• Provides format of input/output data \n• Provides specification of CPU, ROM, RAM, EEPROM and Flash needs \n• Describes the interrupts with their priorities \n• Describes the tasks with cycle time and priority \n• Establishes required data naming conventions \n• Defines the format of required data structures \n• Defines the data fields and purpose of each required data element \n• Provides the specifications of the program structure \n04-06 System architectural \ndesign \n• Provides an overview of all system design \n• Describes the interrelationship between system elements \n• Describes the relationship between the system elements and the \nsoftware \n• Specifies the design for each required system element, consideration is \ngiven to aspects such as: \n- memory/capacity requirements \n- hardware interface requirements \n- user interface requirements \n- external system interface requirements \n- performance requirements \n- command structures \n- security/data protection characteristics \n- settings for system parameters (such as application parameters or \nglobal variables) \n- manual operations \n- reusable components \n• Mapping of requirements to system elements \n• Description of the operation modes of the system components (startup, \nshutdown, sleep mode, diagnosis mode, etc.) \n• Description of the dependencies among the system components \nregarding the operation modes \n• Description of the dynamic behavior of the system and the system \ncomponents \n05-00 Goals • Identifies the objective to be achieved \n• Identifies who is expected to achieve the goal \n• Identifies any incremental supporting goals \n• Identifies any conditions/constraints \n• Identifies the timeframe for achievement \n• Are reasonable and achievable within the resources allocated \n• Are current, established for current project, organization \n• Are optimized to support known performance criteria and plans \n06-00 User documentation • Identifies: \n\n  \n \n \n \n© VDA Quality Management Center 98 \n \n \nWP ID WP Name WP Characteristics \n- external documents \n- internal documents \n- current site distribution and maintenance list maintained \n• Documentation kept synchronized with latest product release \n• Addresses technical issues \n06-01 Customer manual • Takes account of: \n- audience and task profiles \n- the environment in which the information will be used \n- convenience to users \n- the range of technical facilities, including resources and the \nproduct, available for developing and delivering on-screen \ndocumentation \n- information characteristics \n- cost of delivery and maintainability \n• Includes information needed for operation of the system, including but \nnot limited to: \n- product and version information \n- instructions for handling the system \n- initial familiarization information \n- long examples \n- structured reference material, particularly for advanced features of \nthe software \n- checklists \n- guides to use input devices \n06-02 Handling and \nstorage guide \n• Defines the tasks to perform in handling and storing products including:  \n- providing for master copies of code and documentation \n- disaster recovery \n- addressing appropriate critical safety and security issues \n• Provides a description of how to store the product including: \n- storage environment required \n- the protection media to use \n- packing materials required \n- what items need to be stored \n- assessments to be done on stored product \n• Provides retrieval instructions \n06-04 Training material • Updated and available for new releases \n• Coverage of system, application, operations, maintenance as \nappropriate to the application \n• Course listings and availability \n07-00 Measure • Available to those with a need to know \n• Understood by those expected to use them \n• Provides value to the organization/project \n• Non-disruptive to the work flow \n• Appropriate to the process, life cycle model, organization: \n- is accurate \n- source data is validated \n- results are validated to ensure accuracy \n• Has appropriate analysis and commentary to allow meaningful \ninterpretation by users \n07-01 Customer \nsatisfaction survey \n• Identification of customer and customer information \n• Date requested \n• Target date for responses \n• Identification of associated hardware/software/product configuration \n\n  \n \n \n \n© VDA Quality Management Center 99 \n \n \nWP ID WP Name WP Characteristics \n• Ability to record feedback \n07-02 Field measure • Measures attributes of the performance of system's operation at field \nlocations, such as: \n- field defects \n- performance against defined service level measures \n- system ability to meet defined customer requirements \n- support time required \n- user complaints (may be third party users) \n- customer requests for help \n- performance trends \n- problem reports \n- enhancements requested \n07-03 Personnel \nperformance \nmeasure \n• Real time measures of personnel performance or expected service \nlevel \n• Identifies aspects such as: \n- capacity \n- throughput \n- operational performance \n- operational service \n- availability \n07-04 Process measure • Measures about the process' performance: \n- ability to produce sufficient work products \n- adherence to the process \n- time it takes to perform process \n- defects related to the process \n• Measures the impact of process change \n• Measures the efficiency of the process \n07-05 Project measure • Monitors key processes and critical tasks, provides status information \nto the project on: \n- project performance against established plan \n- resource utilization against established plan \n- time schedule against established plan \n- process quality against quality expectations and/or criteria \n- product quality against quality expectations and/or criteria \n- highlight product performance problems, trends \n• Measures the results of project activities: \n- tasks are performed on schedule \n- product's development is within the resource commitments \nallocated \n• References any goals established \n07-06 Quality measure • Measures quality attributes of the work products defined: \n- functionality \n- reliability \n- usability \n- efficiency \n- maintainability \n- portability \n• Measures quality attributes of the \"end customer\" product quality and \nreliability \nNOTE: Refer ISO/IEC 25010 for detailed information on measurement of \nproduct quality. \n07-07 Risk measure • Identifies the probability of risk occurring \n\n  \n \n \n \n© VDA Quality Management Center 100 \n \n \nWP ID WP Name WP Characteristics \n• Identifies the impact of risk occurring  \n• Establishes measures for each risk defined \n• Measures the change in the risk state \n07-08 Service level \nmeasure \n• Real time measures taking while a system is operational, it measures \nthe system's performance or expected service level \n• Identifies aspects such as: \n- capacity \n- throughput \n- operational performance \n- operational service \n- service outage time \n- up time \n- job run time \n08-00 Plan As appropriate to the application and purpose: \n• Identifies what objectives or goals there are to be satisfied \n• Establishes the options and approach for satisfying the objectives, or \ngoals \n• Identification of the plan owner \n• Includes: \n- the objective and scope of what is to be accomplished \n- assumptions made \n- constraints \n- risks \n- tasks to be accomplished \n- schedules, milestones and target dates \n- critical dependencies \n- maintenance disposition for the plan \n• Method/approach to accomplish plan \n• Identifies: \n- task ownership, including tasks performed by other parties (e.g. \nsupplier, customer) \n- quality criteria \n- required work products \n• Includes resources to accomplish plan objectives: \n- time \n- staff (key roles and authorities e.g. sponsor) \n- materials/equipment \n- budget \n• Includes contingency plan for non-completed tasks \n• Plan is approved \n08-04 Configuration \nmanagement plan \n• Defines or references the procedures to control changes to \nconfiguration items \n• Defines measurements used to determine the status of the \nconfiguration management activities \n• Defines configuration management audit criteria \n• Approved by the configuration management function \n• Identifies configuration library tools or mechanism \n• Includes management records and status reports that show the status \nand history of controlled items \n• Specifies the location and access mechanisms for the configuration \nmanagement library \n• Storage, handling and delivery (including archival and retrieval) \nmechanisms specified \n\n  \n \n \n \n© VDA Quality Management Center 101 \n \n \nWP ID WP Name WP Characteristics \n08-12 Project plan • Defines: \n- work products to be developed \n- life cycle model and methodology to be used \n- customer requirements related to project management \n- project resources \n• Milestones and target dates: \n- estimates \n- quality criteria \n- processes and methods to employ \n- contingency actions  \n08-13 Quality plan • Objectives/goal for quality \n• Defines the activities tasks required to ensure quality \n• References related work products \n• References any regulatory requirements, standards, customer \nrequirements \n• Identifies the expected quality criteria \n• Specifies the monitoring and quality checkpoints for the defined life \ncycle and associated activities planned \n• Defines the methods of assuring quality \n• Identifies the quality criteria for work products and process tasks \n• Specifies the threshold/tolerance level allowed prior to requiring \ncorrective actions \n• Defines quality measurements and timing of the collection \n• Specifies mechanism to feed collected quality record back into process \nimpacted by poor quality \n• Defines the approach to guaranteeing objectivity \n• Approved by the quality responsible organization/function: \n- identifies escalations opportunities and channels  \n- defines the cooperation with customer and supplier QA \n08-14 Recovery plan • Identifies what is to be recovered: \n- procedures/methods to perform the recovery \n- schedule for recovery \n- time required for the recovery \n- critical dependencies \n- resources required for the recovery \n- list of backups maintained \n- staff responsible for recovery and roles assigned \n- special materials required \n- required work products \n- required equipment \n- required documentation \n- locations and storage of backups \n- contact information on who to notify about the recovery \n- verification procedures \n- cost estimation for recovery \n08-16 Release plan • Identifies the functionality to be included in each release \n• Identifies the associated elements required (i.e., hardware, software, \ndocumentation etc.) \n• Mapping of the customer requests, requirements satisfied to particular \nreleases of the product \n08-17 Reuse plan • Defines the policy about what items to be reused \n• Defines standards for construction of reusable objects: \n- defines the attributes of reusable components \n\n  \n \n \n \n© VDA Quality Management Center 102 \n \n \nWP ID WP Name WP Characteristics \n- quality/reliability expectations \n- standard naming conventions \n• Defines the reuse repository (library, CASE tool, file, data base, etc.) \n• Identifies reusable components: \n- directory of component \n- description of components \n- applicability of their use \n- method to retrieve and use them \n- restrictions for modifications and usage \n• Method for using reusable components \n• Establishes goal for reusable components \n08-18 Review plan • Defines: \n- what to be reviewed \n- roles and responsibilities of reviewers \n- criteria for review (check-lists, requirements, standards) \n- expected preparation time \n- schedule for reviews \n• Identification of: \n- procedures for conducting review \n- review inputs and outputs \n- expertise expected at each review \n- review records to keep \n- review measurements to keep \n- resources, tools allocated to the review \n08-19 Risk management \nplan \n• Project risks identified and prioritized \n• Mechanism to track the risk \n• Threshold criteria to identify when corrective action required \n• Proposed ways to mitigate risks: \n- risk mitigator \n- work around \n- corrective actions activities/tasks \n- monitoring criteria \n- mechanisms to measure risk \n08-20 Risk mitigation plan • Planned risk treatment activities and tasks: \n- describes the specifics of the risk treatment selected for a risk or \ncombination of risks found to be unacceptable \n- describes any difficulties that may be found in implementing the \ntreatment \n• Treatment schedule \n• Treatment resources and their allocation \n• Responsibilities and authority: \n- describes who is responsible for ensuring that the treatment is \nbeing implemented and their authority \n• Treatment control measures: \n- defines the measures that will be used to evaluate the \neffectiveness of the risk treatment \n• Treatment cost \n• Interfaces among parties involved: \n- describes any coordination among stakeholders or with the \nproject’s master plan that must occur for the treatment to be \nproperly implemented \n• Environment/infrastructure: \n\n  \n \n \n \n© VDA Quality Management Center 103 \n \n \nWP ID WP Name WP Characteristics \n- describes any environmental or infrastructure requirements or \nimpacts (e.g., safety or security impacts that the treatment may \nhave) \n• Risk treatment plan change procedures and history \n08-26 Documentation plan \n \n• Identifies documents to be produced \n• Defines the documentation activities during the life cycle of the \nsoftware product or service \n• Identifies any applicable standards and templates \n• Defines requirements for documents \n• Review and authorization practices \n• Distribution of the documents  \n• Maintenance and disposal of the documents \n08-27 Problem \nmanagement plan \n• Defines problem resolution activities including identification, recording, \ndescription and classification \n• Problem resolution approach: evaluation and correction of the problem  \n• Defines problem tracking \n• Mechanism to collect and distribute problem resolutions \n08-28 Change \nmanagement plan \n• Defines change management activities including identification, \nrecording, description, analysis and implementation \n• Defines approach to track status of change requests \n• Defines verification and validation activities \n• Change approval and implication review \n08-29 Improvement plan • Improvement objectives derived from organizational business goals \n• Organizational scope \n• Process scope, the processes to be improved \n• Key roles and responsibilities \n• Appropriate milestones, review points and reporting mechanisms \n• Activities to be performed to keep all those affected by the \nimprovement program informed of progress \n08-50 Test specification • Test Design Specification  \n• Test Case Specification \n• Test Procedure Specification \n• Identification of test cases for regression testing \n• Additionally, for system integration: \n- identification of required system elements (hardware elements, \nwiring elements, settings for parameters (such as application \nparameters or global variables) , data bases, etc.) \n- necessary sequence or ordering identified for integrating the \nsystem elements \n08-51 Technology \nmonitoring plan \nNo requirements additional to Plan (Generic) \n08-52 Test plan • Test Plan according to ISO29119-3 \n• Context: \n- project/Test sub-process \n- test item(s) \n- test scope \n- assumptions and constraints \n- stakeholder \n- testing communication \n• Test strategy \n- identifies what needs there are to be satisfied \n\n  \n \n \n \n© VDA Quality Management Center 104 \n \n \nWP ID WP Name WP Characteristics \n- establishes the options and approach for satisfying the needs \n(black-box and/or white-box-testing, boundary class test \ndetermination, regression testing strategy, etc.)  \n- establishes the evaluation criteria against which the strategic \noptions are evaluated \n- identifies any constraints/risks and how these will be addressed \n- test design techniques \n- test completion criteria \n- test ending criteria \n- test start, abort and re-start criteria \n- metrics to be collected \n- test data requirements \n- retesting and regression testing \n- suspension and resumption criteria \n- deviations from the Organizational Test Strategy \n• Test data requirements \n• Test environment requirements \n• Test sub-processes \n• Test deliverables \n• Testing activities and estimates \n09-00 Policy • Authorized \n• Available to all personnel impacted by the policy \n• Establishes practices/rules to be adhered to \n09-03 Reuse policy • Identification of reuse requirements \n• Establishes the rules of reuse \n• Documents the reuse adoption strategy including goals and objectives  \n• Identification of the reuse program \n• Identification of the name of the reuse sponsor \n• Identification of the reuse program participants \n• Identification of the reuse steering function \n• Identification of reuse program support functions \n10-00 Process description • A detailed description of the process/procedure which includes: \n- tailoring of the standard process (if applicable) \n- purpose of the process \n- outcomes of the process \n- task and activities to be performed and ordering of tasks \n- critical dependencies between task activities \n- expected time required to execute task \n- input/output work products \n- links between input and outputs work products \n• Identifies process entry and exit criteria \n• Identifies internal and external interfaces to the process \n• Identifies process measures \n• Identifies quality expectations \n• Identifies functional roles and responsibilities \n• Approved by authorized personnel \n11-00 Product • Is a result/deliverable of the execution of a process, includes services, \nsystems (software and hardware) and processed materials \n• Has elements that satisfy one or more aspects of a process purpose \n• May be represented on various media (tangible and intangible) \n11-03 Product release \ninformation \n• Coverage for key elements (as appropriate to the application): \n• Description of what is new or changed (including features removed) \n• System information and requirements \n\n  \n \n \n \n© VDA Quality Management Center 105 \n \n \nWP ID WP Name WP Characteristics \n• Identification of conversion programs and instructions \n• Release numbering implementation may include: \n- the major release number \n- the feature release number \n- the defect repair number \n- the alpha or beta release; and the iteration within the alpha or beta \nrelease \n• Identification of the component list (version identification included): \n- hardware / software / product elements, libraries, etc. \n- associated documentation list \n• New/changed parameter information (e.g. for application parameters or \nglobal variables) and/or commands \n• Backup and recovery information \n• List of open known problems, faults, warning information, etc. \n• Identification of verification and diagnostic procedures \n• Technical support information \n• Copyright and license information \n• The release note may include an introduction, the environmental \nrequirements, installation procedures, product invocation, new feature \nidentification and a list of defect resolutions, known defects and \nworkarounds \n11-04 Product release \npackage \n• Includes the hardware/software/product \n• Includes and associated release elements such as: \n- system hardware/software/product elements \n- associated customer documentation \n- application parameter definitions defined \n- command language defined \n- installation instructions \n- release letter \n11-05 Software unit • Follows established coding standards (as appropriate to the language \nand application): \n- commented \n- structured or optimized \n- meaningful naming conventions \n- parameter information identified \n- error codes defined \n- error messages descriptive and meaningful \n- formatting - indented, levels \n• Follows data definition standards (as appropriate to the language and \napplication): \n- variables defined \n- data types defined \n- classes and inheritance structures defined \n- objects defined \n• Entity relationships defined \n• Database layouts are defined \n• File structures and blocking are defined \n• Data structures are defined \n• Algorithms are defined  \n• Functional interfaces defined \n11-06 System • All elements of the product release are included \n• Any required hardware \n• Integrated product \n\n  \n \n \n \n© VDA Quality Management Center 106 \n \n \nWP ID WP Name WP Characteristics \n• Customer documentation \n• Fully configured set of the system elements: \n- application parameters defined \n- commands defined \n- data loaded or converted \n11-07 Temporary solution • Problem identification \n• Release and system information \n• Temporary solution, target date for actual fix identified \n• Description of the solution: \n- limitations, restriction on usage \n- additional operational requirements \n- special procedures \n- applicable releases \n• Backup/recovery information \n• Verification procedures \n• Temporary installation instructions \n12-00 Proposal • Defines the proposed solution \n• Defines the proposed schedule \n• Identifies the coverage identification of initial proposal: \n- identifies the requirements that would be satisfied \n- identifies the requirements that could not be satisfied, and provides \na justification of variants \n• Defines the estimated price of proposed development, product, or \nservice \n12-01 Request for proposal • Reference to the requirements specifications \n• Identifies supplier selection criteria \n• Identifies desired characteristics, such as: \n- system architecture, configuration requirements or the \nrequirements for service (consultants, maintenance, etc.) \n- quality criteria or requirements \n- project schedule requirements \n- expected delivery/service dates \n- cost/price expectations \n- regulatory standards/requirements \n• Identifies submission constraints: \n- date for resubmission of the response \n- requirements with regard to the format of response \n12-03 Reuse proposal • Identifies the project name \n• Identifies the project contact \n• Identifies the reuse goals and objectives \n• Identifies the list of reuse assets \n• Identifies the issues/risks of reusing the component including specific \nrequirements (hardware, software, resource and other reuse \ncomponents) \n• Identifies the person who will be approving the reuse proposal \n12-04 Supplier proposal \nresponse \n• Defines the suppliers proposed solution \n• Defines the suppliers proposed delivery schedule \n• Identifies the coverage identification of initial proposal: \n- identifies the requirements that would be satisfied \n- identifies the requirements that could not be satisfied, and provides \na justification of variants \n\n  \n \n \n \n© VDA Quality Management Center 107 \n \n \nWP ID WP Name WP Characteristics \n• Defines the estimated price of proposed development, product, or \nservice \n13-00 Record • Work product stating results achieved or provides evidence of activities \nperformed in a process \n• An item that is part of a set of identifiable and retrievable data \n13-01 Acceptance record • Record of the receipt of the delivery \n• Identification of the date received \n• Identification of the delivered components \n• Records the verification of any customer acceptance criteria defined \n• Signed by receiving customer \n13-04 Communication \nrecord \n• All forms of interpersonal communication including: \n- letters \n- faxes \n- e-mails \n- voice recordings \n- podcast \n- blog \n- videos \n- forum \n- live chat \n- wikis \n- photo protocol \n- meeting support record \n13-05 Contract review \nrecord \n• Scope of contract and requirements \n• Possible contingencies or risks \n• Alignment of the contract with the strategic business plan of the \norganization \n• Protection of proprietary information \n• Requirements which differ from those in the original documentation \n• Capability to meet contractual requirements \n• Responsibility for subcontracted work \n• Terminology \n• Customer ability to meet contractual obligations. \n13-06 Delivery record • Record of items shipped/delivered electronically to customer \n• Identification of: \n- who it was sent to \n- address where delivered \n- the date delivered \n• Record receipt of delivered product \n13-07 Problem record • Identifies the name of submitted and associated contact details \n• Identifies the group/person(s) responsible for providing a fix \n• Includes a description of the problem \n• Identifies classification of the problem (criticality, urgency, relevance \netc.) \n• Identifies the status of the reported problem \n• Identifies the target release(s) in which the problem will be fixed  \n• Identifies the expected closure date \n• Identifies any closure criteria \n• Identifies re-review actions \n13-08 Baseline • Identifies a state of one or a set of work products and artifacts which \nare consistent and complete  \n• Basis for next process steps \n\n  \n \n \n \n© VDA Quality Management Center 108 \n \n \nWP ID WP Name WP Characteristics \n• Is unique and may not be changed \nNOTE: This should be established before a release to identify consistent \nand complete delivery \n13-09 Meeting support \nrecord \n• Agenda and minutes that are records that define: \n- purpose of meeting \n- attendees \n- date, place held \n- reference to previous minutes \n- what was accomplished \n- identifies issues raised \n- any open issues \n- next meeting, if any \n13-10 Configuration \nmanagement record \n• Status of the work products/items and modifications \n• Identifies items under configuration control  \n• Identifies activities performed e.g. backup, storage, archiving, handling \nand delivery of configured items \n• Supports consistency of the product \n13-13 Product release \napproval record \n• Content information of what is to be shipped or delivered \n• Identification of: \n- for whom it is intended \n- the address where to deliver \n- the date released \n• Record of supplier approval \n13-14 Progress status \nrecord \n• Record of the status of a plan(s) (actual against planned) such as: \n- status of actual tasks against planned tasks \n- status of actual results against established objectives/goals \n- status of actual resources allocation against planned resources \n- status of actual cost against budget estimates \n- status of actual time against planned schedule \n- status of actual quality against planned quality \n• Record of any deviations from planned activities and reason why \n13-15 Proposal review \nrecord \n• Scope of proposal and requirements \n• Possible contingencies or risks \n• Alignment of the proposal with the strategic business plan of the \norganization \n• Protection of proprietary information \n• Requirements which differ from those in the original documentation \n• Capability to meet contractual requirements \n• Responsibility for subcontracted work \n• Terminology \n• Supplier ability to meet obligations \n• Approved \n13-16 Change request • Identifies purpose of change \n• Identifies request status (e.g., open, allocated, implemented, closed)  \n• Identifies requester contact information \n• Impacted system(s) \n• Impact to operations of existing system(s) defined \n• Impact to associated documentation defined \n• Criticality of the request, due date \n13-17 Customer request • Identifies request purpose, such as: \n- new development \n\n  \n \n \n \n© VDA Quality Management Center 109 \n \n \nWP ID WP Name WP Characteristics \n- enhancement \n- internal customer \n- operations \n- documentation \n- informational \n• Identifies request status information, such as: \n- date opened \n- current status \n- date assigned and responsible owner \n- date verified \n- date closed \n• Identifies priority/severity of the request \n• Identifies customer information, such as: \n- company/person initiating the request \n- contact information and details \n- system site configuration information \n- impacted system(s) \n- impact to operations of existing systems \n- criticality of the request \n- expected customer response/closure requirements \n• Identifies needed requirements/standards \n• Identifies information sent with request (i.e., RFPs, dumps, etc.) \n13-18 Quality record • Identifies what information to keep \n• Identifies what tasks/activities/process produce the information \n• Identifies when the data was collected \n• Identifies source of any associated data \n• Identifies the associated quality criteria \n• Identifies any associated measurements using the information \n• Identifies any requirements to be adhered to create the record, or \nsatisfied by the record \n13-19 Review record • Provides the context information about the review: \n- what was reviewed \n- lists reviewers who attended \n- status of the review \n• Provides information about the coverage of the review: \n- check-lists \n- review criteria \n- requirements \n- compliance to standards \n• Records information about: \n- the readiness for the review \n- preparation time spent for the review \n- time spent in the review \n- reviewers, roles and expertise \n• Review findings: \n- non-conformances  \n- improvement suggestions \n• Identifies the required corrective actions: \n- risk identification \n- prioritized list of deviations and problems discovered \n- the actions, tasks to be performed to fix the problem \n- ownership for corrective action \n- status and target closure dates for identified problems \n\n  \n \n \n \n© VDA Quality Management Center 110 \n \n \nWP ID WP Name WP Characteristics \n13-20 Risk action request • Date of initiation \n• Scope \n• Subject \n• Request originator \n• Risk management process context:  \n- this section may be provided once, and then referenced in \nsubsequent action requests if no changes have occurred \n- process scope \n- stakeholder perspective \n- risk categories \n- risk thresholds \n- project objectives \n- project assumptions \n- project constraints \n• Risks:  \n- this section may cover one risk or many, as the user chooses \n- where all the information above applies to the whole set of risks, \none action request may suffice \n- where the information varies, each request may cover the risk or \nrisks that share common information \n- risk description(s) \n- risk probability \n- risk consequences \n- expected timing of risk \n• Risk treatment alternatives: \n- alternative descriptions \n- recommended alternative(s) \n- justifications \n• Risk action request disposition: \n- each request should be annotated as to whether it is accepted, \nrejected, or modified, and the rationale provided for whichever \ndecision is taken \n13-21 Change control \nrecord \n• Used as a mechanism to control change to baselined \nproducts/products in official project release libraries \n• Record of the change requested and made to a baselined product \n(work products, software, customer documentation, etc.): \n- identification of system, documents impacted with change \n- identification of change requester \n- identification of party responsible for the change \n- identification of status of the change \n• Linkage to associated customer requests, internal change requests, \netc. \n• Appropriate approvals \n• Duplicate requests are identified and grouped \n13-22 \n \nTraceability record • All requirements (customer and internal) are to be traced \n• Identifies a mapping of requirement to life cycle work products \n• Provides the linkage of requirements to work product decomposition \n(i.e., requirement  design  code  test  deliverables, etc.) \n• Provides forward and backwards mapping of requirements to \nassociated work products throughout all phases of the life cycle \nNOTE: this may be included as a function of another defined work \nproduct (example: A CASE tool for design decomposition may have a \nmapping ability as part of its features) \n\n  \n \n \n \n© VDA Quality Management Center 111 \n \n \nWP ID WP Name WP Characteristics \n13-24 Validation results • Validation check-list \n• Passed items of validation \n• Failed items of validation \n• Pending items of validation  \n• Problems identified during validation \n• Risk analysis \n• Recommendation of actions \n• Conclusions of validation \n• Signature of validation \n13-25 Verification results • Verification check-list \n• Passed items of verification \n• Failed items of verification \n• Pending items of verification  \n• Problems identified during verification \n• Risk analysis \n• Recommendation of actions \n• Conclusions of verification \n• Signature of verification  \n13-50 Test result • Level Test Log  \n• Anomaly Report  \n• Level Test Report (Summary) \n- test cases not passed \n- test cases not executed \n- information about the test execution (date, tester name etc.) \nAdditionally where necessary: \n• Level Interim Test Status Report  \n• Master Test Report (Summary) \n14-00 * Register • A register is a compilation of data or information captured in a defined \nsequence to enable:  \n- an overall view of evidence of activities that have taken place \n- monitoring and analyzes \n- provides evidence of performance of a process over time \n14-01 Change history • Historical records of all changes made to an object (document, file, \nsoftware component, etc.): \n- description of change \n- version information about changed object \n- date of change \n- change requester information \n- change control record information \n14-02 Corrective action \nregister \n• Identifies the initial problem \n• Identifies the ownership for completion of defined action \n• Defines a solution (series of actions to fix problem) \n• Identifies the open date and target closure date \n• Contains a status indicator \n• Indicates follow up audit actions \n14-05 Preferred suppliers \nregister \n• Subcontractor or supplier history \n• List of potential subcontractor/suppliers \n• Qualification information \n• Identification of their qualifications \n• Past history information when it exists \n14-06 Schedule • Identifies the tasks to be performed \n\n  \n \n \n \n© VDA Quality Management Center 112 \n \n \nWP ID WP Name WP Characteristics \n• Identifies the expected and actual start and completion date for \nrequired tasks against progress/completion of tasks \n• Allows for the identification of critical tasks and task dependencies \n• Identifies task completion status, vs. planned date \n• Has a mapping to scheduled resource data \nNOTE: A schedule is consistent with the work breakdown structure, see \n14-09 \n14-08 Tracking system • Ability to record customer and process owner information \n• Ability to record related system configuration information \n• Ability to record information about problem or action needed: \n- date opened and target closure date \n- severity/criticality of item \n- status of any problem or actions needed \n- information about the problem or action owner \n- priority of problem resolution \n• Ability to record proposed resolution or action plan \n• Ability to provide management status information \n• Information is available to all with a need to know \n• Integrated change control system(s)/records \n14-09 Work breakdown \nstructure \n• Defines tasks to be performed, and their amendments \n• Documents ownership for tasks \n• Documents critical dependencies between tasks \n• Documents inputs and output work products \n• Documents the critical dependencies between defined work products \nNOTE: A work breakdown structure may be integrated into/part of the \nschedule, see 14-06 \n14-11 Work product list • Identifies:  \n- name of work product \n- work product reference ID \n- work product revision \n- when updated \n- work product status \n- when approved \n- reference to approval source \n- file reference \n14-50 Stakeholder groups \nlist \n• Identifies:  \n- relevant stakeholder groups \n- weight/importance of each stakeholder group \n- representative(s) for each stakeholder group \n- information needs of each stakeholder group \n15-00 * Report • A work product describing a situation that: \n- includes results and status \n- identifies applicable/associated information \n- identifies considerations/constraints \n- provides evidence/verification \n15-01 Analysis report • What was analyzed? \n• Who did the analysis? \n• The analysis criteria used: \n- selection criteria or prioritization scheme used \n- decision criteria \n- quality criteria \n\n  \n \n \n \n© VDA Quality Management Center 113 \n \n \nWP ID WP Name WP Characteristics \n• Records the results: \n- what was decided/selected \n- reason for the selection \n- assumptions made \n- potential risks \n• Aspects of correctness to analyze include: \n- completeness \n- understandability \n- testability \n- verifiability \n- feasibility \n- validity \n- consistency \n- adequacy of content \n15-03 Configuration status \nreport \n• Identification of the number of items under configuration management \n• Identification of risks associated to configuration management \n• Identification of the number of configuration management items lost \nand reason for their loss \n• Identification of problem and issues related to configuration \nmanagement \n• Identification of receiving parties \n• Identification of baselines made \n15-05 Evaluation report • States the purpose of evaluation \n• Method used for evaluation \n• Requirements used for the evaluation \n• Assumptions and limitations \n• Identifies the context and scope information required: \n- date of evaluation \n- parties involved \n- context details \n- evaluation instrument (check-list, tool) used \n• Records the result: \n- data \n- identifies the required corrective and preventive actions \n- improvement opportunities, as appropriate \n15-06 Project status report • A report of the current status of the project \n• Schedule: \n- planned progress (established objectives/goals) or completion \n(dates/deadlines) of tasks against \n- actual progress of tasks \n- reasons for variance from planned progress  \n- threats to continued progress  \n- contingency plans to maintain progress \n• Resources (human resources, infrastructure, hardware/materials, \nbudget): \n- planned expenditure against actual expenditure  \n- reasons for variance between planned and actual expenditure  \n- expected future expenditure  \n- contingency plans to achieve budget goals \n• Quality goals: \n- actual quality measures  \n- reasons for variance from planned quality measures  \n- contingency plans to achieve quality goals \n\n  \n \n \n \n© VDA Quality Management Center 114 \n \n \nWP ID WP Name WP Characteristics \n• Project issues: \n- issues which may affect the ability of the project to achieve its \ngoals.  \n- contingency plans to overcome threats to project goals \n15-07 Reuse evaluation \nreport \n• Identification of reuse opportunities \n• Identification of investment in Reuse \n• Identification of current skills and experience \n• Identification of reuse infrastructure \n• The evaluation report must represent current status in implementation \nof the reuse program \n15-08 Risk analysis report • Identifies the risks analyzed \n• Records the results of the analysis: \n- potential ways to mitigate the risk \n- assumptions made \n- constraints \n15-09 Risk status report • Identifies the status of an identified risk: \n- related project or activity \n- risk statement \n- condition \n- consequence \n- changes in priority \n- duration of mitigation, when started \n- risk mitigation activities in progress \n- responsibility \n- constraints \n15-12 Problem status \nreport \n• Presents a summary of problem records: \n- by problem categories/classification \n• Status of problem solving: \n- development of solved vs. open problems \n15-13 Assessment/audit \nreport \n• States the purpose of assessment \n• Method used for assessment \n• Requirements used for the assessment \n• Assumptions and limitations \n• Identifies the context and scope information required: \n- date of assessment \n- organizational unit assessed \n- sponsor information \n- assessment team \n- attendees \n- scope/coverage \n- assessees’ information \n- assessment Instrument (check-list, tool) used \n• Records the result: \n- data  \n- identifies the required corrective actions \n- improvement opportunities \n15-16 Improvement \nopportunity \n• Identifies what the problem is \n• Identifies what the cause of a problem is \n• Suggest what could be done to fix the problem \n• Identifies the value (expected benefit) in performing the improvement \n• Identifies the penalty for not making the improvement \n\n  \n \n \n \n© VDA Quality Management Center 115 \n \n \nWP ID WP Name WP Characteristics \n15-18 Process \nperformance report \nNo requirements additional to Evaluation report (Generic) \n15-21 Supplier evaluation \nreport \nNo requirements additional to Evaluation report (Generic) \n16-00 * Repository • Repository for components  \n• Storage and retrieval capabilities \n• Ability to browse content \n• Listing of contents with description of attributes \n• Sharing and transfer of components between affected groups \n• Effective controls over access \n• Maintain component descriptions \n• Recovery of archive versions of components \n• Ability to report component status \n• Changes to components are tracked to change/user requests \n16-03 Configuration \nmanagement system \n• Supports the configuration management strategy \n• Correct configuration of products \n• Can recreate any release or test configuration \n• Ability to report configuration status \n• Has to cover all relevant tools \n16-06 Process repository • Contains process descriptions \n• Supports multiple presentations of process assets \n17-00 Requirement \nspecification \n• Each requirement is identified \n• Each requirement is unique \n• Each requirement is verifiable or can be assessed (see 17-50) \n• Includes statutory and regulatory requirements \n• Includes issues/requirements from (contract) reviews \n17-02 Build list • Identification of aggregates of the software application system \n• Identification of required system elements (application parameter \nsettings, macro libraries, data bases, job control languages, etc.) \n• Necessary sequence ordering identified for compiling the software \nrelease \n• Input and output source libraries identified \n17-03 Stakeholder \nrequirements \n• Purpose/objectives defined \n• Includes issues/requirements from (contract) reviews \n• Identifies any:  \n- time schedule/constraints  \n- required feature and functional characteristics \n- necessary performance considerations/constraints \n- necessary internal/external interface considerations/constraints \n- required system characteristics/constraints \n- human engineering considerations/constraints \n- security considerations/constraints \n- environmental considerations/constraints \n- operational considerations/constraints \n- maintenance considerations/constraints \n- installation considerations/constraints \n- support considerations/constraints \n- design constraints \n- safety/reliability considerations/constraints \n- quality requirements/expectations \n17-05 * Documentation \nrequirements \n• Purpose/objectives defined \n• Proposed contents (coverage) defined \n\n  \n \n \n \n© VDA Quality Management Center 116 \n \n \nWP ID WP Name WP Characteristics \n• Intended audience defined \n• Identification of supported hardware/software/product release, system \ninformation \n• Identification of associated hardware/software/product requirements \nand designs satisfied by document \n• Identification of style, format, media standards expected definition of \nthe intended distribution requirement \n• Includes storage requirements \n17-08 Interface \nrequirements \nspecification \n• Defines relationships between two products, process or process tasks \n• Defines criteria and format for what is common to both \n• Defines critical timing dependencies or sequence ordering \n• Description of the physical interfaces of each system component like: \n- bus interfaces (CAN, MOST, LIN, Flexray etc.) \n- transceiver (type, manufacturer, etc.) \n- analogue interfaces \n- digital interfaces (PWM, I/O) \n- additional interfaces (IEEE, ISO, Bluetooth, USB, etc.) \n• Identification of the software interfaces of software components and \nother software item in terms of: \n- inter-process communication mechanisms \n- bus communication mechanisms \n17-11 Software \nrequirements \nspecification \n• Identifies standards to be used \n• Identifies any software structure considerations/constraints  \n• Identifies the required software elements \n• Identifies the relationship between software elements \n• Consideration is given to: \n- any required software performance characteristics \n- any required software interfaces \n- any required security characteristics required \n- any database design requirements \n- any required error handling and recovery attributes \n- any required resource consumption characteristics \n17-12 System \nrequirements \nspecification \n• System requirements include: functions and capabilities of the system; \nbusiness, organizational and user requirements; safety, security, \nhuman-factors engineering (ergonomics), interface, operations, and \nmaintenance requirements; design constraints and qualification \nrequirements. \n• Identifies the required system overview  \n• Identifies any interrelationship considerations/constraints between \nsystem elements \n• Identifies any relationship considerations/constraints between the \nsystem elements and the software \n• Identifies any design considerations/constraints for each required \nsystem element, including: \n- memory/capacity requirements \n- hardware interface requirements \n- user interface requirements \n- external system interface requirements \n- performance requirements \n- command structures \n- security/data protection characteristics \n- application parameter settings \n- manual operations \n- reusable components \n\n  \n \n \n \n© VDA Quality Management Center 117 \n \n \nWP ID WP Name WP Characteristics \n• Describes the operation capabilities  \n• Describes environmental capabilities \n• Documentation requirements \n• Reliability requirements \n• Logistical Requirements \n• Describes security requirements \n• Diagnosis requirements \n17-50 Verification criteria • Each requirement is verifiable or can be assessed \n• Verification criteria define the qualitative and quantitative criteria for \nverification of a requirement. \n• Verification criteria demonstrate that a requirement can be verified \nwithin agreed constraints. (Additional Requirement to 17-00 \nRequirements specification) \n18-00 * Standard • Identification of to whom/what they apply \n• Expectations for conformance are identified \n• Conformance to requirements can be demonstrated \n• Provisions for tailoring or exception to the requirements are included  \n18-01 Acceptance criteria • Defines expectations for acceptance like e.g.: \n- interfaces \n- schedules \n- messages \n- documents \n- meetings \n- joint reviews \n18-06 Product release \ncriteria \n• Defines expectations for product release: \n- release type and status \n- required elements of the release \n- product completeness including documentation \n- adequacy and coverage of testing \n- limit for open defects \n- change control status \n18-07 Quality criteria • Defines expectations for quality: \n- establishes what is an adequate work product (required elements, \ncompleteness expected, accuracy, etc.) \n- identifies what constitutes the completeness of the defined tasks \n- establishes life cycle transition criteria and the entry and exit \nrequirements for each process and/or activity defined \n- establishes expected performance attributes \n- establishes product reliability attributes \n18-50 Supplier qualification \ncriteria \n• Expectations for conformance, to be fulfilled by competent suppliers, \nare identified \n• Links from the expectations to national/international/domains-specific \nstandards/laws/regulations are described \n• Conformance to requirements can be demonstrated by the potential \nsuppliers or assessed by the acquiring organization \n• Provisions for tailoring or exception to the requirements are included  \n19-00 Strategy • Identifies what needs and objectives or goals there are to be satisfied \n• Establishes the options and approach for satisfying the needs, \nobjectives, or goals \n• Establishes the evaluation criteria against which the strategic options \nare evaluated \n• Identifies any constraints/risks and how these will be addressed \n\n  \n \n \n \n© VDA Quality Management Center 118 \n \n \nWP ID WP Name WP Characteristics \n19-05 Reuse strategy • Identify the goals for reuse \n• Identify the commitment for creating reusable components \n• Determine which product lines and type of artifacts should be \nsupported with reuse \n• Identify system and hardware/software/product elements which can be \nreused within the organization \n• Identify the reuse repository and tools \n19-10 Verification strategy • Verification methods, techniques, and tools \n• Work product or processes under verification \n• Degrees of independence for verification \n• Schedule for performing the above activities \n• Identifies what needs there are to be satisfied \n• Establishes the options and approach for satisfying the need \n• Establishes the evaluation criteria against which the strategic options \nare evaluated \n• Identifies any constraints/risks and how these will be addressed \n• Verification ending criteria \n• Verification start, abort and re-start criteria \n19-11 Validation strategy • Validation methods, techniques, and tools \n• Work products under validation \n• Degrees of independence for validation \n• Schedule for performing the above activities \n• Identifies what needs there are to be satisfied \n• Establishes the options and approach for satisfying the need \n• Establishes the evaluation criteria against which the strategic options \nare evaluated \n• Identifies any constraints/risks and how these will be addressed \n20-00 Template • Defines the attributes associated with a work product to be created as \na consequence of a process execution \n• Identifies technical elements typically associated with this product type \n• Defines expected form and style \n21-00 Work product • Defines the attributes associated with an artifact from a process \nexecution: \n- key elements to be represented in the work product \n\n  \n \n \n \n© VDA Quality Management Center 119 \n \n \nAnnex C Terminology \nAnnex C lists the applicable terminology references from ISO/IEC/IEEE 24765 and ISO/IEC/IEEE\n\n# It also provides terms which are specifically defined within Automotive SPICE. Some of these\n\ndefinitions are based on ISO/IEC/IEEE 24765.  \nTable C.1 — Terminology \nTerm Origin Description \nAcceptance testing ISO/IEC/IEEE\n\n# Formal testing conducted to enable a user, customer, or authorized\n\nentity to determine whether to accept a system or component. \nApplication \nparameter \nAutomotive \nSPICE V3.1 \nAn application parameter is a parameter containing data applied to \nthe system or software functions, behavior or properties. T he notion \nof application parameter is expressed in two ways: firstly, the logical \nspecification (including name, description, unit, value domain or \nthreshold values or characteristic curves, respectively), and, \nsecondly, the actual quantitative data value it receives by means of \ndata application. \nArchitecture \nelement \nAutomotive \nSPICE V3.1 \nResult of the decomposition of the architecture on system and \nsoftware level: \n• The system is decomposed into elements of the system \narchitecture across appropriate hierarchical levels. \n• The software is decomposed into elements of the software \narchitecture across appropriate hierarchical levels down to \nthe software components (the lowest level elements of the \nsoftware architecture). \nBaseline ISO/IEC/IEEE\n\n# A speci fication or product that has been formally reviewed and\n\nagreed upon, that thereafter serves as the basis for further \ndevelopment, and can be changed only through formal change \ncontrol procedures. \nBlack-box testing Automotive \nSPICE V3.1 \nMethod of requireme nt testing where tests are developed without \nknowledge of the internal structure and mechanisms of the tested \nitem. \nCode review Automotive \nSPICE V3.1 \nA check of the code by one or more qualified persons to determine \nits suitability for its intended use an d identify discrepancies from \nspecifications and standards.  \nCoding ISO/IEC/IEEE\n\n# The transforming of logic and data from design specifications (design\n\ndescriptions) into programming language. \nConsistency Automotive \nSPICE V3.1 \nConsistency addresses content and semantics and ensures that work \nproducts are not in contradiction to each other. Consistency is \nsupported by bidirectional traceability. \nDefect  → [FAULT] \nDynamic analysis ISO/IEC/IEEE\n\n# A process of evaluating a system or component based on its behavior\n\nduring execution. \nElement Automotive \nSPICE V3.1 \nElements are all structural objects on architectural and design level \non the left side of the \"V\". Such elements can be further decomposed \ninto more fine -grained sub -elements of the architecture or design \nacross appropriate hierarchical levels. \nError ISO/IEC/IEEE\n\n# The difference between a computed, observed, or measured value or\n\ncondition and the true, specified, or theoretically correct value or \ncondition. \n\n  \n \n \n \n© VDA Quality Management Center 120 \n \n \nFault ISO/IEC/IEEE\n\n# A manifestation of an error in software.\n\nFunctional \nrequirement \nISO/IEC/IEEE\n\n# A statement that identifies what a product or process must\n\naccomplish to produce required behavior and/or results. \nFunctional \nspecification \nISO/IEC/IEEE\n\n# A document that specifies the functions that a system or component\n\nmust perform. Often part of a requirements specification. \nFunctional testing ISO/IEC/IEEE\n\n# Testing conducted to evaluate the compliance of a system or\n\ncomponent with specified functional requirements. \nHardware ISO/IEC/IEEE\n\n# Physical equipment used to process, store, or transmit computer\n\nprograms or data. \nHardware item Automotive \nSPICE V3.1 \nA physical representation of a hardware element. \nIntegration Automotive \nSPICE V3.1 \nA process of combining items to larger items up to an overall system. \nIntegrated software \nitem \nAutomotive \nSPICE V3.1 \nA set of software units or items that are integrated into a larger \nassembly for the purpose of integration testing. \nIntegration testing Automotive \nSPICE V3.1 \nTesting in which items (software items, hardware items, or system \nitems) are combined and tested to evaluate the interaction among \nthem. \nIntegrated system \nitem \nAutomotive \nSPICE V3.1 \nA set of items that are integrated into a larger assembly for the \npurpose of integration testing. \nQuality assurance ISO/IEC/IEEE\n\n# A planned and systematic pattern of all actions necessary to provide\n\nadequate confidence that an item or product conforms to established \ntechnical requirements. \nRegression testing Automotive \nSPICE V3.1 \nSelective retesting of a system or item to verify that modifications \nhave not caused unintended effects and that the system or item still \ncomplies with its specified requirements. \nRequirement Automotive \nSPICE V3.1 \nA prope rty or capability that must be achieved or possessed by a \nsystem, system item, product, or service to satisfy a contract, \nstandard, specification or other formally imposed documents. \nRequirements \nspecification \nAutomotive \nSPICE V3.1 \nA document that specifies the requirements for a system or item. \nTypically included are functional requirements, performance \nrequirements, interface requirements, design requirements, and \ndevelopment standards. \nSoftware ISO/IEC/IEEE\n\n# Computer programs, procedures, and possibly associated\n\ndocumentation and data pertaining to the operation of a computer \nsystem. \nSoftware \ncomponent \nAutomotive \nSPICE V3.1 \nIn Automotive SPICE V3.1 the term \"software component\" is used for \nthe lowest level elements of the software architecture for which finally \nthe detailed design is defined. A software \"component\" consists of \none or more software \"units\". \n→ [ARCHITECTURE ELEMENT], [UNIT] \nSoftware element  → [ARCHITECTURE ELEMENT] \nSoftware item ISO/IEC/IEEE\n\n# Identifiable part of a software product.\n\nSoftware unit  → [UNIT] \n\n  \n \n \n \n© VDA Quality Management Center 121 \n \n \nStatic analysis Automotive \nSPICE V3.1 \nA process of evaluating an item based on its form, structure, content, \nor documentation. \nSystem Automotive \nSPICE V3.1 \nA collection of interacting items organized to accompli sh a specific \nfunction or set of functions within a specific environment. \nSystem item Automotive \nSPICE V3.1 \nIdentifiable part of the system. \nSystem test ISO/IEC/IEEE\n\n# Testing conducted on a complete, integrated system to evaluate the\n\nsystem's compliance with its specified requirements. \nTesting Automotive \nSPICE V3.1 \nActivity in which an item (system, hardware, or software) is executed \nunder specific conditions; and  the results are recorded , summarized \nand communicated. \nTraceability ISO/IEC/IEEE\n\n# The degree to which a relationship can be established between two\n\nor more products of the development process, especially products \nhaving a predecessor -successor or master -subordinate relationship \nto one another. \nUnit Automotive \nSPICE V3.1 \nPart of a software component which is not further subdivided.  \n→ [SOFTWARE COMPONENT] \nUnit test Automotive \nSPICE V3.1 \nThe testing of individual software units or a set of combined software \nunits. \nValidation ISO/IEC/IEEE\n\n# Validation demonstrates that the work item can be used by the users\n\nfor their specific tasks. \nVerification ISO/IEC/IEEE\n\n# Verification is confirmation, through the provision of objective\n\nevidence, that specified requirements have been fulfilled in a given \nwork item. \nWhite-box testing Automotive \nSPICE V3.1 \nMethod of testing where tests are developed based on the knowledge \nof the internal structure and mechanisms of the tested item. \n\n  \n \n \n \n© VDA Quality Management Center 122 \n \n \nAnnex D Key concepts \nThe following sections describe the key concepts that have been introduced in the Au tomotive \nSPICE PRM resp. PAM 3.1. They relate to the terminology described in Annex C Terminology. \nD.1 The \"Plug-in\" concept \nThe following figure shows the basic principle of the \"plug-in\" concept. The top-level comprises all \nsystem engineering processes organized in a system \"V\". Depending on the product to be developed \nthe corresponding engineering disciplines with their domain -specific processes (e.g. hardware \nengineering HWE, mechanical engineeri ng MEE, or software engineering SWE) can be added to \nthe assessment scope. All other processes such as management processes and supporting \nprocesses are domain-independent and are therefore designed in a way that they can be applied to \nboth the system level and the domain levels.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "64": {
    "node_id": "baafe92c-5814-47b4-bd9e-6026afc4e901",
    "title": "SYS.2",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "65": {
    "node_id": "ac079a42-7764-43fa-a602-6514c11d5648",
    "title": "SYS.5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "66": {
    "node_id": "8b19bc65-05bc-412c-8ec1-dd615d7f03f2",
    "title": "System level",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "67": {
    "node_id": "57d1f171-4b1e-4008-84b2-83dcca05c252",
    "title": "HWE.2",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "68": {
    "node_id": "aa222238-80f5-4063-8c1c-8e82bd041d8e",
    "title": "HWE.5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "69": {
    "node_id": "bdc12d9e-08b3-4f71-aecc-4dd75bb4a832",
    "title": "HWE.6 MEE.1",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "70": {
    "node_id": "c6eb2ee0-5e9b-42c0-99f4-3c4c4643c2ff",
    "title": "MEE.3",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "71": {
    "node_id": "90195d04-9c8e-4077-beff-f6e73db06582",
    "title": "MEE.4",
    "level": 2,
    "type": "clause",
    "content": "MEE.6SWE.1",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "72": {
    "node_id": "dd955493-f7e2-4e2d-aabf-53c8a2e3a8f1",
    "title": "SWE.3",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "73": {
    "node_id": "57c00b66-6eec-4829-b1f9-b8eae8eaa0fa",
    "title": "SWE.4",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "74": {
    "node_id": "1b1d23e4-27c8-4872-886f-336d4a4ef635",
    "title": "Domain level",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "75": {
    "node_id": "ba310179-f55d-4334-b9c5-28c21bc3412c",
    "title": "MAN.3",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "76": {
    "node_id": "7298675b-2492-473c-bfb4-d925e52752d6",
    "title": "SUP.1",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "77": {
    "node_id": "00ca43f4-7cda-4cd0-8756-daec8958f9a2",
    "title": "SUP.10",
    "level": 2,
    "type": "clause",
    "content": "SYS : System engineering\n SWE : Software engineering \n HWE : Hardware engineering\n MEE : Mechanical engineering\nVDA scope as part of Automotive SPICE 3.1 PRM/PAM\nExamplary processes for other domains, neither developed \nby VDA nor part of Automotive SPICE PRM/PAM\n \nFigure D.1 — The \"Plug-in\" concept \nAll processes printed in bold are part of the Automotive SPICE 3. 1 PRM/PAM whereas the other \nprocesses (mechanical engineering and hardware engineering) are not developed under VDA QMC \nmandate. \n  \n\n  \n \n \n \n© VDA Quality Management Center 123 \n \n \nD.2 The Tip of the \"V\" \nAll engineering processes (i.e. system engineering and software engineering) have been organized \naccording to the \"V model\" principle in such a way that each process on the left side is corresponding \nto exactly one process on the right side. Therefor e, the process SWE.3 \"Software Detailed Design \nand Unit Construction\" is separated from the process SWE.4 \"Software Unit Verification\".",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "78": {
    "node_id": "3bbdd12b-8f1d-4538-b5b2-315b005b4f3b",
    "title": "System Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "79": {
    "node_id": "71862cf5-56db-41d6-a26e-8585f82f2050",
    "title": "System Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "80": {
    "node_id": "e355f564-2f66-477c-a79a-78f0a773ab8b",
    "title": "System Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "81": {
    "node_id": "5bc2e253-d1d6-4df9-9193-8eabef2cf4e0",
    "title": "System Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "82": {
    "node_id": "23cae6b5-b5ef-4a0f-a512-736f3e7905d2",
    "title": "Software Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "83": {
    "node_id": "f0146dd3-d1c0-4111-8f4a-3976ea57140f",
    "title": "Software Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "84": {
    "node_id": "ad99e453-2f9b-4ede-9a91-196983d246f0",
    "title": "Software Detailed Design",
    "level": 2,
    "type": "clause",
    "content": "and Unit Construction",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "85": {
    "node_id": "8196c2e5-b3e0-4fe4-9da1-d0ccf1d930d4",
    "title": "Software Unit Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "86": {
    "node_id": "86330018-9967-48c4-83c4-44591741d7c0",
    "title": "Software Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "87": {
    "node_id": "b4499eeb-0e53-4ddf-8984-8f92d2f869ee",
    "title": "Software Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "Figure D.2 — The tip of the \"V\" \n \nD.3 Terms \"Element\", \"Component\", \"Unit\", and \"Item\" \nThe following figure depicts the relationships between element, component, software unit, and item, \nwhich are used consistently in the engineering processes. \nUnit\nComponent",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "88": {
    "node_id": "d7174d43-f050-4139-96e0-d3d7ed834502",
    "title": "System Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "89": {
    "node_id": "99f232b3-9e67-4b62-891e-e3de24b830cd",
    "title": "System Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "90": {
    "node_id": "b1e6e02b-bd46-4f15-8e0c-8cb5fc9e43eb",
    "title": "System Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "91": {
    "node_id": "b9b042dc-cac4-4ba7-ae86-816d17b8fa6f",
    "title": "System Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "92": {
    "node_id": "5ec469ed-445b-4072-9efb-7dde6823fca9",
    "title": "Software Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "93": {
    "node_id": "c45f2762-58e5-40a4-99d1-d30f3dc4978b",
    "title": "Software Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "94": {
    "node_id": "2fb60649-5e98-4fca-9c9d-7a335408227a",
    "title": "Software Detailed Design",
    "level": 2,
    "type": "clause",
    "content": "and Unit Construction",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "95": {
    "node_id": "66346e0d-c4f6-4419-ae6e-205aed1a664e",
    "title": "Software Unit Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "96": {
    "node_id": "de232e66-69d7-4465-a3a4-8d8f0d1541f3",
    "title": "Software Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "97": {
    "node_id": "b5119e07-2242-45ad-ab82-f5a0b44f7aa4",
    "title": "Software Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "Element Item\n \nFigure D.3 — Element, component, unit, and item \n\n  \n \n \n \n© VDA Quality Management Center 124 \n \n \nAn architecture consists of architectural \"elements\" that can be further decomposed into more fine- \ngrained architectural sub -\"elements\" across appropriate hierarchical levels. The software \n\"components\" are the lowest -level \"elements\" of the software architecture for which finally  the \ndetailed design is defined. A software \"component\" consists of one or more software \"units\". \n\"Items\" on the right side of the V -model correspond to \"elements\" on the left side (e.g. a software \n\"item\" can be an object file, a library or an executable). This can be a 1:1 or m:n relationship, e.g. an \n\"item\" may represent more than one architectural \"element\".  \n \nD.4 Traceability and consistency \nTraceability and consistency are addressed by two separate base practices in the Automotive SPICE\n\n## PAM. Traceability refers to the existence of references or links between work products thereby\n\nfurther supporting coverage, impact analysis, requirements implementation status tracking etc. In \ncontrast, consistency addresses content and semantics. \nFurthermore, bidirectional traceability has been explicitly defined between \n• test cases and test results, and \n• change requests and work products affected by these change requests. \nAn overview of bidirectional traceability and consistency is depicted in the following figure.",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "98": {
    "node_id": "8bf5499a-6415-4aed-a942-08e7fc303e55",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "99": {
    "node_id": "859f507b-58f9-4277-8bc0-73781e5f359c",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "100": {
    "node_id": "37accb1c-c953-405f-800c-c7c68d862db0",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "101": {
    "node_id": "f2cb1842-ddea-48d1-b939-696674875114",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "102": {
    "node_id": "1e074e26-db9b-4dfd-b5cc-8202e0cd00bf",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "103": {
    "node_id": "0060ba4b-8a45-44f8-98da-c9f470c92e4d",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "104": {
    "node_id": "d2027465-b129-48bf-b600-d8f19967325e",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "105": {
    "node_id": "1a34efc3-45af-4229-9517-700c9dd38b4d",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "106": {
    "node_id": "2ac7ae99-c34c-439f-9e36-96f54701ef3a",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "107": {
    "node_id": "102e36a2-8475-49cc-be15-cac36fd079f2",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "108": {
    "node_id": "a08c2a48-735f-43e9-a8ac-2830ea9a7024",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "109": {
    "node_id": "c8180b78-f317-42c2-a100-f72f20c665ad",
    "title": "BP8",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "110": {
    "node_id": "b9e398a9-3153-40c9-abe0-6a0327a909df",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "111": {
    "node_id": "27faabf4-491d-4237-a564-1e988cddb7b1",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "SWE.5.BP7",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "112": {
    "node_id": "1868ac15-5ae1-4270-a6dd-728474134f6d",
    "title": "BP8",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "113": {
    "node_id": "b6228a47-c543-422d-8cd9-807d132e144b",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "114": {
    "node_id": "27c7cef5-5a34-4237-90eb-591edfe4b135",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "SWE.3.BP5",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "115": {
    "node_id": "b845d780-455d-4333-b889-1e3208f860f1",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "116": {
    "node_id": "c6bdd151-187e-4a4a-98f2-ae5876de86ff",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "117": {
    "node_id": "76ad91e9-bd72-4728-bb28-8d8a1a4b2da3",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "118": {
    "node_id": "990e0c8e-5086-4182-83cb-dbc577eabcfb",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "119": {
    "node_id": "6ed1a1dd-8e9b-4264-b5a5-fc8fab2ca9da",
    "title": "BP6",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "120": {
    "node_id": "6dbe6b6d-d243-400e-824c-dc8bf9c3cdc1",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "121": {
    "node_id": "81642ef1-c68c-4fc7-88a6-5e9b9c7ada4a",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "122": {
    "node_id": "7e6be28f-ba8a-4203-a4a5-2437a8f1b2e5",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "123": {
    "node_id": "02f8c296-e0b7-46a2-822c-21fe2b7de145",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "124": {
    "node_id": "6e62415c-22f0-4ac1-aa82-8bc90a9b1d8b",
    "title": "BP8",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "125": {
    "node_id": "71879a89-7d39-4038-a117-cfb049f0da0e",
    "title": "BP7",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "126": {
    "node_id": "6da00f0a-9f7e-4665-9345-519195341324",
    "title": "BP8",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "127": {
    "node_id": "f6b479e0-2748-4963-babf-61004ad8316a",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "128": {
    "node_id": "673cd944-60cf-4fdd-87fe-7b2f0c357e08",
    "title": "BP5",
    "level": 2,
    "type": "clause",
    "content": "consistency\nbidirectional traceabilityStakeholder\nrequirements\nSystem requirements\nSystem architecture\nSoftware requirements\nSoftware architecture\nSoftware detailed\ndesign\nSoftware units\nUnit test specification Unit test results\nStatic verification\nresults\nChange requests\nTo affected work products\nSoftware integration\ntest results\nSoftware qualification\ntest results\nSoftware qualification\ntest specification\nTest cases\nSoftware integration\ntest specification\nTest cases\nSystem integration\ntest results\nSystem qualification\ntest results\nSystem qualification\ntest specification\nTest cases\nSystem integration\ntest specification\nTest cases\n \nFigure D.4 — Bidirectional traceability and consistency \n  \n\n  \n \n \n \n© VDA Quality Management Center 125 \n \n \nD.5 \"Agree\" and \"Summarize and Communicate\" \nThe information flow on the left side o f the \"V\" is ensured through a b ase practice \"Communicate \nagreed ‘work product x’\". The term \"agreed\" here means that there is a joint understanding between \naffected parties of what is meant by the content of the work product. \nThe information flow on the right side of the \"V\" is ensured through a base practice \"Summarize and \ncommunicate results\". The term \"Summarize\" refers to abstracted information resulting from test \nexecutions made available to all relevant parties. \nNote that these communication-oriented base practices do not necessarily require a formal approval, \nconfirmation, or release as rather targeted at by GP 2.1.7 on capability level 2. At capability level 1 \nthe communication-oriented base practices mean that the work products (or their content) are to be \ndisseminated to relevant parties.  \nAn overview of these aspects is shown in the following figure:",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "129": {
    "node_id": "d34da995-1f94-45d7-b1c9-0dac4067889e",
    "title": "System Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "130": {
    "node_id": "f78f878a-78af-470f-9ea4-10985a5c5894",
    "title": "System Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "131": {
    "node_id": "07f16296-fa99-454d-af2a-20e6c71a47c4",
    "title": "System Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "132": {
    "node_id": "66b37185-8d6b-4c92-b407-6509349c6b66",
    "title": "System Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "133": {
    "node_id": "208ade9e-8cf6-43f5-ac96-425203697485",
    "title": "Software Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "134": {
    "node_id": "e48fc7b7-21a6-4f80-93b0-8f358b8c0265",
    "title": "Software Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "135": {
    "node_id": "bb517cdb-fbad-4554-9a7f-e4c1a1de6cee",
    "title": "Software Detailed Design",
    "level": 2,
    "type": "clause",
    "content": "and Unit Construction",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "136": {
    "node_id": "9e3d1b13-7ace-4ec5-8da4-b9d8cb435065",
    "title": "Software Unit Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "137": {
    "node_id": "419b8083-829e-4bbf-b719-16711d1dcff8",
    "title": "Software Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "138": {
    "node_id": "956c138c-4930-442d-90c0-5c41ab8f0742",
    "title": "Software Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "BP: „communicate agreed…“ BP: „summarize and communicate…“\n \nFigure D.5 — Agree, summarize and communicate \nD.6 \"Evaluate\", \"Verification Criteria\" and \"Ensuring compliance\" \nThis section describes relations, differences, and commonalities between verification, testing, \nevaluation, and compliance. The following Figure D.6 provides an overview. \nVerification criteria are used as input for the development of the test cases or other verification \nmeasures that ensures compliance with the requirements. Verification criteria are only used in the \ncontext of System Requirements Analysis (SYS.2) and Software Requirements Analysis (SWE.1) \nprocesses. Verification aspects which cannot be covered by testing are cov ered by the verification \nprocess (SUP.2). \nCriteria for unit verification ensure compliance of the source code with the software detailed design \nand the non-functional requirements. Possible criteria for unit verification include unit test cases, unit \ntest data, coverage goals and coding standards and coding guidelines, e.g. MISRA. For unit testing, \nsuch criteria shall be defined in a unit test specification. This unit test specific ation may be \nimplemented e.g. as a script in an automated test bench.  \n\n  \n \n \n \n© VDA Quality Management Center 126 \n \n \nSWE.3.BP4: Evaluate\nSYS.3.BP5: Evaluate\nSWE.2.BP6: Evaluate",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "139": {
    "node_id": "f9922ab8-499a-4c22-a9e9-5b447e1360ce",
    "title": "System Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "140": {
    "node_id": "19774ab8-61fc-472c-bcbb-6f77b8a82bd0",
    "title": "System Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "141": {
    "node_id": "2bde56e4-35b9-41e5-b84c-7ebfe380bb3c",
    "title": "System Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "142": {
    "node_id": "1a89c8bb-26de-4d12-8f45-405e75b94f2a",
    "title": "System Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "143": {
    "node_id": "1f4b12ba-4e43-48a6-bc28-671af7c3dc54",
    "title": "Software Requirements",
    "level": 2,
    "type": "clause",
    "content": "Analysis",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "144": {
    "node_id": "3dbc698b-4acd-4635-99f1-f1c031aa3556",
    "title": "Software Architectural",
    "level": 2,
    "type": "clause",
    "content": "Design",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "145": {
    "node_id": "5f2b76a9-0d35-48ac-8cee-36db20cfa9ba",
    "title": "Software Detailed Design",
    "level": 2,
    "type": "clause",
    "content": "and Unit Construction",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "146": {
    "node_id": "087a11e8-2f55-4de9-bf9a-2385a34edb71",
    "title": "Software Unit Verification",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "147": {
    "node_id": "91b97aea-cb02-4004-a70c-2231ae1faa2b",
    "title": "Software Integration and",
    "level": 2,
    "type": "clause",
    "content": "Integration Test",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "148": {
    "node_id": "625a5c19-3bf5-4980-b7df-6689f7d9b226",
    "title": "Software Qualification Test",
    "level": 2,
    "type": "clause",
    "content": "SYS.2.BP5: Verification criteria\nSWE.1.BP5: Verification criteria\nSWE.5.BP3: Compliance\nSYS.4.BP3: Compliance\nSWE.4.BP2: Criteria for unit verification",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "149": {
    "node_id": "e8f96e61-f3e1-478c-9ee7-a2716368b7ff",
    "title": "Verification",
    "level": 2,
    "type": "clause",
    "content": "SYS.5.BP2: Compliance\nSWE.6.BP2: Compliance\nSWE.4.BP2: Compliance\n \nFigure D.6 — Evaluation, verification criteria and compliance \nEvaluation of alternative solutions is required for system and software architectures as well as for \nsoftware detailed designs. The evaluation has to be done according to defined criteria. Such \nevaluation criteria may include quality characteristics like modularity, reliability, security, and \nusability, or results of make-or-buy or reuse analysis. The evaluation result including a rationale for \nthe architecture/design selection has to be recorded. \nCompliance with an architectural design means that the specified integration tests are capable of \nproving that interfaces and relevant interactions between \n• the software units, \n• the software items and \n• the system items \nfulfill the specification given by the architectural design. \nD.7 The relation between \"Strategy\" and \"Plan\" \nBoth terms \"Strategy\" and \"Plan\" are commonly used across following processes of the Automotive \nSPICE 3.1 PAM: \n• SYS.4   System Integration and Integration Test \n• SYS.5   System Qualification Test \n• SWE.4  Software Unit Verification \n• SWE.5  Software Integration and Integration Test \n• SWE.6  Software Qualification Test \n• SUP.1  Quality Assurance \n• SUP.8  Configuration Management \n• SUP.9  Problem Resolution Management \n• SUP.10  Change Request Management \nThe following figure shows the general relationship between strategy and plan in any of these \nprocesses. \n\n  \n \n \n \n© VDA Quality Management Center 127 \n \n \nPlan\nCL >= 2\nCL = 1\nProcess specific plan\nWP 08-nn\nGeneric plan\nWP 08-00\nBP1:\nDevelop Strategy\n \nFigure D.7— Strategy and plan \nCapability Level 1: \nEach of these processes requires the development of a process -specific strategy. The strategy \nalways corresponds to a process-specific \"Plan\". For each process-specific \"Plan\" there are process-\nspecific work product characteristics defined (e.g. \"08-52 Tes t Plan \", \"08-04 Configuration \nManagement Plan\").  \nCapability Level 2 or higher: \nEach process-specific \"Plan\" (WP 08-nn) inherits the work product characteristics represented by \nthe Generic Plan (WP 08-00). This means that for a process-specific \"Plan\" both the process-specific \ncharacteristics (WP 08-nn) and the generic characteristics (WP 08-00) apply. \n\n  \n \n \n \n© VDA Quality Management Center 128 \n \n \nAnnex E Reference standards \nAnnex E provides a list of reference standards and guidelines that support implementation of the \nAutomotive SPICE PAM / PRM. \nTable E.1 — Reference standards \nISO/IEC 33001:2015 Information technology -- Process assessment – \nConcepts and terminology \nISO/IEC 33002:2015 Information technology -- Process assessment – \nRequirements for performing process assessment \nISO/IEC 33003:2015 Information technology -- Process assessment – \nRequirements for process measurement frameworks  \nISO/IEC 33004:2015 Information technology -- Process assessment – \nRequirements for process reference, process assessment and \nmaturity models  \nISO/IEC 33020:2015 Information technology -- Process assessment – \nProcess measurement framework for assessment of process \ncapability \nISO/IEC 15504-5:2006 Information Technology – Process assessment – Part 5: An \nexemplar Process Assessment Model \nISO/IEC 12207:2008 Systems and software engineering -- Software life cycle processes \nISO/IEC/IEEE 29119-1:2013 Software and systems engineering -- Software testing -- Part 1: \nConcepts and definitions \nISO/IEC/IEEE 29119-3:2013 Software and systems engineering -- Software testing -- Part 3: \nTest documentation \nISO/IEC/IEEE 24765:2010 Systems and software engineering -- Vocabulary \nISO/IEC 25010:2011 Systems and software engineering -- Systems and software \nQuality Requirements and Evaluation (SQuaRE) -- System and \nsoftware quality models",
    "source": "..\\data\\md\\automotivespice.md"
  },
  "150": {
    "node_id": "003cdc58-6e2b-446b-b425-e1eb4cf6275c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Checking Configuration Consistency . . . . . . . . . . . . . . 39\n\n\n\n#### The Necessity for Checking Configuration Consis-\n\ntency in the ECU Manager . . . . . . . . . . . . . . . 39\n\n#### Example Hash Computation Algorithm . . . . . . . . 41\n\n\n\n### Driver Initialization . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n\n\n### BSW Initialization . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n\n\n## SHUTDOWN Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n\n\n### Activities in the OffPreOS Sequence . . . . . . . . . . . . . . 44\n\n\n\n### Activities in the OffPostOS Sequence . . . . . . . . . . . . . 45\n\n\n\n## SLEEP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n\n\n### Activities in the GoSleep Sequence . . . . . . . . . . . . . . 49\n\n\n\n### Activities in the Halt Sequence . . . . . . . . . . . . . . . . . 49\n\n\n\n### Activities in the Poll Sequence . . . . . . . . . . . . . . . . . 52\n\n\n\n### Leaving Halt or Poll . . . . . . . . . . . . . . . . . . . . . . . 54\n\n\n\n### Activities in the WakeupRestart Sequence . . . . . . . . . . 54\n\n\n\n## UP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n\n\n\n### Alarm Clock Handling . . . . . . . . . . . . . . . . . . . . . . 56\n\n\n\n### Wakeup Source State Handling . . . . . . . . . . . . . . . . 56\n\n\n\n### Internal Representation of Wakeup States . . . . . . . . . . 58\n\n\n\n### Activities in the WakeupValidation Sequence . . . . . . . . . 59\n\n\n\n#### Wakeup of Communication Channels . . . . . . . . . 61\n\n\n\n#### Interaction of Wakeup Sources and the ECU Manager 62\n\n\n\n#### Wakeup Validation Timeout . . . . . . . . . . . . . . 62\n\n\n\n#### Requirements for Drivers with Wakeup Sources . . . 63\n\n\n\n### Requirements for Wakeup Validation . . . . . . . . . . . . . . 63\n\n\n\n### Wakeup Sources and Reset Reason . . . . . . . . . . . . . . 63\n\n\n\n### Wakeup Sources with Integrated Power Control . . . . . . . 64\n\n\n\n## Shutdown Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n\n\n\n### Sleep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n\n\n\n### Reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n\n\n## Alarm Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n\n\n### Alarm Clocks and Users . . . . . . . . . . . . . . . . . . . . . 67\n\n\n\n### EcuM Clock Time . . . . . . . . . . . . . . . . . . . . . . . . 68\n\n\n\n#### EcuM Clock Time in the UP Phase . . . . . . . . . . 68\n\n\n\n#### EcuM Clock Time in the Sleep Phase . . . . . . . . 68\n\n\n\n## MultiCore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n\n\n\n### Master Core . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n\n\n### Slave Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n\n\n### Master Core - Slave Core Signalling . . . . . . . . . . . . . . 70\n\n\n\n#### BSW Level . . . . . . . . . . . . . . . . . . . . . . . 70\n\n\n\n#### Example for Shutdown Synchronization . . . . . . . 71\n\n\n\n### UP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\n\n\n### STARTUP Phase . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\n\n\n#### Master Core STARTUP . . . . . . . . . . . . . . . . 74\n\n\n\n#### Slave Core STARTUP . . . . . . . . . . . . . . . . . 76\n\n\n\n### SHUTDOWN Phase . . . . . . . . . . . . . . . . . . . . . . . 78\n\n7 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "151": {
    "node_id": "5af43cf1-0084-452d-9d72-fe0dab8429c8",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### Master Core SHUTDOWN . . . . . . . . . . . . . . . 80\n\n\n\n#### Slave Core SHUTDOWN . . . . . . . . . . . . . . . . 82\n\n\n\n### SLEEP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . 83\n\n\n\n#### Master Core SLEEP . . . . . . . . . . . . . . . . . . 84\n\n\n\n#### Slave Core SLEEP . . . . . . . . . . . . . . . . . . . 87\n\n\n\n### Runnables and Entry points . . . . . . . . . . . . . . . . . . . 91\n\n\n\n#### Internal behavior . . . . . . . . . . . . . . . . . . . . 91\n\n\n\n## EcuM Mode Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93\n\n\n\n## Advanced Topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\n\n\n\n### Relation to Bootloader . . . . . . . . . . . . . . . . . . . . . . 95\n\n\n\n### Relation to Complex Drivers . . . . . . . . . . . . . . . . . . 96\n\n\n\n### Handling Errors during Startup and Shutdown . . . . . . . . 96\n\n\n\n## ErrorHook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n\n\n\n## Error classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\n\n\n\n### Development Errors . . . . . . . . . . . . . . . . . . . . . . . 97\n\n\n\n### Runtime Errors . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\n### Transient Faults . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\n### Production Errors . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\n### Extended Production Errors . . . . . . . . . . . . . . . . . . . 98\n\n\n\n# API specification 99\n\n\n\n## Imported Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n\n\n\n## Type definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n\n\n\n### EcuM_ConfigType . . . . . . . . . . . . . . . . . . . . . . . . 100\n\n\n\n### EcuM_RunStatusType . . . . . . . . . . . . . . . . . . . . . . 101\n\n\n\n### EcuM_WakeupSourceType . . . . . . . . . . . . . . . . . . . 101\n\n\n\n### EcuM_WakeupStatusType . . . . . . . . . . . . . . . . . . . 102\n\n\n\n### EcuM_ResetType . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n\n\n### EcuM_StateType . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n\n\n## Function Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n\n\n### General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\n\n\n\n#### EcuM_GetVersionInfo . . . . . . . . . . . . . . . . . 104\n\n\n\n### Initialization and Shutdown Sequences . . . . . . . . . . . . 104\n\n\n\n#### EcuM_GoDownHaltPoll . . . . . . . . . . . . . . . . 104\n\n\n\n#### EcuM_Init . . . . . . . . . . . . . . . . . . . . . . . . 105\n\n\n\n#### EcuM_StartupTwo . . . . . . . . . . . . . . . . . . . 105\n\n\n\n#### EcuM_Shutdown . . . . . . . . . . . . . . . . . . . . 106\n\n\n\n### State Management . . . . . . . . . . . . . . . . . . . . . . . 107\n\n\n\n#### EcuM_ SetState . . . . . . . . . . . . . . . . . . . . 107\n\n\n\n#### EcuM_RequestRUN . . . . . . . . . . . . . . . . . . 107\n\n\n\n#### EcuM_ReleaseRUN . . . . . . . . . . . . . . . . . . 108\n\n\n\n#### EcuM_RequestPOST_RUN . . . . . . . . . . . . . . 109\n\n\n\n#### EcuM_ReleasePOST_RUN . . . . . . . . . . . . . . 109\n\n\n\n### Shutdown Management . . . . . . . . . . . . . . . . . . . . . 110\n\n\n\n#### EcuM_SelectShutdownTarget . . . . . . . . . . . . . 110\n\n\n\n#### EcuM_GetShutdownTarget . . . . . . . . . . . . . . 111\n\n8 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "152": {
    "node_id": "02b74264-e405-4d6e-a91c-5b85210e975b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### EcuM_GetLastShutdownTarget . . . . . . . . . . . . 112\n\n\n\n#### EcuM_SelectShutdownCause . . . . . . . . . . . . . 113\n\n\n\n#### EcuM_GetShutdownCause . . . . . . . . . . . . . . 113\n\n\n\n### Wakeup Handling . . . . . . . . . . . . . . . . . . . . . . . . 114\n\n\n\n#### EcuM_GetPendingWakeupEvents . . . . . . . . . . 114\n\n\n\n#### EcuM_ClearWakeupEvent . . . . . . . . . . . . . . . 115\n\n\n\n#### EcuM_GetValidatedWakeupEvents . . . . . . . . . . 116\n\n\n\n#### EcuM_GetExpiredWakeupEvents . . . . . . . . . . . 116\n\n\n\n### Alarm Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . 117\n\n\n\n#### EcuM_SetRelWakeupAlarm . . . . . . . . . . . . . . 117\n\n\n\n#### EcuM_SetAbsWakeupAlarm . . . . . . . . . . . . . . 118\n\n\n\n#### EcuM_AbortWakeupAlarm . . . . . . . . . . . . . . . 118\n\n\n\n#### EcuM_GetCurrentTime . . . . . . . . . . . . . . . . 119\n\n\n\n#### EcuM_GetWakeupTime . . . . . . . . . . . . . . . . 119\n\n\n\n#### EcuM_SetClock . . . . . . . . . . . . . . . . . . . . . 120\n\n\n\n### Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n\n\n\n#### EcuM_SelectBootTarget . . . . . . . . . . . . . . . . 121\n\n\n\n#### EcuM_GetBootTarget . . . . . . . . . . . . . . . . . 121\n\n\n\n## Callback Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\n\n\n### Callbacks from Wakeup Sources . . . . . . . . . . . . . . . . 122\n\n\n\n#### EcuM_CheckWakeup . . . . . . . . . . . . . . . . . 122\n\n\n\n#### EcuM_SetWakeupEvent . . . . . . . . . . . . . . . . 122\n\n\n\n#### EcuM_ValidateWakeupEvent . . . . . . . . . . . . . 123\n\n\n\n## Callout Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\n\n\n\n### Generic Callouts . . . . . . . . . . . . . . . . . . . . . . . . . 124\n\n\n\n#### EcuM_ErrorHook . . . . . . . . . . . . . . . . . . . . 124\n\n\n\n### Callouts from the STARTUP Phase . . . . . . . . . . . . . . 125\n\n\n\n#### EcuM_AL_SetProgrammableInterrupts . . . . . . . . 125\n\n\n\n#### EcuM_AL_DriverInitZero . . . . . . . . . . . . . . . . 126\n\n\n\n#### EcuM_DeterminePbConfiguration . . . . . . . . . . . 126\n\n\n\n#### EcuM_AL_DriverInitOne . . . . . . . . . . . . . . . . 127\n\n\n\n#### EcuM_LoopDetection . . . . . . . . . . . . . . . . . 128\n\n\n\n### Callouts from the SHUTDOWN Phase . . . . . . . . . . . . . 128\n\n\n\n#### EcuM_OnGoOffOne . . . . . . . . . . . . . . . . . . 128\n\n\n\n#### EcuM_OnGoOffTwo . . . . . . . . . . . . . . . . . . 129\n\n\n\n#### EcuM_AL_SwitchOff . . . . . . . . . . . . . . . . . . 129\n\n\n\n#### EcuM_AL_Reset . . . . . . . . . . . . . . . . . . . . 130\n\n\n\n### Callouts from the SLEEP Phase . . . . . . . . . . . . . . . . 131\n\n\n\n#### EcuM_EnableWakeupSources . . . . . . . . . . . . 131\n\n\n\n#### EcuM_GenerateRamHash . . . . . . . . . . . . . . . 131\n\n\n\n#### EcuM_SleepActivity . . . . . . . . . . . . . . . . . . 132\n\n\n\n#### EcuM_StartCheckWakeup . . . . . . . . . . . . . . . 133\n\n\n\n#### EcuM_CheckWakeup . . . . . . . . . . . . . . . . . 133\n\n\n\n#### EcuM_EndCheckWakeup . . . . . . . . . . . . . . . 134\n\n\n\n#### EcuM_CheckRamHash . . . . . . . . . . . . . . . . 135\n\n\n\n#### EcuM_DisableWakeupSources . . . . . . . . . . . . 135\n\n9 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "153": {
    "node_id": "4d3caba7-b5fd-4aa3-b989-da8d5f681708",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### EcuM_AL_DriverRestart . . . . . . . . . . . . . . . . 136\n\n\n\n### Callouts from the UP Phase . . . . . . . . . . . . . . . . . . 137\n\n\n\n#### EcuM_StartWakeupSources . . . . . . . . . . . . . . 137\n\n\n\n#### EcuM_CheckValidation . . . . . . . . . . . . . . . . . 137\n\n\n\n#### EcuM_StopWakeupSources . . . . . . . . . . . . . . 138\n\n\n\n## Scheduled Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n\n\n\n### EcuM_MainFunction . . . . . . . . . . . . . . . . . . . . . . . 139\n\n\n\n## Expected Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n\n\n\n### Optional Interfaces . . . . . . . . . . . . . . . . . . . . . . . . 140\n\n\n\n### Configurable interfaces . . . . . . . . . . . . . . . . . . . . . 141\n\n\n\n#### Callbacks from the STARTUP phase . . . . . . . . . 141\n\n\n\n## Specification of the Port Interfaces . . . . . . . . . . . . . . . . . . . . 142\n\n\n\n### Ports and Port Interface for EcuM_ShutdownTarget Interface 142\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 142\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 142\n\n\n\n### Port Interface for EcuM_BootTarget Interface . . . . . . . . . 145\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 145\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 145\n\n\n\n### Port Interface for EcuM_AlarmClock Interface . . . . . . . . 146\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 146\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 146\n\n\n\n### Port Interface for EcuM_Time Interface . . . . . . . . . . . . 147\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 147\n\n\n\n#### Data Types . . . . . . . . . . . . . . . . . . . . . . . 147\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 147\n\n\n\n### Port Interface for EcuM_StateRequest Interface . . . . . . . 148\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 149\n\n\n\n#### Data Types . . . . . . . . . . . . . . . . . . . . . . . 149\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 149\n\n\n\n### Port Interface for EcuM_CurrentMode Interface . . . . . . . . 150\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 150\n\n\n\n#### Data Types . . . . . . . . . . . . . . . . . . . . . . . 151\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 151\n\n\n\n### Definition of the ECU Manager Service . . . . . . . . . . . . 151\n\n\n\n## API Parameter Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 156\n\n\n\n# Sequence Charts 157\n\n\n\n## State Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n\n\n\n## Wakeup Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n\n\n\n### GPT Wakeup Sequences . . . . . . . . . . . . . . . . . . . . 157\n\n\n\n### ICU Wakeup Sequences . . . . . . . . . . . . . . . . . . . . 160\n\n\n\n### CAN Wakeup Sequences . . . . . . . . . . . . . . . . . . . . 162\n\n\n\n### LIN Wakeup Sequences . . . . . . . . . . . . . . . . . . . . . 169\n\n\n\n### FlexRay Wakeup Sequences . . . . . . . . . . . . . . . . . . 173\n\n\n\n# Configuration specification 176\n\n\n\n## Common Containers and configuration parameters . . . . . . . . . . . 176\n\n10 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "154": {
    "node_id": "b2f365ba-d06e-4c6d-adb3-1fc9555069cc",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\n\n\n\n### EcuMGeneral . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n\n\n\n### EcuMConfiguration . . . . . . . . . . . . . . . . . . . . . . . 180\n\n\n\n### EcuMCommonConfiguration . . . . . . . . . . . . . . . . . . 181\n\n\n\n### EcuMDefaultShutdownTarget . . . . . . . . . . . . . . . . . . 183\n\n\n\n### EcuMDriverInitListOne . . . . . . . . . . . . . . . . . . . . . 185\n\n\n\n### EcuMDriverInitListZero . . . . . . . . . . . . . . . . . . . . . 186\n\n\n\n### EcuMDriverRestartList . . . . . . . . . . . . . . . . . . . . . 186\n\n\n\n### EcuMDriverInitItem . . . . . . . . . . . . . . . . . . . . . . . 187\n\n\n\n### EcuMSleepMode . . . . . . . . . . . . . . . . . . . . . . . . . 190\n\n\n\n### EcuMWakeupSource . . . . . . . . . . . . . . . . . . . . . . 192\n\n\n\n## EcuM-Flex Containers and configuration parameters . . . . . . . . . . 196\n\n\n\n### EcuMFlexGeneral . . . . . . . . . . . . . . . . . . . . . . . . 196\n\n\n\n### EcuMFlexConfiguration . . . . . . . . . . . . . . . . . . . . . 200\n\n\n\n### EcuMAlarmClock . . . . . . . . . . . . . . . . . . . . . . . . 202\n\n\n\n### EcuMDriverInitListBswM . . . . . . . . . . . . . . . . . . . . 204\n\n\n\n### EcuMGoDownAllowedUsers . . . . . . . . . . . . . . . . . . 206\n\n\n\n### EcuMResetMode . . . . . . . . . . . . . . . . . . . . . . . . 206\n\n\n\n### EcuMSetClockAllowedUsers . . . . . . . . . . . . . . . . . . 207\n\n\n\n## Published Information . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\n\nA Not applicable requirements 210\n11 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "155": {
    "node_id": "e1b2b050-0af5-4580-8c5a-fc4164c49fe8",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Known Limitations\n•The ECU Manager module interfaces must be specified as reentrant in the Multi-\nCore context.\n12 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "156": {
    "node_id": "7eb807a6-55d6-48fb-8668-a78021d83d62",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Introduction and Functional Overview\n\nThe ECU Manager module (as specified in this document) is a basic software module\n(see [1]) that manages common aspects of ECU states. Specifically, the ECU Manager\nmodule:\n•Initializes and de-initializes the OS, the SchM and the BswM as well as some\nbasic software driver modules.\n•configures the ECU for SLEEP and SHUTDOWN when requested.\n•manages all wakeup events on the ECU\nThe ECU Manager module provides the wakeup validation protocol to distinguish ’real’\nwakeup events from ’erratic’ ones.\nFurthermore:\n•Partial or fast startup where he ECU starts up with limited capabilities and later,\nas determined by the application, continues startup step by step.\n•Interleaved startup where the ECU starts minimally and then starts the RTE to\nexecute functionality in SW-Cs as soon as possible. It then continues to start\nfurther BSW and SW-Cs, thus interleaving BSW and application functionality..\n•Multiple operational states where the ECU has more than one RUN state. This,\namong other things, refines the notion of a spectrum of SLEEP states to RUN\nstates. There can now be a continuum of operational states spanning from the\nclassic RUN (fully operational) to the deepest SLEEP (processor halted).\n•Multi-Core ECUs: STARTUP , SHUTDOWN, SLEEP and WAKEUP are coordi-\nnated on all cores of the ECU.\nFlexible ECU management employs the generic mode management facilities provided\nby the following modules:\n•RTE and BSW Scheduler module [2] are now amalgamated into one module:\nThis module supports freely configurable BSW and application modes and their\nmode-switching facilities.\n•BSW Mode Manager module [3]: This module implements configurable rules and\naction lists to evaluate the conditions for switching ECU modes and to implement\nthe necessary actions to do so.\nThus with Flexible ECU Management, most ECU states are no longer implemented\nin the ECU Manager module itself. In general, the ECU Manager module takes over\ncontrol when the generic mode management facilities are unavailable in:\n•Early STARTUP phases,\n•Late SHUTDOWN phases,\n•SLEEP phases where the facilities are locked out by the scheduler.\n13 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "157": {
    "node_id": "6373275e-66ef-40c8-8971-a5d795132d20",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "During the UP Phase of the ECU Manager module the BSW Mode Manager is re-\nsponsible for further actions. Whereas, the ECU Manager module arbitrates RUN and\nPOST_RUN Requests from SW-Cs and notifies BswM about the status of the modes.\n\n## Backwards Compatibility to Previous ECU Manager Module\n\nVersions\nFlexible ECU management is backward compatible to previous ECU Manager versions\nif it is configured accordingly.\nFor more information about a configuration in respect to compatibility see the \"Guide\nto Mode Management\" [4].\n14 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "158": {
    "node_id": "847d548e-d7d1-49c2-9b85-16fab9ee8c05",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Definitions and Abbreviations\n\nThis chapter defines terms that are of special significance to the ECU Manager and\nthe acronyms of related modules.\n\n## Definitions\n\nTerm Description\nCallback Refer to the Glossary [5]\nCallout\n’Callouts’ are function stubs that the system designer can replace\nwith code, usually at configuration time, to add functionality to the\nECU Manager module. Callouts are separated into two classes.\nOne class provides mandatory ECU Manager module functional-\nity and serves as a hardware abstraction layer. The other class\nprovides optional functionality.\nIntegration Code Refer to the Glossary [5]\nMode\nA Mode is a certain set of states of the various state machines\n(not only of the ECU Manager) that are running in the vehicle\nand are relevant to a particular entity, an application or the whole\nvehicle\nPassive Wakeup A wakeup caused from an attached bus rather than an internal\nevent like a timer or sensor activity.\nPhase\nA logical or temporal assembly of ECU Manager’s actions and\nevents, e.g. STARTUP , UP , SHUTDOWN, SLEEP , ... Phases\ncan consist of Sub-Phases which are often called Sequences if\nthey above all exist to group sequences of executed actions into\nlogical units. Phases in this context are not the phases of the\nAUTOSAR Methodology.\nShutdown Target\nThe ECU must be shut down before it is put to sleep, before it is\npowered off or before it is reset. SLEEP , OFF , and RESET are\ntherefore valid shutdown targets. By selecting a shutdown target,\nan application can communicate its wishes for the ECU behavior\nafter the next shutdown to the ECU Manager module.\nState\nStates are internal to their respective BSW component and thus\nnot visible to the application. So they are only used by the BSW’s\ninternal state machine. The States inside the ECU Manager build\nthe phases and therefore handle the modes.\nWakeup Event\nA physical event which causes a wakeup. A CAN message or a\ntoggling IO line can be wakeup events. Similarly, the internal SW\nrepresentation, e.g. an interrupt, may also be called a wakeup\nevent.\nWakeup Reason The wakeup reason is the wakeup event that is the actual cause\nof the last wakeup.\nWakeup Source\nThe peripheral or ECU component which deals with wakeup\nevents is called a wakeup source.\n\n## Abbreviations\n\n15 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "159": {
    "node_id": "2b2bb40c-7e8a-4f8b-841f-9f626205a6ff",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Abbreviation Description\nBswM Basic Software Mode Manager\nDem Diagnostic Event Manager\nDet Default Error Tracer\nEcuM ECU Manager\nGpt General Purpose Timer\nIcu Input Capture Unit\nISR Interrupt Service Routine\nMcu Microcontroller Unit\nNVRAM Non-volatile random access memory\nOs Operating System\nRte Runtime Environment\nVFB Virtual Function Bus\n16 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "160": {
    "node_id": "1729dc4a-e271-4e3b-8119-485111eda732",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Related documentation\n\n\n\n## Input documents & related standards and norms\n\n[1] List of Basic Software Modules\nAUTOSAR_TR_BSWModuleList\n[2] Specification of RTE Software\nAUTOSAR_SWS_RTE\n[3] Specification of Basic Software Mode Manager\nAUTOSAR_SWS_BSWModeManager\n[4] Guide to Mode Management\nAUTOSAR_EXP_ModeManagementGuide\n[5] Glossary\nAUTOSAR_TR_Glossary\n[6] General Specification of Basic Software Modules\nAUTOSAR_SWS_BSWGeneral\n[7] Virtual Functional Bus\nAUTOSAR_EXP_VFB\n[8] General Requirements on Basic Software Modules\nAUTOSAR_SRS_BSWGeneral\n[9] Requirements on Mode Management\nAUTOSAR_SRS_ModeManagement\n[10] Specification of MCU Driver\nAUTOSAR_SWS_MCUDriver\n[11] Specification of CAN Transceiver Driver\nAUTOSAR_SWS_CANTransceiverDriver\n\n## Related specification\n\nAUTOSAR provides a General Specification on Basic Software modules (see [6]),\nwhich is also valid for ECU State Manager. Thus, the specification [6] shall be con-\nsidered as additional and required specification for ECU State Manager.\n17 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "161": {
    "node_id": "e61d4abd-86f5-486b-a973-4f1a58156217",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Constraints and Assumptions\n\n\n\n## Limitations\n\nECUs cannot always be switched off (i.e. zero power consumption).\nRationale: The shutdown target OFF can only be reached using ECU special hardware\n(e.g. a power hold circuit). If this hardware is not available, this specification proposes\nto issue a reset instead. Other default behaviors are permissible, however.\n\n## Hardware Requirements\n\nIn this section, the term \"EcuM RAM\" refers to a block of RAM reserved for use by the\nECU Manager module.\nThe EcuM RAM shall keep contents of vital data while the ECU clock is switched off.\nRationale: This requirement is needed to implement sleep states as required in section\n\n## SLEEP Phase.\n\nThe EcuM RAM shall provide a no-init area that keeps contents over a reset cycle.\nThe no-init area of the EcuM RAM (see EcuM2869) shall only be initialized on a power\non event (clamp 30).\nThe system designer is responsible for establishing an initialization strategy for the no\ninit area of the ECU RAM.\n\n## Applicability to car domains\n\nThe ECU Manager module is applicable to all car domains.\n18 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "162": {
    "node_id": "4e888350-1d27-4830-bb97-16ca33a9b376",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Dependencies to other modules\n\nThe following sections outline the important relationships to other modules. They also\ncontain some requirements that these modules must fulfill to collaborate correctly with\nthe ECU Manager module.\nIf data pointers are passed to a BSW module, the address needs to point to a location\nin the shared part of the memory space.\n\n## SPAL Modules\n\n\n\n### MCU Driver\n\nThe MCU Driver is the first basic software module initialized by the ECU Manager\nmodule. When MCU_Init returns (see [SWS_EcuM_02858]), the MCU module and\nthe MCU Driver module are not necessarily fully initialized, however. Additional MCU\nmodule specific steps may be needed to complete the initialization. The ECU Manager\nmodule provides two callout where this additional code can be placed. Refer to section\n\n### Activities in StartPreOS Sequence for details.\n\n\n\n### Driver Dependencies and Initialization Order\n\nBSW drivers may depend on each other. A typical example is the watchdog driver,\nwhich needs the SPI driver to access an external watchdog. This means on the one\nhand, that drivers may be stacked (not relevant to the ECU Manager module) and on\nthe other hand that the called module must be initialized before the calling module is\ninitialized.\nThe system designer is responsible for defining the initialization order at configuration\ntime in EcuMDriverInitListZero, EcuMDriverInitListOne, EcuMDriver-\nRestartList and inEcuMDriverInitListBswM.\n\n## Peripherals with Wakeup Capability\n\nWakeup sources must be handled and encapsulated by drivers.\nThese drivers must follow the protocols and requirements presented in this document\nto ensure a seamless integration into the AUTOSAR BSW. Basically, the protocol is as\nfollows:\nThe driver must invoke EcuM_SetWakeupEvent (see [SWS_EcuM_02826]) to notify\nthe ECU Manager module that a pending wakeup event has been detected. The driver\nmust not only invoke EcuM_SetWakeupEvent while the ECU is waiting for a wakeup\n19 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "163": {
    "node_id": "ef6dd53d-0dc6-4309-875b-ff782a19a819",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "event during a sleep phase but also during the driver initialization phase and during\nnormal operation when EcuM_MainFunction is running.\nThe driver must provide an explicit function to put the wakeup source to sleep. This\nfunction shall put the wakeup source into an energy saving and inert operation mode\nand rearm the wakeup notification mechanism.\nIf the wakeup source is capable of generating spurious events1 then either\n•the driver or\n•the software stack consuming the driver or\n•another appropriate BSW module\nmust either provide a validation callout for the wakeup event or call the ECU Manager\nmodule’s validation function. If validation is not necessary, then this requirement is not\napplicable for the corresponding wakeup source.\n\n## Operating System\n\nThe ECU Manager module starts the AUTOSAR OS and also shuts it down. The ECU\nManager module defines the protocol how control is handled before the OS is started\nand how control is handled after the OS has been shut down.\n\n## BSW Scheduler\n\nThe ECU Manager module initializes the BSW Scheduler and the ECU Manager mod-\nule also contains EcuM_MainFunction (see [SWS_EcuM_02837]) which is scheduled\nto periodically evaluate wakeup requests and update the Alarm Clock.\n\n## BSW Mode Manager\n\nECU states are generally implemented as AUTOSAR modes and the BSW Mode Man-\nager is responsible for monitoring changes in the ECU and affecting the corresponding\nchanges to the ECU state machine as appropriate. Refer to the Specification of the\nVirtual Function Bus [7] for a discussion of AUTOSAR mode management and to the\nGuide to Mode Management [4] for ECU state machine implementation details and\nfor guidelines about how to configure the BSW Mode Manager to implement the ECU\nstate machine\nThe BSW Mode Manager can only manage the ECU state machine after mode man-\nagement is operational - that is, after the SchM has been initialized and until the SchM\n1Spurious wakeup events may result from EMV spikes, bouncing effects on wakeup lines etc.\n20 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "164": {
    "node_id": "630a84ea-e4fa-4b55-b478-309fc36b01e9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "is de-initialised or halted. The ECU Manager module takes control of the ECU when\nthe BSW Mode manager is not operational.\nThe ECU Manager module therefore takes control immediately after the ECU has\nbooted and relegates control to the BSW Mode Manager after initializing the SchM\nand the BswM.\nThe BswM passes control of the ECU back to the ECU Manager module to lock the\noperating system and handle wakeup events.\nThe BswM also passes control back to the ECU Manager immediately before the OS\nis stopped on shutdown.\nWhen wakeup sources are being validated, the ECU Manager module indicates\nwakeup source state changes to the BswM through mode switch requests.\n\n## Software Components\n\nThe ECU Manager module handles the following ECU-wide properties:\n•Shutdown targets.\nThis specification assumes that SW-Cs set these properties (through AUTOSAR ports),\ntypically by some ECU specific part of the SW-C. The ECU Manager does not prevent\na SW-C from overrighting settings made by SW-Cs. The policy must be defined at a\nhigher level.\nThe following measures might help to resolve this issue.\n•The SW-C Template may contain a field to indicate whether the SW-C sets the\nshutdown target.\n•The generation tool may only allow configurations that have one SW-C accessing\nthe shutdown target.\n\n## File Structure\n\n\n\n### Code file structure\n\nThis specification does not define the code file structure completely.\n[SWS_EcuM_02990] ⌈The ECU Manager module implementation shall provide a sin-\ngle EcuM_Callout_Stubs.c file which contains the stubs of the callouts realized in\nthis implementation.⌋()\nSee also section 8.5 Callout Definitions for a list of the callouts that could possibly be\nimplemented.\n21 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "165": {
    "node_id": "779ca325-8d0c-4e1f-93ed-156383549efe",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Whether EcuM_Callout_Stubs.c can be edited manually or is composed only of\nother generated files depends on the implementation.\n\n### Header file structure\n\nAlso refer to chapter 8.7 Expected Interfaces for dependencies to other modules.\n22 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "166": {
    "node_id": "b060cad4-35d8-4715-96cd-ba11195ed1af",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Requirements Tracing\n\nThe following tables reference the requirements specified in [8] and [9] and links to the\nfulfillment of these. Please note that if column \"Satisfied by\" is empty for a specific\nrequirement this means that this requirement is not fulfilled by this document.\nRequirement Description Satisfied by\n[SRS_BSW_00005] Modules of theµC Abstraction Layer\n(MCAL) may not have hard coded\nhorizontal interfaces\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00010] The memory consumption of all Basic\nSW Modules shall be documented for\na defined configuration for all\nsupported platforms.\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00101] The Basic Software Module shall be\nable to initialize variables and\nhardware in a separate initialization\nfunction\n[SWS_EcuM_02811]\n[SRS_BSW_00159] All modules of the AUTOSAR Basic\nSoftware shall support a tool based\nconfiguration\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00160] Configuration files of AUTOSAR\nBasic SW module shall be readable\nfor human beings\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00161] The AUTOSAR Basic Software shall\nprovide a microcontroller abstraction\nlayer which provides a standardized\ninterface to higher software layers\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00162] The AUTOSAR Basic Software shall\nprovide a hardware abstraction layer\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00164] The Implementation of interrupt\nservice routines shall be done by the\nOperating System, complex drivers or\nmodules\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00167] All AUTOSAR Basic Software\nModules shall provide configuration\nrules and constraints to enable\nplausibility checks\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00168] SW components shall be tested by a\nfunction defined in a common API in\nthe Basis-SW\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00172] The scheduling strategy that is built\ninside the Basic Software Modules\nshall be compatible with the strategy\nused in the system\n[SWS_EcuM_02836]\n[SRS_BSW_00307] Global variables naming convention [SWS_EcuM_NA_00000]\n[SRS_BSW_00308] AUTOSAR Basic Software Modules\nshall not define global data in their\nheader files, but in the C file\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00309] All AUTOSAR Basic Software\nModules shall indicate all global data\nwith read-only purposes by explicitly\nassigning the const keyword\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00314] All internal driver modules shall\nseparate the interrupt frame definition\nfrom the service routine\n[SWS_EcuM_NA_00000]\n▽\n23 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "167": {
    "node_id": "733bf0cc-9ca8-421b-9dd4-ec7e289c7d1c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nRequirement Description Satisfied by\n[SRS_BSW_00323] All AUTOSAR Basic Software\nModules shall check passed API\nparameters for validity\n[SWS_EcuM_03009]\n[SRS_BSW_00325] The runtime of interrupt service\nroutines and functions that are\nrunning in interrupt context shall be\nkept short\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00327] Error values naming convention [SWS_EcuM_04032]\n[SRS_BSW_00330] It shall be allowed to use macros\ninstead of functions where source\ncode is used and runtime is critical\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00331] All Basic Software Modules shall\nstrictly separate error and status\ninformation\n[SWS_EcuM_91005]\n[SRS_BSW_00333] For each callback function it shall be\nspecified if it is called from interrupt\ncontext or not\n[SWS_EcuM_02171] [SWS_EcuM_02345]\n[SRS_BSW_00334] All Basic Software Modules shall\nprovide an XML file that contains the\nmeta data\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00337] Classification of development errors [SWS_EcuM_04032]\n[SRS_BSW_00339] Reporting of production relevant error\nstatus\n[SWS_EcuM_02987]\n[SRS_BSW_00341] Module documentation shall contains\nall needed informations\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00347] A Naming seperation of different\ninstances of BSW drivers shall be in\nplace\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00348] All AUTOSAR standard types and\nconstants shall be placed and\norganized in a standard type header\nfile\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00350] All AUTOSAR Basic Software\nModules shall allow the enabling/\ndisabling of detection and reporting of\ndevelopment errors.\n[SWS_EcuM_04032]\n[SRS_BSW_00353] All integer type definitions of target\nand compiler specific scope shall be\nplaced and organized in a single type\nheader\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00358] The return type of init() functions\nimplemented by AUTOSAR Basic\nSoftware Modules shall be void\n[SWS_EcuM_02811]\n[SRS_BSW_00359] All AUTOSAR Basic Software\nModules callback functions shall\navoid return types other than void if\npossible\n[SWS_EcuM_02826] [SWS_EcuM_02829]\n[SRS_BSW_00360] AUTOSAR Basic Software Modules\ncallback functions are allowed to\nhave parameters\n[SWS_EcuM_02826] [SWS_EcuM_02829]\n[SRS_BSW_00361] All mappings of not standardized\nkeywords of compiler specific scope\nshall be placed and organized in a\ncompiler specific type and keyword\nheader\n[SWS_EcuM_NA_00000]\n▽\n24 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "168": {
    "node_id": "729a933e-b52d-47d6-b3b1-f0c8fac73043",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nRequirement Description Satisfied by\n[SRS_BSW_00373] The main processing function of each\nAUTOSAR Basic Software Module\nshall be named according the defined\nconvention\n[SWS_EcuM_02837]\n[SRS_BSW_00385] List possible error notifications [SWS_EcuM_04032]\n[SRS_BSW_00406] A static status variable denoting if a\nBSW module is initialized shall be\ninitialized with value 0 before any\nAPIs of the BSW module is called\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00407] Each BSW module shall provide a\nfunction to read out the version\ninformation of a dedicated module\nimplementation\n[SWS_EcuM_02813]\n[SRS_BSW_00410] Compiler switches shall have defined\nvalues\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00411] All AUTOSAR Basic Software\nModules shall apply a naming rule for\nenabling/disabling the existence of\nthe API\n[SWS_EcuM_02813]\n[SRS_BSW_00413] An index-based accessing of the\ninstances of BSW modules shall be\ndone\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00414] Init functions shall have a pointer to a\nconfiguration structure as single\nparameter\n[SWS_EcuM_02811]\n[SRS_BSW_00415] Interfaces which are provided\nexclusively for one module shall be\nseparated into a dedicated header file\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00416] The sequence of modules to be\ninitialized shall be configurable\n[SWS_EcuM_02559]\n[SRS_BSW_00417] Software which is not part of the\nSW-C shall report error events only\nafter the DEM is fully operational.\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00422] Pre-de-bouncing of error status\ninformation is done within the DEM\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00425] The BSW module description\ntemplate shall provide means to\nmodel the defined trigger conditions\nof schedulable objects\n[SWS_EcuM_02837]\n[SRS_BSW_00426] BSW Modules shall ensure data\nconsistency of data which is shared\nbetween BSW modules\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00427] ISR functions shall be defined and\ndocumented in the BSW module\ndescription template\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00432] Modules should have separate main\nprocessing functions for read/receive\nand write/transmit data path\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00437] Memory mapping shall provide the\npossibility to define RAM segments\nwhich are not to be initialized during\nstartup\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00439] Enable BSW modules to handle\ninterrupts\n[SWS_EcuM_NA_00000]\n▽\n25 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "169": {
    "node_id": "f4cdc18d-2f54-4ca5-aa96-e718ab6548ae",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nRequirement Description Satisfied by\n[SRS_BSW_00440] The callback function invocation by\nthe BSW module shall follow the\nsignature provided by RTE to invoke\nservers via Rte_Call API\n[SWS_EcuM_02826] [SWS_EcuM_02829]\n[SRS_BSW_00449] BSW Service APIs used by Autosar\nApplication Software shall return a\nStd_ReturnType\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00450] A Main function of a un-initialized\nmodule shall return immediately\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00453] BSW Modules shall be harmonized [SWS_EcuM_NA_00000]\n[SRS_ModeMgm_-\n09072]\nECU shutdown shall be forced [SWS_EcuM_03022]\n[SRS_ModeMgm_-\n09098]\nStoring the wake-up reasons shall be\navailable\n[SWS_EcuM_02826]\n[SRS_ModeMgm_-\n09100]\nSelection of wake-up sources shall\nbe configurable\n[SWS_EcuM_02389]\n[SRS_ModeMgm_-\n09104]\nECU State Manager shall take over\ncontrol after OS shutdown\n[SWS_EcuM_02952] [SWS_EcuM_02953]\n[SRS_ModeMgm_-\n09113]\nInitialization of Basic Software\nmodules shall be done\n[SWS_EcuM_02932]\n[SRS_ModeMgm_-\n09114]\nStarting/invoking the shutdown\nprocess shall be provided\n[SWS_EcuM_00624] [SWS_EcuM_02185]\n[SWS_EcuM_02585] [SWS_EcuM_02812]\n[SWS_EcuM_02822]\n[SRS_ModeMgm_-\n09116]\nRequesting and releasing the RUN\nstate shall be provided\n[SWS_EcuM_04115] [SWS_EcuM_04116]\n[SWS_EcuM_04117] [SWS_EcuM_04118]\n[SWS_EcuM_04119] [SWS_EcuM_04120]\n[SWS_EcuM_04121] [SWS_EcuM_04123]\n[SWS_EcuM_04125] [SWS_EcuM_04126]\n[SWS_EcuM_04127] [SWS_EcuM_04128]\n[SWS_EcuM_04129] [SWS_EcuM_04130]\n[SWS_EcuM_04132]\n[SRS_ModeMgm_-\n09126]\nAn API for querying the wake-up\nreason shall be provided\n[SWS_EcuM_02827] [SWS_EcuM_02828]\n[SWS_EcuM_02830] [SWS_EcuM_02831]\n[SRS_ModeMgm_-\n09127]\nThe ECU State Manager shall\nde-initialize Basic Software modules\nwhere appropriate during the\nshutdown process\n[SWS_EcuM_03021]\n[SRS_ModeMgm_-\n09128]\nSeveral shutdown targets shall be\nsupported\n[SWS_EcuM_02822] [SWS_EcuM_02824]\n[SWS_EcuM_02825]\n[SRS_ModeMgm_-\n09136]\nThe ECU State Manager shall be the\nreceiver of all wake-up events\n[SWS_EcuM_04091]\n[SRS_ModeMgm_-\n09186]\nAlarm Clock shall be active while the\nECU is powered\n[SWS_EcuM_04054] [SWS_EcuM_04055]\n[SWS_EcuM_04056] [SWS_EcuM_04057]\n[SWS_EcuM_04058] [SWS_EcuM_04059]\n[SWS_EcuM_04060]\n[SRS_ModeMgm_-\n09187]\nIn Case of wakeup, all the alarm\nclock shall be canceled\n[SWS_EcuM_04009]\n[SRS_ModeMgm_-\n09188]\nIn Case of startup, all the alarm clock\nshall be canceled\n[SWS_EcuM_04010]\n[SRS_ModeMgm_-\n09190]\nThe alarm clock service shall allow\nsetting an alarm relative to the\ncurrent time using a time resolution of\nseconds\n[SWS_EcuM_04054]\n▽\n26 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "170": {
    "node_id": "6d43b87d-b9eb-420b-9e39-4408a0dbfb3d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nRequirement Description Satisfied by\n[SRS_ModeMgm_-\n09194]\nThe alarm clock service shall allow\nsetting the clock\n[SWS_EcuM_04064]\n[SRS_ModeMgm_-\n09199]\nThe alarm clock service shall allow\nsetting an alarm absolute by using an\nabsolute time with a resolution of\nseconds\n[SWS_EcuM_04057]\n[SRS_ModeMgm_-\n09234]\nThe EcuM shall handle the\ninitialization of Basic Software\nmodules\n[SWS_EcuM_02559] [SWS_EcuM_02730]\n[SWS_EcuM_02947]\n[SRS_ModeMgm_-\n09235]\nThe ECU State Manager shall offer\ntwo targets for shutting down the ECU\n[SWS_EcuM_00624] [SWS_EcuM_02156]\n[SWS_EcuM_02822] [SWS_EcuM_02824]\n[SWS_EcuM_02825]\n[SRS_ModeMgm_-\n09239]\nTo shutdown, ShutdownAllCores shall\nbe called on the master core after\nsynchronizing all cores\n[SWS_EcuM_04024]\nTable 6.1: RequirementsTracing\n27 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "171": {
    "node_id": "af15daf6-c847-4684-bbbe-0714d4c57142",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Functional Specification\n\nChapter 1 introduced the new, more flexible approach to ECU state management.\nHowever, this flexibility comes at the price of responsibility. There are no standard ECU\nmodes, or states. The integrator of an ECU must decide which states are needed and\nalso configure them.\nWhen ECU Mode Handling is used, the standard states RUN and POST_RUN are\narbitrated by the RUN Request Protocol and propagated to the BswM. The system\ndesigner has to make sure that pre-conditions of respective states are met when setting\nan EcuM Mode by BswM actions.\nNote that neither the BSW nor SW-Cs will be able to rely on certain ECU modes or\nstates, although previous versions of the BSW have largely not relied on them..\nThis document only specifies the functionality that remains in the ECU Manager mod-\nule. For a complete picture of ECU State Management, refer to the specifications of\nthe other relevant modules, i.e., RTE and BSW Scheduler module [2] and BSW Mode\nManager module [3].\nRefer to the Guide to Mode Management [4] for some example use cases for ECU\nstates and the interaction between the involved BSW modules.\nThe ECU Manager module manages the state of wakeup sources in the same way as\nit has in the past. The APIs to set/clear/validate wakeup events remain the same - with\nthe notable difference that these APIs are Callbacks.\nIt was always intended that wakeup source handling take place not only during wakeup\nbut continuously, in parallel to all other EcuM activities. This functionality is now fully\ndecoupled from the rest of ECU management via mode requests.\n\n## Phases of the ECU Manager Module\n\nPrevious versions of the ECU Manager Module specification have differentiated be-\ntween ECU states and ECU modes.\nECU modes were longer-lasting periods of operational ECU activities that were visible\nto applications and provided orientation to them, i.e. starting up, shutting down, going\nto sleep and waking up.\nThe ECU Manager states were generally continuous sequences of ECU Manager Mod-\nule operations terminated by waiting until external conditions were fulfilled. Startup1,\nfor example, contained all BSW initialization before the OS was started and terminated\nwhen the OS returned control to the ECU Manager module.\nFor the current Flexible ECU Manager there existStates, Modes and Phases which\nare defined in Definitions and Acronyms.\n28 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "172": {
    "node_id": "921a0dc9-24aa-40bd-b32e-fddd054d367b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Here the ECU state machine is implemented as general modes under the control of\nthe BSW Mode Manager module. This creates a terminology problem as the old ECU\nStates now becomeModes that are visible through the RTE_Mode port interface and\nthe old ECUModes become Phases.\nBecause Modes as defined by the VFB and used in the RTE are only available in the\nUP phase (where the ECU Manager is passive) the change of terminology fromModes\nto Phases got necessary.\nFigure 7.1 shows an overview over the phases of the Flexible ECU Manager module.\nThe STARTUP phase lasts until the mode management facilities are running. Basically\nthe STARTUP phase consists of the minimal activities needed to start mode manage-\nment: initializing low-level drivers, starting the OS and initializing the BSW Scheduler\nand the BSW Mode Manager modules. Similarly the SHUTDOWN phase is the reverse\nof the STARTUP phase is where mode management is de-initialized.\nThe UP phase consists of all states that are not highlighted. During that phase, the\nECU goes fromState to State and fromMode to Mode, as dictated by the Integrator-\ndefined state machine.\nThe UP phase contains default Modes in case ECU Mode Handling is used. The tran-\nsition between these Modes is done by cooperation between the ECU State Manager\nmodule and the BSW Mode Manager module.\nNote that the UP phase contains some former sleep states. The mode management\nfacilities do not operate from the point where the OS Scheduler has been locked to pre-\nvent other tasks from running in sleep to the point where the MCU mode that puts the\nECU to sleep has been exited. The ECU Manager module provides wakeup handling\nsupport at this time.\n29 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "173": {
    "node_id": "7341abc6-03e1-4142-91e4-909f25f31cbe",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "174": {
    "node_id": "4f737d8c-6ca7-4b35-ac23-5fe523eb7567",
    "title": "SHUTDOWN",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "175": {
    "node_id": "1467ede7-3a9a-4fa6-ab95-78a6978df7c2",
    "title": "STARTUP",
    "level": 2,
    "type": "clause",
    "content": "StartPreOs\nStartPostOs\nUP\nOffPreOs\nOffPostOs",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "176": {
    "node_id": "e25ac631-e26c-4929-b615-caf7f927c037",
    "title": "OFF",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "177": {
    "node_id": "d4d9d75c-5740-4b0b-9829-d6963312ab26",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "GoSleep\nPoll Halt\nWakeUpRestart\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \n \u000b \u0004 \f \u000e \u000f \u0010 \u0010\n\u0011\n\u0004 \u0004\n\u0012\n\u0002\n\u0011\n\u0010 \u0004\n\u0013\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \n \u000b \u0004 \f \u000e \u000f \u0010 \u0010\n\u0011\n\u0004\n\u0013\n\u000f \f \u0002\n\u0011\n\u0010 \u0004\n\u0013\n\u0014 \u0015 \u0016\n\u0004 \n \u0007 \u0010 \u0004 \u0004 \u0006\n\u0016 \u0017\n\u0004\n\u0001 \u0002 \u0003 \u0004 \t \u0006 \u0018 \u0002 \u0010 \u000f\n\u0013\n\u0002\n\u0016\n\u000f \b\n\u0012\n\u000f \f\n\f\n\u0016\n\u0002 \n\u0016\n\u0004\n\u0013\n\u000f\n\u0015 \u0012\n\u0004 \u0004\n\u0013\n\u0004\n\u0013\nOS started\nBswM, Os and SchM initialized\nReset if Shutdown\nTarget is RESET\nSchM and BswM de-\ninitialized; OS will be\nshutdown\nFigure 7.1: Phases of the ECU Manager\n30 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "178": {
    "node_id": "e08afa83-7b4d-45ab-b104-737d7c44358d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### STARTUP Phase\n\nThe purpose of the STARTUP phase is to initialize the basic software modules to the\npoint where Generic Mode Management facilities are operational. For more details\nabout the initialization see chapter 7.3.\n\n### UP Phase\n\nEssentially, the UP phase starts when the BSW Scheduler has started andBswM_-\nInit has been called. At that point, memory management is not initialized, there are\nno communication stacks, no SW-C support (RTE) and the SW-Cs have not started.\nProcessing starts in a certain mode (the next one configured after Startup) with cor-\nresponding runnables, i.e. the BSW MainFunctions, and continues as an arbitrary\ncombination of mode changes which cause the BswM to execute actions as well as\ntriggering and disabling corresponding runnables.\nFrom the ECU Manager Module perspective, the ECU is \"up\", however. The BSW\nMode Manager Module then starts mode arbitration and all further BSW initialization,\nstarting the RTE and (implicitly) starting SW-Cs becomes code executed in the BswM’s\naction lists or driven by mode-dependent scheduling, effectively under the control of\nthe integrator.\nInitializing the NvM and calling NvM_Readall therefore also becomes integration code.\nThis means that the integrator is responsible for triggering the initialization of Com,\nDEM and FIM at the end of NvM_ReadAll. The NvM will notify the BswM when NvM_\nReadAll has finished.\nNote that the RTE can be started after NvM and COM have been initialized. Note also\nthat the communication stack need not be fully initialized before COM can be initialized.\nThese changes initialize BSW modules as well as starting SW-Cs in arbitrary order\nuntil the ECU reaches full capacity and the changes continue to determine the ECU\ncapabilities thereafter as well.\nUltimately mode switches stop SW-Cs and de-initialize the BSW so that the Up phase\nends when the ECU reaches a state where it can be powered off.\nSo, as far as the ECU Manager module is concerned, the BSW and SW-Cs run until\nthey are ready for the ECU to be shut down or put to sleep.\nRefer to the Guide to Mode Management [4] for guidance on how to design mode-\ndriven ECU management and for configuring the BSW Mode Manager accordingly.\n31 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "179": {
    "node_id": "200f489f-3c95-4b02-95f9-ee37c840e9c7",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### SHUTDOWN Phase\n\n[SWS_EcuM_03022] ⌈The SHUTDOWN phase handles the controlled shutdown of\nbasic software modules and finally results in the selected shutdown target OFF or\nRESET.⌋(SRS_ModeMgm_09072)\n\n### SLEEP Phase\n\nThe ECU saves energy in the SLEEP phase. Typically, no code is executed but power\nis still supplied, and if configured accordingly, the ECU is wakeable in this state1. The\nECU Manager module provides a configurable set of (hardware) sleep modes which\ntypically are a trade off between power consumption and time to restart the ECU.\nThe ECU Manager module wakes the ECU up in response to intended or unintended\nwakeup events. Since unintended wakeup events should be ignored, the ECU Man-\nager module provides a protocol to validate wakeup events. The protocol specifies\na cooperative process between the driver which handles the wakeup source and the\nECU Manager (see section 7.6.4 ).\n\n### OFF Phase\n\nThe ECU enters the OFF state when it is powered down. The ECU may be wakeable\nin this state but only for wakeup sources with integrated power control. In any case the\nECU must be startable (e.g. by reset events).\n1Some ECU designs actually do require code execution to implement a SLEEP state (and the wakeup\ncapability). For these ECUs, the clock speed is typically dramatically reduced. These could be imple-\nmented with a small loop inside the SLEEP state.\n32 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "180": {
    "node_id": "42cd06f8-eb15-417b-aa0b-49d688af3cf0",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "## Structural Description of the ECU Manager\n\n«module»\nEcuM\nBswM_Deinit\nBswM_EcuM_CurrentWakeup\nBswM_Init\nComM_EcuM_WakeUpIndication\nMcu_GetResetReason\nMcu_Init\nMcu_PerformReset\nMcu_SetMode\nSchM_Init\nSchM_Deinit\nWdgM_PerformReset\nGetResource\nReleaseResource\nShutdownOS\nStartOS\nAdc_Init\nCan_Init\nCanTrcv_Init\nDet_Init\nDet_ReportError\nEth_Init\nEthTrcv_Init\nFls_Init\nFr_Init\nFrTrcv_Init\nGetCoreID\nGpt_Init\nIcu_Init\nIoHwAb_Init\nLinTrcv_Init\nLin_Init\nPort_Init\nPwm_Init\nShutdownAllCores\nStartCore\nWdg_Init\nSpi_Init\nDisableAllInterrupts\nEnableAllInterrupts\nGetEvent\nSetEvent\nDem_Init\nDem_PreInit\nDem_Shutdown\nOcu_Init\nEcuM_SelectShutdownTarget\nEcuM_GetLastShutdownTarget\nEcuM_GetShutdownTarget\nCanSM_EcuMWakeUpValidation\nEcuM_flex_Types\nEcuM_SetState\nEthSwt_Init\nEcuM_Types_both\nEcuM_StartCheckWakeup\nEcuM_EndCheckWakeup\nComM_EcuM_PNCWakeUpIndication\nEcuM_AL_DriverInitBswM_<x>\nEcuM_GoDownHaltPoll EcuM_Types\n«mandatory» «optional»\n«mandatory»\n«mandatory»\n«optional»\n«mandatory»\n«realize»\n«mandatory»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«optional»\n«optional»\n«realize»\n«optional»\n«configurable»\n«realize»\n«mandatory»\n«mandatory»\n«optional»\n«mandatory»\n«realize»\n«optional»\n«optional»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«optional»\n«mandatory»\n«mandatory»\n«mandatory»\n«mandatory»\n«mandatory»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«configurable»\n«mandatory»\n«realize»\n«optional»\n«optional»\n«realize»\n«realize»\n«realize»\n«optional»\n«realize»\n«mandatory»\nFigure 7.2: ECU Manager Module Relationships\nFigure 7.2 illustrates the ECU Manager module’s relationship to the interfaces of other\nBSW modules. In most cases, the ECU Manager module is simply responsible for\n33 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "181": {
    "node_id": "0c4bdcfa-dceb-450e-b241-2b63c1ed5b3a",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "initialization2. There are however some modules that have a functional relationship\nwith the ECU Manager module, which is explained in the following paragraphs.\n\n### Standardized AUTOSAR Software Modules\n\nSome Basic Software driver modules are initialized, shut down and re-initialized upon\nwakeup by the ECU Manager module.\nThe OS is initialized and shut down by the ECU Manager.\nAfter the OS initialization, additional initialization steps are undertaken by the ECU\nManager module before passing control to the BswM. The BswM hands execution\ncontrol back to the ECU Manager module immediately before OS shutdown. Details\nare provided in the chapters 7.3 STARTUP and 7.4 SHUTDOWN .\n\n### Software Components\n\nSW-Components contain the AUTOSAR ECU’s application code.\nA SW-C interacts with the ECU Manager module using AUTOSAR ports.\n\n## STARTUP Phase\n\nSee Chapter 7.1.1 for an overview description of the STARTUP phase.\n2To be precise, \"initialization\" could also mean de-initialization.\n34 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "182": {
    "node_id": "42fed864-b434-4dc5-90a1-a4b5a9a52915",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nOs\nC Init Code «module»\nEcuM\nBSW Task (OS task\nor cyclic call)\nBoot Menu\nResetReset\nref\nStartPostOS Sequence\nref\nStartPreOS Sequence\nActivateTask()\nJump()\nEcuM_StartupTwo()\nEcuM_Init()\nStartOS()\nStartupHook()\nReset\nVector()\nSet up\nstack()\nFigure 7.3: STARTUP Phase\nFigure 7.3 shows the startup behavior of the ECU. When invoked throughEcuM_Init,\nthe ECU Manager module takes control of the ECU startup procedure. With the call\nto StartOS, the ECU Manager module temporarily relinquishes control. To regain\ncontrol, the Integrator has to implement an OS task that is automatically started and\ncalls EcuM_StartupTwo as its first action.\n\n### Activities before EcuM_Init\n\nThe ECU Manager module assumes that before EcuM_Init (see\n[SWS_EcuM_02811] ) is called a minimal initialization of the MCU has taken\nplace, so that a stack is set up and code can be executed, also that C initialization of\nvariables has been performed.\n\n### Activities in StartPreOS Sequence\n\n[SWS_EcuM_02411] ⌈Table StartPreOS Sequence shows the activities in StartPre\nOS Sequence and the order in which they shall be executed inEcuM_Init (see\n[SWS_EcuM_02811] ).⌋()\n35 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "183": {
    "node_id": "6c7b71db-9b16-430a-afaa-8dfc83435b78",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "StartPreOS Sequence\nInitialization Activity Comment Opt.\nCallout EcuM_AL_SetProgrammableIn-\nterrupts\nOn ECUs with programmable interrupt prior-\nities, these priorities must be set before the\nOS is started.\nyes\nCallout EcuM_AL_DriverInitZero\nInit block 0\nThis callout may only initialize BSW modules\nthat do not use post-build configuration pa-\nrameters. The callout may not only contain\ndriver initialization but also any kind of pre-\nOS, low level initialization code. See 7.3.5\nDriver Initialization\nyes\nCallout EcuM_DeterminePbConfigura-\ntion\nThis callout is expected to return a pointer to a\nfully initialized EcuM_ConfigType structure\ncontaining the post-build configuration data\nfor the ECU Manager module and all other\nBSW modules.\nno\nCheck consistency of configuration data\nIf check fails theEcuM_ErrorHook is called.\nSee 7.3.4 Checking Configuration Consis-\ntency for details on the consistency check.\nno\nCallout EcuM_AL_DriverInitOne\nInit block I\nThe callout may not only contain driver initial-\nization but any kind of pre-OS, low level ini-\ntialization code. See 7.3.5 Driver Initialization\nyes\nGet reset reason\nThe reset reason is derived from a call\nto Mcu_GetResetReason and the map-\nping defined via the EcuMWakeupSource\nconfiguration containers. See 8.4.1.2\nEcuM_SetWakeupEvent and 8.3.5.3\nEcuM_GetValidatedWakeupEvents (see\n[SWS_EcuM_02830] )\nno\nSelect default shutdown target See [SWS_EcuM_02181] no\nCallout EcuM_LoopDetection If Loop Detection is enabled, this callout is\ncalled on every startup. yes\nStart OS Start the AUTOSAR OS, see\n[SWS_EcuM_02603]\nno\nTable 7.1: StartPreOS Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration.\nSee section 10.1 Common Containers and configuration parameters for details.\n[SWS_EcuM_02623] ⌈The ECU Manager module shall remember the wakeup source\nresulting from the reset reason translation (see tableStartPreOS Sequence).⌋()\nRationale for [SWS_EcuM_02623]: The wakeup sources must be validated by the\nEcuM_MainFunction (see section 7.6.4 Activities in the WakeupValidation Se-\nquence).\n[SWS_EcuM_02684] ⌈When activated through the EcuM_Init (see\n[SWS_EcuM_02811] ) function, the ECU Manager module shall perform the ac-\ntions in the StartPreOS Sequence (see tableStartPreOS Sequence).⌋()\n36 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "184": {
    "node_id": "2028b2ce-1bfa-45b0-b472-dd54259a12eb",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nOs\n«module»\nMcu\n«module»\nEcuM\nIntegration Code\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u0001\nopt Configuration data inconsistent\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u000b\n\f \n \u0003 \u000e \t \u000f \u0007 \u0007 \u0002 \u0010 \u0011 \u0010 \u0012 \u0012 \u0010 \u0004 \u0013 \u0012 \u0002 \u000e \u0014\nEcuM_LoopDetection()\nEcuM_AL_DriverInitOne()\nCheck consistency of configuration\ndata()\nEcuM_AL_DriverInitZero()\nEcuM_DeterminePbConfiguration(const\nEcuM_ConfigType*)\nStartOS(ECUM_DEFAULT_APP_MODE)\nMcu_GetResetReason()\nEcuM_ErrorHook(ECUM_E_CONFIGURATION_DATA_INCONSISTEN T)\nMcu_GetResetReason(Mcu_ResetType)\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nMap reset reason to wakeup\nsource()\nFigure 7.4: StartPreOS Sequence\n37 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "185": {
    "node_id": "d0e1eea3-a501-4033-abd9-639fbb2d808e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "The StartPreOS Sequence is intended to prepare the ECU to initialize the OS and\nshould be kept as short as possible. Drivers should be initialised in the UP phase\nwhen possible and the callouts should also be kept short. Interrupts should not be\nused during this sequence. If interrupts have to be used, only category I interrupts are\nallowed in the StartPreOS Sequence 13 .\nInitialization of drivers and hardware abstraction modules is not strictly defined by the\nECU Manager. Two calloutsEcuM_AL_DriverInitZero (see [SWS_EcuM_02905]\n) andEcuM_AL_DriverInitOne (see [SWS_EcuM_02907] ) are provided to define\nthe init blocks 0 and I. These blocks contain the initialization activities associated with\nthe StartPreOS sequence.\nMCU_Init does not provide complete MCU initialization. Additionally, hardware depen-\ndent steps have to be executed and must be defined at system design time. These\nsteps are supposed to be taken within theEcuM_AL_DriverInitZero (see EcuM_-\nAL_DriverInitZero, [SWS_EcuM_02905] ) or EcuM_AL_DriverInitOne call-\nouts (see EcuM_AL_DriverInitOne, [SWS_EcuM_02907] ). Details can be found\nin the Specification of MCU Driver [10].\n[SWS_EcuM_02181] ⌈The ECU Manager module shall callEcuM_GetValidated-\nWakeupEvents with the configured default shutdown target (EcuMDefaultShut-\ndownTarget).⌋()\nSee section 7.7 Shutdown Targets.\n[SWS_EcuM_02603] ⌈The StartPreOS Sequence shall initialize all basic software\nmodules that are needed to start the OS.⌋()\n\n### Activities in the StartPostOS Sequence\n\nStartPostOS Sequence\nInitialization Activity Comment Opt.\nStart BSW Scheduler no\nInit BSW Mode Manager no\nInit BSW Scheduler Initialize the semaphores for critical sections used\nby BSW modules no\nStart Scheduler Timing Start periodical events for BSW/SWCs no\nTable 7.2: StartPostOS Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration.\nSee section 10.1 Common Containers and configuration parameters for details.\n[SWS_EcuM_02932] ⌈When activated through the EcuM_StartupTwo (see\n[SWS_EcuM_02838] ) function, the ECU Manager module shall perform the actions\nin StartPostOS Sequence (see table 7.2).⌋(SRS_ModeMgm_09113)\n3Category II interrupts require a running OS while category I interrupts do not. AUTOSAR OS re-\nquires each interrupt vector to be exclusively put into one category.\n38 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "186": {
    "node_id": "ca698038-76ca-4ad6-afd9-8dc4cec14f83",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nSchM\n«module»\nEcuM\n«module»\nBswM\nSchM_Start():\nStd_ReturnType\nSchM_StartTiming(const SchM_ConfigType*)\nSchM_Init(const SchM_ConfigType*)\nBswM_Init(const BswM_ConfigType *)\nFigure 7.5: StartPostOS Sequence\n\n### Checking Configuration Consistency\n\n\n\n#### The Necessity for Checking Configuration Consistency in the ECU Man-\n\nager\nIn an AUTOSAR ECU several configuration parameters are set and put into the ECU\nat different times. Pre-compile parameters are set, inserted into the generated source\ncode and compiled into object code. When the source code has been compiled, link-\ntime parameters are set, compiled, and linked with the previously configured object\ncode into an image that is put into the ECU. Finally, post-build parameters are set,\ncompiled, linked, and put into the ECU at a different time. All these parameters must\nmatch to obtain a stable ECU.\n39 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "187": {
    "node_id": "c43444be-cf46-4d08-a09f-153b3921e15d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Figure 7.6: BSW Configuration Steps\nThe configuration tool can check the consistency of configuration time parameters it-\nself. The compiler may detect parameter errors at compilation time and the linker may\nfind additional errors at link time. Unfortunately, finding configuration errors in post-\nbuild parameters is very difficult. This can only be achieved by checking that\n•the pre-compile and link-time parameter settings used when compiling the code\nare exactly the same as\n•the pre-compile and link-time parameter settings used when configuring and com-\npiling the post-build parameters.\nThis can only be done at run-time.\nExplanation for [SWS_EcuM_02796]: The ECU Manager module checks the consis-\ntency once before initializing the first BSW module to avoid multiple checks scattered\nover the different BSW modules.\nThis also implies that:\n[SWS_EcuM_02796] ⌈The ECU Manager module shall not only check the consistency\nof its own parameters but of all post-build configurable BSW modules before initializing\nthe first BSW module.⌋()\nThe ECU Manager Configuration Tool must compute a hash value over all pre-compile\nand link-time configuration parameters of all BSW modules and store the value in the\nlink-time ECUM_CONFIGCONSISTENCY_HASH (see EcuMConfigConsistencyHash)\nconfiguration parameter. The hash value is necessary for two reasons. First, the pre-\ncompile and link-time parameters are not accessible at run-time. Second, the check\n40 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "188": {
    "node_id": "e654c8c6-9b43-41c8-89cf-3ac9dde80c34",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "must be very efficient at run-time. Comparing hundreds of parameters would cause an\nunacceptable delay in the ECU startup process.\nThe ECU Manager module Configuration Tool must in turn put the computedECUM_\nCONFIGCONSISTENCY_HASH value into the field in theEcuM_ConfigType structure\nwhich contains the root of all post-build configuration parameters.\n[SWS_EcuM_02798] ⌈The ECU Manager module shall check inEcuM_Init (see\n[SWS_EcuM_02811] ) that the field in the structure is equal to the value ofECUM_\nCONFIGCONSISTENCY_HASH .⌋()\nBy computing hash values at configuration time and comparing them at run-time the\nEcuM code can be very efficient and is furthermore independent of a particular hash\ncomputation algorithm. This allows the use of complex hash computation algorithms,\ne.g. cryptographically strong hash functions.\nNote that the same hash algorithm can be used to produce the value for the post-build\nconfiguration identifier in theEcuM_ConfigType structure. Then the hash algorithm\nis applied to the post-build parameters instead of the pre-compile and link-time param-\neters.\n[SWS_EcuM_02799] ⌈The hash computation algorithm used to compute a hash value\nover all pre-compile and link-time configuration parameters of all BSW modules shall\nalways produce the same hash value for the same set of configuration data regardless\nof the order of configuration parameters in the XML files.⌋()\n\n#### Example Hash Computation Algorithm\n\nNote: This chapter is not normative. It describes one possible way to compute hash\nvalues.\nA simple CRC over the values of configuration parameters will not serve as a good\nhash algorithm. It only detects global changes, e.g. one parameter has changed from\n1 to 2. But if another parameter changed from 2 to 1, the CRC might stay the same.\nAdditionally, not only the values of the configuration parameters but also their names\nmust be taken into account in the hash algorithm. One possibility is to build a text\nfile that contains the names of the configuration parameters and containers, separate\nthem from the values using a delimiter, e.g. a colon, and putting each parameter as a\nline into a text file.\nIf there are multiple containers of the same type, each container name can be ap-\npended with a number, e.g. \"_0\", \"_1\" and so on.\nTo make the hash value independent of the order in which the parameters are written\ninto the text file, the lines in the file must now be sorted lexicographically.\n41 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "189": {
    "node_id": "21d5ccb8-a49e-4f46-b287-bd9a02bcd132",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Finally, a cryptographically strong hash function, e.g. MD5, can be run on the text file\nto produce the hash value. These hash functions produce completely different hash\nvalues for slightly changed input files.\n\n### Driver Initialization\n\nA driver’s location in the initialization process depends strongly on its implementation\nand the target hardware design.\nDrivers can be initialized by the ECU Manager module in Init Block 0 or Init Block 1 of\nthe STARTUP phase or re-initialized in theEcuM_AL_DriverRestart callout of the\nWakeupRestart Sequence. Drivers can also be initialized or re-initialized by the BswM\nduring the UP phase.\nThis chapter applies to those AUTOSAR Basic Software drivers, other than SchM and\nBswM, whose initialization and re-initialization is handled by the ECU Manager module\nand not the BswM.\n[SWS_EcuM_02559] ⌈The configuration of the ECU Manager module shall spec-\nify the order of initialization calls inside init block 0 and init block 1. (seeEcuM-\nDriverInitListZero and EcuMDriverInitListOne ).⌋(SRS_BSW_00416,\nSRS_ModeMgm_09234)\n[SWS_EcuM_02730] ⌈The ECU Manager module shall call each driver’s init function\nwith the parameters derived from the driver’sEcuMModuleService configuration con-\ntainer.⌋(SRS_ModeMgm_09234)\n[SWS_EcuM_02947] ⌈For re-initialization during WakeupRestart, the integrator shall\nintegrate a restart block into the integration code forEcuM_AL_DriverRestart (see\n[SWS_EcuM_02923] ) using the EcuMDriverRestartList.⌋(SRS_ModeMgm_-\n09234)\n[SWS_EcuM_02562] ⌈EcuMDriverRestartList may contain drivers that serve as\nwakeup sources. EcuM_AL_DriverRestart shall re-arm the trigger mechanism of\nthese drivers’ ’wakeup detected’ callback.⌋()\nSee Section 7.5.5 Activities in the WakeupRestart Sequence.\n[SWS_EcuM_02561] ⌈The ECU Manager module shall initialize the drivers in Ecu\nMDriverRestartList in the same order as in the combined list of init block 0 and init\nblock 1.⌋()\nHint for [SWS_EcuM_02561]:EcuMDriverRestartList will typically only contain a\nsubset of the combined list of init block 0 and init block 1 drivers.\nTable 7.3 shows one possible (and recommended) sequence of activities for the Init\nBlocks 0 and I. Depending on hardware and software configuration, BSW modules\nmay be added or left out and other sequences may also be possible.\n42 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "190": {
    "node_id": "12b36b5e-c3e8-4941-b33f-e1820d4ffb25",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Recommended Init Block\nInitialization Activity Comment\nInit Block 04\nDefault Error Tracer\nThis should always be the first module to be initial-\nized, so that other modules can report development\nerrors.\nDiagnostic Event Manager Pre-Initialization\nAny drivers needed to access\npost-build configuration data\nThese drivers shall not depend on the post-build\nconfiguration or on OS features.\nInit Block I5\nMCU Driver\nPort Driver\nGeneral Purpose Timer\nWatchdog Driver Internal watchdogs only, external ones may need",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "191": {
    "node_id": "9e626efe-df5b-4f5c-b05b-ae4fa90b5a77",
    "title": "SPI",
    "level": 2,
    "type": "clause",
    "content": "Watchdog Manager\nADC Driver\nICU Driver\nPWM Driver\nOCU Driver\nTable 7.3: Driver Initialization Details, Sample Configuration\n\n### BSW Initialization\n\nThe remaining BSW modules are initialized by the BSW Mode Manager, using a config-\nured function of the ECU Manager (EcuMDriverInitCalloutName ECUC_EcuM_00227)\ncreated from the configured list of init functions (EcuMDriverInitListBswM ).\n[SWS_EcuM_04142] ⌈The configuration of the ECU Manager module shall specify the\norder of initialization calls inside the BSW initialization (seeEcuMDriverInitListB-\nswM ).⌋()\n\n## SHUTDOWN Phase\n\nRefer to Section 7.1.3 SHUTDOWN Phase for an overview of the SHUTDOWN phase.\nEcuM_GoDownHaltPoll with shutdown target RESET or OFF initiates the SHUT -\nDOWN Phase.\n[SWS_EcuM_02756] ⌈When a wakeup event occurs during the shutdown phase, the\nECU Manager module shall complete the shutdown and restart immediately there-\nafter.⌋()\n4Drivers in Init Block 0 are listed in the EcuMDriverInitListZero configuration container.\n5Drivers in Init Block I are listed in the EcuMDriverInitListOne configuration container.\n43 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "192": {
    "node_id": "fbb7a6fb-c7f5-488d-8ddc-f91cc189e9ae",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nOs\n«module»\nEcuM\nIntegration Code«module»\nBswM\nref\nOffPreOS Sequence\nref\nOffPostOS Sequence\nEcuM_Shutdown()\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nShutdownHook()\nEcuM_GoDownHaltPoll\n(Std_ReturnType, EcuM_UserType)\nShutdownOS()\nFigure 7.7: SHUTDOWN Phase\n\n### Activities in the OffPreOS Sequence\n\n[SWS_EcuM_03021] ⌈See 7.4⌋(SRS_ModeMgm_09127)\nOffPreOS Sequence\nShutdown Activity Comment Opt.\nDe-init BSW Mode Manager no\nDe-init BSW Scheduler no\nCheck for pending wakeup events Purpose is to detect wakeup events\nthat occurred during shutdown no\nSet RESET as shutdown target, if\nwakeup events are pending (default\nreset mode of EcuMDefaultReset-\nModeRef will be used)\nThis action shall only be carried out\nwhen pending wakeup events were de-\ntected to allow an immediate startup\nno\nShutdownOS Last operation in this OS task no\nTable 7.4: OffPreOs Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration. It\nshall be the system designers choice if a module is compiled in or not for an ECU de-\nsign. See chapter 10.1 Common Containers and configuration parameters for details.\n[SWS_EcuM_02952] ⌈As its last activity, the ECU Manager module shall call the Shut-\ndownOS function.⌋(SRS_ModeMgm_09104)\nThe OS calls the shutdown hook at the end of its shutdown.\n44 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "193": {
    "node_id": "a3ef3e9d-e1f4-4f06-8804-477054721718",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_02953] ⌈The shutdown hook shall call EcuM_Shutdown (see\n[SWS_EcuM_02812] ) to terminate the shutdown process. EcuM_Shutdown(see\n[SWS_EcuM_02812] ) shall not return but switch off the ECU or issue a reset.⌋(SRS_-\nModeMgm_09104)\n«module»\nEcuM\n«module»\nOs\n«module»\nSchM\n«module»\nBswM\nIntegration Code\nopt Pending wakeup events?\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nShutdownOS()\nEcuM_OnGoOffOne()\nBswM_Deinit()\nSchM_Deinit()\nFigure 7.8: OffPreOS Sequence\n\n### Activities in the OffPostOS Sequence\n\nThe OffPostOS sequence implements the final steps to reach the shutdown target after\nthe OS has been shut down.EcuM_Shutdown (see [SWS_EcuM_02812] ) initiates the\nsequence.\n45 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "194": {
    "node_id": "f862e925-bf0d-4a7b-a624-dcf0147d1b42",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "The shutdown target can be either ECUM_SHUTDOWN_TARGET_RESET or ECUM_\nSHUTDOWN_TARGET_OFF , whereby the specific reset modality is determined by the\nreset mode. See section 7.7 Shutdown Targets for details.\nOffPostOS Sequence\nShutdown Activity Comment Opt.\nCallout EcuM_OnGoOffTwo\nCallout EcuM_AL_Reset or Callout\nEcuM_AL_SwitchOff\nDepends on the selected shutdown tar-\nget (RESET or OFF)\nno\nTable 7.5: OffPostOs Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration. It\nshall be the system designers choice if a module is compiled in or not for an ECU de-\nsign. See chapter 10.1 Common Containers and configuration parameters for details.\nIntegration Code«module»\nEcuM\nalt Shutdown Target\n[Reset]\n[Off]\nEcuM_AL_SwitchOff()\nEcuM_OnGoOffTwo()\nEcuM_AL_Reset(EcuM_ResetType)\nFigure 7.9: OffPostOS Sequence\n[SWS_EcuM_04074] ⌈When the shutdown target is RESET, the ECU Manager module\nshall call theEcuM_AL_Reset callout.⌋()\n46 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "195": {
    "node_id": "981f1431-d1b5-4374-b8b7-4cbd43f57d6e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "See section 8.5.3.4EcuM_AL_Reset ([SWS_EcuM_04065] ) for details.\n[SWS_EcuM_04075] ⌈When the shutdown target is OFF , the ECU Manager module\nshall call theEcuM_AL_SwitchOff callout.⌋()\nSee section 8.5.3.3EcuM_AL_SwitchOff ([SWS_EcuM_02920] ) for details.\n\n## SLEEP Phase\n\nRefer to Section 7.1.4 SLEEP Phase for an overview of the SLEEP phase.EcuM_-\nGoDownHaltPoll with shutdown target SLEEP initiate the SLEEP phase.\nEcuM_GoDownHaltPoll with shutdown target SLEEP initiate two control streams,\ndepending on the sleep mode selected (EcuMSleepModeSuspend parameter), that\ndiffer structurally in the mechanisms used to realize sleep. They share the sequences\nfor preparing for and recovering from sleep, however.\n47 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "196": {
    "node_id": "928183b9-98f8-4d95-9d5b-5eca4223c4fd",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n«module»\nBswM\nref\nGoSleep Sequence\nalt \n[EcuM_GoDownHaltPoll called]\n[EcuM_GoDownHaltPoll called]\nref\nHalt Sequence\nref\nPolling Sequence\nref\nWakeupRestart Sequence\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nEcuM_GoDownHaltPoll\n(Std_ReturnType, EcuM_UserType)\nFigure 7.10: SLEEP Phase\nAnother module, presumably the BswM, although it could be an SW-C as well, must\nensure that an appropriate ECUM_STATE_SLEEP shutdown target has been selected\nbefore callingEcuM_GoDownHaltPoll.\n48 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "197": {
    "node_id": "c10510b1-9b7d-4c14-b1cd-aac0b6c68fc3",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Activities in the GoSleep Sequence\n\nIn the GoSleep sequence the ECU Manager module configures hardware for the up-\ncoming sleep phase and sets the ECU up for the next wakeup event.\n[SWS_EcuM_02389] ⌈To set the wakeup sources up for the next sleep mode, the\nECU Manager module shall execute theEcuM_EnableWakeupSources callout (see\n[SWS_EcuM_02546] ) for each wakeup source that is configured inEcuMWakeup-\nSourceMask for the target sleep mode.⌋(SRS_ModeMgm_09100)\n[SWS_EcuM_02951] ⌈In contrast to the SHUTDOWN phase, the ECU Manager mod-\nule shall not shut down the OS when entering the SLEEP phase. The sleep mode, i.e.\ncombination of the EcuM SLEEP phase and the Mcu Mode, shall be transparent to the\nOS.⌋()\n«module»\nEcuM\n«module»\nOs\nIntegration Code «module»\n:BswM\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_NONE )\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nFigure 7.11: GoSleep Sequence\n[SWS_EcuM_03010] ⌈When operating on a multicore ECU ECUM shall reserve a ded-\nicated resource (RES_AUTOSAR_ECUM) for each core, which is allocated during Go\nSleep.⌋()\n\n### Activities in the Halt Sequence\n\n[SWS_EcuM_02960] ⌈The ECU Manager module shall execute the Halt Sequence in\nsleep modes that halt the microcontroller. In these sleep modes the ECU Manager\nmodule does not execute any code.⌋()\n[SWS_EcuM_02863] ⌈The ECU Manager module shall invoke theEcuM_Generat-\neRamHash (see [SWS_EcuM_02919] ) callout before halting the microcontroller the\n49 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "198": {
    "node_id": "76dafcf3-b02d-4343-8230-09e005285376",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "EcuM_CheckRamHash (see [SWS_EcuM_02921] ) callout after the processor returns\nfrom halt.\nIn case of applied multi core and existence of \"slave\" EcuM(s) this check should be\nexecuted on the \"master\" EcuM only. The \"master\" EcuM generates the hash out of all\ndata that lie within its reach. Private data of \"slave\" EcuMs are out of scope.⌋()\nRationale for [SWS_EcuM_02863] : Ram memory may become corrupted when an\nECU is held in sleep mode for a long time. The RAM memory’s integrity should there-\nfore be checked to prevent unforeseen behavior. The system designer may choose an\nadequate checksum algorithm to perform the check.\n50 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "199": {
    "node_id": "cab71ebd-59de-4751-a0a0-5bf4a7bab2db",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \b \t \n \u000b \n \f \f \n \n \u000e \f \t \u0004 \u000f\nIntegration Code\n\u0010 \u0011 \u0012 \u0013 \n \n \u000e \f \t \u0004 \n \u0014 \u0015 \u0007 \b \n \u0016 \u0010 \u0017 \n \u0006 \u000e \n \u0003 \u0014 \t\n\u0006 \u0014 \t \n \u0003 \t \u000e \n \u0004\n\u0018\n\u0003 \n \u0002 \n \u0002 \n \u0003 \t \n \n \f \f \u000e\n\u0019\n\n \u0007\n\u001a\n\u0014 \u000b \n\u001b\n«module»\n:BswM\n«Peripheral»\nWakeup Source\n«module»\nMcu\n«module»\nEcuM\n«module»\nWakeup Source\n«module»\nOs",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "200": {
    "node_id": "83cc447d-e204-4283-a040-5ea4db79418d",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "opt RAM check failed\nalt Validation Needed\n[Yes]\n[No]\nalt AlarmClock Service Present\n[EcuM_AlarmClock only pending event AND Alarm not expired]\nopt Wakeup handling\n[Wakeup detected]\n[No Wakeup detected]\nBswM_EcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_VALIDATED)\nMcu_SetMode(Mcu_ModeType)\nMcu_SetMode()\nEcuM_StartCheckWakeup()\nBswM_EcuM_CurrentWakeup(sources.\nECUM_WKSTATUS_PENDING)\n<Module>_CheckWakeup()\nActivate\nPLL()\nEcuM_CheckRamHash(uint8)\nMcu_SetMode(Mcu_ModeType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nEcuM_GenerateRamHash()\nEcuM_ErrorHook(uint16)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_GenerateRamHash()\nReturn from\ninterrupt()\nInterrupt()\nDisableAllInterrupts()\nFigure 7.12: Halt Sequence\n51 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "201": {
    "node_id": "79890754-3ec1-495a-9d9a-5b4661fc41ef",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_02961] ⌈The ECU Manager module shall invoke theEcuM_Generat-\neRamHash (see [SWS_EcuM_02919] ) where the system designer can place a RAM\nintegrity check.⌋()\n\n### Activities in the Poll Sequence\n\n[SWS_EcuM_02962] ⌈The ECU Manager module shall execute the Poll Sequence in\nsleep modes that reduce the power consumption of the microcontroller but still execute\ncode.⌋()\n[SWS_EcuM_03020] ⌈In the Poll sequence the EcuM shall call the calloutsEcuM_-\nSleepActivity and EcuM_CheckWakeup() in a blocking loop until a pending/vali-\ndated wakeup event is reported.⌋()\n52 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "202": {
    "node_id": "fba1ff66-6624-4f57-b15f-f4a1635e691f",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n«module»\n:BswM\nIntegration Code «module»\nMcu\n«module»\nWakeup Source\n«module»\nOs\nloop WHILE no pending/validated wakeup events\nloop FOR all wakeup sources that need polling\nopt Wakeup handling\n[Wakeup detected]\n[No wakeup detected]\nalt Validation Needed\n[Yes]\n[No]\n\u0001 \u0002 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0007 \b \n \u0005 \u0006 \u000b \u0003 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0004 \u0005 \f \u0005 \u0005 \n \u000e \u000f \u0010 \u0003 \b \u0011 \u0012 \u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0017 \u0011 \u0013 \u0018 \u0003 \u0015 \u0011 \u0019 \u0013 \u0011 \u001a \u0011 \u0006 \u0004 \u0001 \u001b \u001c\n\u001d\n\u0015\n\u001e \u001f  \n\u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0005 \u0006 \b\n!\n\n \u0011 \u0006 \u0002 \u0003 \u0006\n\"\n\u0011 \u0018 \u0011 \u0006 \u0004 \u0001 \u001b \u001c \u0001 \b \u0007 \u0013 \u0014 \u0006 \u0005 \u0004 \u0011\n#\n\n \u0003 \u0013 \u0011 \u0002\n$\nEcuM_StartCheckWakeup()\nMcu_SetMode(Mcu_ModeType)\nEcuM_SleepActivity()\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\n<Module>_CheckWakeup()\nEnableAllInterrupts()\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources.\nECUM_WKSTATUS_VALIDATED)\nBswM_EcuM_CurrentWakeup(sources.\nECUM_WKSTATUS_PENDING)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_EndCheckWakeup()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nFigure 7.13: Poll Sequence\n53 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "203": {
    "node_id": "d38eadb6-b0ee-43e7-95c7-205e40df5b07",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Leaving Halt or Poll\n\n[SWS_EcuM_02963] ⌈If a wakeup event (e.g. toggling a wakeup line, communication\non a CAN bus etc.) occurs while the ECU is in Halt or Poll, then the ECU Manager\nmodule shall regain control and exit the SLEEP phase by executing the WakeupRestart\nsequence.\nAn ISR may be invoked to handle the wakeup event, but this depends on the hardware\nand the driver implementation.⌋()\nSee section 7.5.5 Activities in the WakeupRestart Sequence.\n[SWS_EcuM_04001] ⌈If irregular events (a hardware reset or a power cycle) occur\nwhile the ECU is in Halt or Poll, the ECU Manager module shall restart the ECU in the\nSTARTUP phase.⌋()\n\n### Activities in the WakeupRestart Sequence\n\nWakeupRestart6\nWakeup Activity Comment Opt.\nRestore MCU normal mode\nSelected MCU mode is configured in\nthe configuration parameter EcuMNor-\nmalMcuModeRef\nGet the pending wakeup sources\nCallout EcuM_DisableWakeup-\nSources\nDisable currently pending wakeup\nsource but leave the others armed so\nthat later wakeups are possible.\nCallout EcuM_AL_DriverRestart Initialize drivers that need restarting\nUnlock Scheduler From this point on, all other tasks may\nrun again.\nTable 7.6: Wakeup Restart activities\nThe ECU Manager module invokes the EcuM_AL_DriverRestart (see\n[SWS_EcuM_02923] ) callout which is intended for re-initializing drivers. Among\nothers, drivers with wakeup sources typically require re-initialization. For more details\non driver initialization refer to section 7.3.5 Driver Initialization.\nDuring re-initialization, a driver must check if one of its assigned wakeup sources was\nthe reason for the previous wakeup. If this test is true, the driver must invoke its ’wakeup\ndetected’ callback (see the Specification of CAN Transceiver Driver [11] for example),\nwhich in turn must call theEcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) func-\ntion.\nThe driver implementation should only invoke the wakeup callback once. Thereafter it\nshould not invoke the wakeup callback again until it has been re-armed by an explicit\nfunction call. The driver must thus be re-armed to fire the callback again.\n54 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "204": {
    "node_id": "80a778e5-f229-44c1-b2b0-3fe7f7817f73",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_02539] ⌈If the ECU Manager module has a list of wakeup source can-\ndidates when the WakeupRestart Sequence has finished, the ECU Manager module\nshall validate these wakeup source candidates inEcuM_MainFunction.⌋()\nSee section 7.6.4 Activities in the WakeupValidation Sequence.\n[SWS_EcuM_04066] ⌈\n«module»\nMcu\n«module»\nOs\n«module»\nEcuM\nIntegration Code\nEcuM_AL_DriverRestart()\nDisableAllInterrupts()\nMcu_SetMode(Mcu_ModeType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nFigure 7.14: WakeupRestart Sequence\n⌋\n()\n55 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "205": {
    "node_id": "95d0cd1a-5773-4dca-8c20-cf37713370ff",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "## UP Phase\n\nIn the UP Phase, theEcuM_MainFunction is executed regularly and it has three\nmajor functions:\n•To check if wakeup sources have woken up and to initiate wakeup validation, if\nnecessary (see 7.6.4 Activities in the WakeupValidation Sequence)\n•To update the Alarm Clock timer\n•Arbitrate RUN and POST_RUN requests and releases.\n\n### Alarm Clock Handling\n\nSee section 7.8.2 EcuM Clock Time in the UP Phase for implementation details.\n[SWS_EcuM_04002] ⌈When the Alarm Clock service is present (seeEcuMAlarm-\nClockPresent ) theEcuM_MainFunction shall update the Alarm Clock Timer⌋()\n\n### Wakeup Source State Handling\n\nWakeup source are not only handled during wakeup but continuously, in parallel to\nall other EcuM activities. This functionality runs in theEcuM_MainFunction fully\ndecoupled from the rest of ECU management via mode requests.\n[SWS_EcuM_04091] ⌈The wakeup sources can be in the following states:\nState Description\nNONE No wakeup event was detected\nor has been cleared.\nPENDING A wakeup event was detected\nbut not yet validated.\nVALIDATED A wakeup event was detected\nand succesfully validated.",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "206": {
    "node_id": "18b7a4dc-9ea3-4881-a52b-40c263cbe135",
    "title": "EXPIRED",
    "level": 2,
    "type": "clause",
    "content": "A wakeup event was detected\nbut validation failed.\nTable 7.7: Wakeup sources\n⌋(SRS_ModeMgm_09136)\nFigure 7.15 illustrates the relationship between the wakeup source states and the con-\nditions functions that evoke state changes. The two super-states Disabled and Valida-\ntion are only shown here for clarification and better understandability.\n56 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "207": {
    "node_id": "4d50b37f-9d82-425b-a871-8319e434e2a8",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "ECUM_WKSTATUS_NONE\nentry / BswM_EcuM_CurrentWakeup(sources, NONE)\nPower On / Initial\nECUM_WKSTATUS_PENDING\nentry / BswM_EcuM_CurrentWakeup(sources, PENDING)\nentry / EcuM_StartWakeupSources()\ndo / exec. wakeup validation seq.\nECUM_WKSTATUS_VALIDATED\nentry / BswM_EcuM_CurrentWakeup(sources, VALIDATED)\nentry / ComM_EcuM_WakeUpIndication()\nECUM_WKSTATUS_EXPIRED\nentry / BswM_EcuM_CurrentWakeup(sources, EXPIRED)\nentry / EcuM_StopWakeupSources()\nTimer Expired\nEcuM_ClearWakeupEvent(sources)\nEcuM_ValidateWakeupEvent()\nEcuM_SetWakeupEvent(sources)\n[With Validation]\nEcuM_SetWakeupEvent(sources)\n[No Validation]\nFigure 7.15: Wakeup Source States\n[SWS_EcuM_04003] ⌈When an ECU Manager action causes the state of a wakeup\nsource to change, the ECU Manager module shall issue a mode request to the BswM\nto change the wakeup source’s mode to the new the wakeup source state.⌋()\nFor the communication of these wakeup source states the typeEcuM_WakeupSta-\ntusType (see SWS_ECUM_04041) is used.\nWhen the ECU Manager module is in the UP phase, wakeup events do not usually\ntrigger state changes. They trigger the end of the Halt and Poll Sub-Phases, however.\nThe ECU Manager module then executes the WakeupRestart Sequence automatically\nand returns thereafter to the UP phase.\nIt is up to the integrator to configure rules in the BswM so that the ECU reacts correctly\nto the wakeup events, as the reaction depends fully on the current ECU (not ECU\nManagement) state.\nIf the wakeup source is valid, the BswM returns the ECU to its RUN state. If all wakeup\nevents have gone back to NONE or EXPIRED, the BswM prepares the BSW for SLEEP\nor OFF again and invokesEcuM_GoDownHaltPoll.\n57 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "208": {
    "node_id": "ad2f47f8-765f-4392-82ef-896e116affed",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Summarizing: every pending event is validated independently (if configured) and the\nEcuM publishes the result as a mode request to the BswM, which in turn can trigger\nstate changes in the EcuM.\n\n### Internal Representation of Wakeup States\n\nThe EcuM manager module offers the following interfaces to ascertain the state of\nthose wakeup sources:\n•EcuM_GetPendingWakeupEvents\n•EcuM_GetValidatedWakeupEvents\n•EcuM_GetExpiredWakeupEvents\nand manipulates the state of the wakeup sources through the following interfaces\n•EcuM_ClearWakeupEvent\n•EcuM_SetWakeupEvent\n•EcuM_ValidateWakeupEvent\n•EcuM_CheckWakeup\n•EcuM_DisableWakeupSources\n•EcuM_EnableWakeupSources\n•EcuM_StartWakeupSources\n•EcuM_StopWakeupSources\nThe ECU Manager module can manage up to 32 wakeup sources. The state of\nthe wakeup sources is typically represented at the EcuM interfaces named above\nby means of an EcuM_WakeupSourceType bitmask where the individual wakeup\nsources correspond to a fixed bit position. There are 5 predefined bit positions and\nthe rest can be assigned by configuration. See section 8.2.3EcuM_WakeupSource-\nType for details.\nOn the one hand, the ECU Manager module manages the modes of each wakeup\nsource. On the other hand, the ECU Manager module presupposes that there are \"in-\nternal variables\" (i.e.EcuM_WakeupSourceType instances) that track which wakeup\nsources are in a particular state (especially NONE (i.e. cleared), PENDING, VALI-\nDATED and EXPIRED). The ECU Manager module uses these \"internal variables\" in\nthe respective interface definitions to define the semantics of the interface.\nWhether these \"internal variables\" are indeed implemented is therefore of secondary\nimportance. They are simply used to explain the semantics of the interfaces.\n58 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "209": {
    "node_id": "112de0c8-313d-4386-be0d-1f1e0975891e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Activities in the WakeupValidation Sequence\n\nSince wakeup events can be generated unintentionally (e.g. EVM spike on CAN line),\nit is necessary to validate wakeups before the ECU resumes full operation.\nThe validation mechanism is the same for all wakeup sources. When a wakeup event\noccurs, the ECU is woken up from its SLEEP state and execution resumes within the\nMCU_SetMode service of the MCU driver7 . When the WakeupRestart Sequence has\nfinished, the ECU Manager module will have a list of pending wakeup events to be\nvalidated (see [SWS_EcuM_02539] ). The ECU Manager module then releases the\nBSW Scheduler and all BSW MainFunctions; most notably in this case, the EcuM Main\nFunction can resume processing.\nImplementation hint: Since SchM will be running at the end of the StartPostOS and\nWakeupRestart sequences, there is the possibility that theEcuM_MainFunction will\ninitiate validation for a source whose stack has not yet been initialized. The integrator\nshould configure appropriate modes which indicate that the stack is not available and\ndisable theEcuM_MainFunction accordingly (see [2] ).\n7Actually, the first code to be executed may be an ISR, e.g. a wakeup ISR. However, this is specific\nto hardware and/or driver implementation.\n59 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "210": {
    "node_id": "38848d74-6d97-441f-96cc-ebd034b5e03e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n«module»\nComM\n«module»\nWakeup Source\nIntegration Code «module»\nBswM\n«module»\nCanSM\nopt No wakeup event was validated\nopt Wakeup validated\nloop WHILE no wakeup event has been validated AND timeout not expired\nBswM_EcuM_CurrentWakeup(Source,\nECUM_WKSTATUS_EXPIRED)\nEcuM_CheckValidation(EcuM_WakeupSourceType)\nCanSM_StartWakeupSource(Std_ReturnType,\nNetworkHandleType)\nComM_EcuM_PNCWakeUpIndication(PNCHandleType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nCanSM_StopWakeupSource(Std_ReturnType,\nNetworkHandleType)\nStart validation\ntimeout()\nEcuM_StopWakeupSources(EcuM_WakeupSourceType)\nBswM_EcuM_CurrentWakeup(Source, ECUM_WKSTATUS_VALID ATED)\nEcuM_ValidateWakeupEvent(EcuM_WakeupSourceType)\n<Module>_CheckValidation()\nEcuM_StartWakeupSources(EcuM_WakeupSourceType)\nComM_EcuM_WakeUpIndication(NetworkHandleType)\nFigure 7.16: The WakeupValidation Sequence\n[SWS_EcuM_02566] ⌈The ECU Manager module shall only invoke wakeup validation\non those wakeup sources where it is required by configuration. If the validation protocol\n60 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "211": {
    "node_id": "8ce8b07e-dbbe-45a0-be91-79d8f7c31f5c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "is not configured (seeEcuMValidationTimeout ), then a call toEcuM_SetWakeu-\npEvent shall also imply a call toEcuM_ValidateWakeupEvent .⌋()\n[SWS_EcuM_02565] ⌈The ECU Manager module shall start a validation timeout for\neach pending wakeup event that should be validated. The timeout shall be event-\nspecific (seeEcuMValidationTimeout ).⌋()\nImplementation hint for [SWS_EcuM_02565]: It is sufficient for an implementation to\nprovide only one timer, which is prolonged to the largest timeout when new wakeup\nevents are reported.\n[SWS_EcuM_04081] ⌈When the validation timeout expires for a pending wakeup\nevent, theEcuM_MainFunction sets (OR-operation) set the bit in the internal expired\nwakeup events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_04082] ⌈When the validation timeout expires for a pending wakeup\nevent, the EcuM_MainFunction shall invoke BswM_EcuM_Current_Wakeup with\nan EcuM_WakeupSourceType bitmask parameter with the bit corresponding to the\nwakeup event set and state value parameter set to ECUM_WKSTATUS_EXPIRED.⌋()\nThe BswM will be configured to monitor the wakeup validation through mode switch\nrequests coming from the EcuM as the wakeup sources are validated or the timers ex-\npire. If the last validation timeout (see [SWS_EcuM_02565] ) expires without validation\nthen the BswM shall consider wakeup validation to have failed. If at least one of the\npending events is validated then the entire validation shall have passed.\nPending events are validated with a call of EcuM_ValidateWakeupEvent (see\n[SWS_EcuM_02829] ). This call must be placed in the driver or the consuming stack\non top of the driver (e.g. the handler). The best place to put this depends on hardware\nand software design. See also section 7.6.4.4 Requirements for Drivers with Wakeup\nSources .\n\n#### Wakeup of Communication Channels\n\nIf a wakeup occurs on a communication channel, the corresponding bus transceiver\ndriver must notify the ECU Manager module by invokingEcuM_SetWakeupEvent (see\n[SWS_EcuM_02826] ) function. Requirements for this notification are described in\nsection 5.2 Peripherals with Wakeup Capability.\n[SWS_EcuM_02479] ⌈The ECU Manager module shall execute the Wakeup Valida-\ntion Protocol upon theEcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) function\ncall according toInteraction of Wakeup Sources and the ECU Managerlater in this\nchapter.⌋()\nSee also 7.6.4.2 Interaction of Wakeup Sources and the ECU Manager.\n61 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "212": {
    "node_id": "f4bd2991-0808-42e9-95ea-30731413d5ba",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### Interaction of Wakeup Sources and the ECU Manager\n\nThe ECU Manager module shall treat all wakeup sources in the same way. The proce-\ndure shall be as follows:\nWhen a wakeup event occurs, the corresponding driver shall notify the ECU Manager\nmodule of the wakeup. The most likely modalities for this notification are:\n•After exiting the Halt or Poll sequences. In this scenario, the ECU Manager\nmodule invokes EcuM_AL_DriverRestart (see [SWS_EcuM_02923] ) to re-\ninitialize of the relevant drivers, which in turn get a chance to scan their hardware\ne.g. for pending wakeup interrupts.\n•If the wakeup source is actually in sleep mode, the driver must scan au-\ntonomously for wakeup events; either by polling or by waiting for an interrupt.\n[SWS_EcuM_02975] ⌈If a wakeup event requires validation then the ECU Manager\nmodule shall invoke the validation protocol⌋()\n[SWS_EcuM_02976] ⌈If a wakeup event does not require validation, the ECU Man-\nager module shall issue a mode switch request to set the event’s mode to ECUM_\nWKSTATUS_VALIDATED.⌋()\n[SWS_EcuM_02496] ⌈If the wakeup event is validated (either immediately or by the\nwakeup validation protocol), the ECU Manager module shall make the information that\nit is a source of the current ECU wakeup through theEcuM_GetValidatedWakeu-\npEvents (see [SWS_EcuM_02830] ) function.⌋()\n\n#### Wakeup Validation Timeout\n\n[SWS_EcuM_04004] ⌈The ECU Manager Module shall either provide a single wakeup\nvalidation timeout timer or one timer per wakeup source.⌋()\nThe following requirements apply:\n[SWS_EcuM_02709] ⌈The ECU Manager module shall start the wakeup validation\ntimeout timer whenEcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) is called.⌋()\n[SWS_EcuM_02710] ⌈EcuM_ValidateWakeupEvent shall stop the wakeup valida-\ntion timeout timer (see [SWS_EcuM_02829] ).⌋()\n[SWS_EcuM_02712] ⌈If EcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) is\ncalled subsequently for the same wakeup source, the ECU Manager module shall not\nrestart the wakeup validation timeout.⌋()\nIf only one timer is used, the following approach is proposed:\nIf EcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) is called for a wakeup source\nthat did not yet fire during the same wakeup cycle then the ECU Manager module\nshould prolong the validation timeout of that wakeup source.\n62 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "213": {
    "node_id": "c21807c2-de42-4ea6-bc6d-0f6e3437638b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Wakeup timeouts are defined by configuration (seeEcuMValidationTimeout).\n\n#### Requirements for Drivers with Wakeup Sources\n\nThe driver must invoke EcuM_SetWakeupEvent (see [SWS_EcuM_02826] )\nonce when the wakeup event is detected and supply a EcuM_WakeupSource-\nType parameter identifying the source of the wakeup (see [SWS_EcuM_02165],\n[SWS_EcuM_02166] ) as specified in the configuration (seeEcuMWakeupSourceId\n).\n[SWS_EcuM_02572] ⌈The ECU Manager module shall detect wakeups that occurr\nprior to driver initialization, both from Halt/Poll or from OFF .⌋()\nThe driver must provide an API to configure the wakeup source for the SLEEP state, to\nenable or disable the wakeup source, and to put the related peripherals to sleep. This\nrequirement only applies if hardware provides these capabilities.\nThe driver should enable the callback invocation in its initialization function.\n\n### Requirements for Wakeup Validation\n\nIf the wakeup source requires validation, this may be done by any but only by one\nappropriate module of the basic software. This may be a driver, an interface, a handler,\nor a manager.\nValidation is done by calling the EcuM_ValidateWakeupEvent (see\n[SWS_EcuM_02829] ) function.\n[SWS_EcuM_02601] ⌈If the EcuM cannot determine the reset reason returned by the\nMcu driver, then the EcuM set a wakeup event for default wakeup source ECUM_\nWKSOURCE_RESET instead.⌋()\n\n### Wakeup Sources and Reset Reason\n\nThe ECU Manager module API only provides one type (EcuM_WakeupSourceType ,\nsee 8.2.3EcuM_WakeupSourceType ), which can describe all reasons why the ECU\nstarts or wakes up.\n[SWS_EcuM_02625] ⌈The ECU Manager module shall never invoke validation for the\nfollowing wakeup sources:\n•ECUM_WKSOURCE_POWER\n•ECUM_WKSOURCE_RESET\n•ECUM_WKSOURCE_INTERNAL_RESET\n63 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "214": {
    "node_id": "f7ac7f71-9873-445e-9b1d-32084ca4549c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "•ECUM_WKSOURCE_INTERNAL_WDG\n•ECUM_WKSOURCE_EXTERNAL_WDG.\n⌋()\n\n### Wakeup Sources with Integrated Power Control\n\nSLEEP can be realized by a system chip which controls the MCU’s power supply.\nTypical examples are CAN transceivers with integrated power supplies which switch\npower off at application request and switch power on upon CAN activity.\nThe consequence is that SLEEP looks like OFF to the ECU Manager module on this\ntype of hardware. This distinction is rather philosophical and not of practical impor-\ntance.\nThe practical impact is that a passive wakeup on CAN looks like a power on reset to the\nECU. Hence, the ECU will continue with the STARTUP sequence after a wakeup event.\nWakeup validation is required nonetheless and the system designer must consider the\nfollowing topics:\n•The CAN transceiver is initialized during one of the driver initialization blocks\n(under BswM control by default). This is configured or generated code, i.e. code\nwhich is under control of the system designer.\n•The CAN transceiver driver API provides functions to find out if it was the CAN\ntransceiver which started the ECU due to a passive wakeup. It is the system de-\nsigner’s responsibility to check the CAN transceiver for wakeup reasons and pass\nthis information on to the ECU Manager module by using theEcuM_SetWake-\nupEvent (see [SWS_EcuM_02826] ) and EcuM_ClearWakeupEvents (see\n[SWS_EcuM_02828] ) functions.\nThese principles can be applied to all wakeup sources with integrated power control.\nThe CAN transceiver only serves as an example.\n\n## Shutdown Targets\n\n\"Shutdown Targets\" is a descriptive term for all states ECU where no code is executed.\nThey are called shutdown targets because they are the destination states where the\nstate machine will drive to when the UP phase is left. The following states are shutdown\ntargets:\n•Off8\n•Sleep\n8The OFF state requires the capability of the ECU to switch off itself. This is not granted for all\nhardware designs.\n64 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "215": {
    "node_id": "c7c6a14f-59df-4447-9552-0d276badcb7e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "•Reset\nNote that the time at which a shutdown target is or can be determined is not neces-\nsarily the start of the shutdown. Since the BswM now controls most ECU resources,\nit will determine the time at which the shutdown target should be set and will set it,\neither directly or indirectly. The BswM must therefore ensure that, for example, the\nshutdown target must be changed from its default to ECUM_STATE_SLEEP before\ncalling EcuM_GoDownHaltPoll.\nIn previous versions of the ECU Manager module, sleep targets were treated specially,\nas the sleep modes realized in the ECU depended on the capabilities of the ECU.\nThese sleep modes depend on hardware and differ typically in clock settings or other\nlow power features provided by the hardware. These different features are accessible\nthrough the MCU driver as so-called MCU modes (see [10] ). There are also vari-\nous modalities for performing a reset which are controlled, or triggered, by different\nmodules:\n•Mcu_PerformReset\n•WdgM_PerformReset\n•Toggle I/O Pin via DIO / SPI\nThe ECU Manager module offers a facility to manage these reset modalities by to\ntracking the time and cause of previous resets. The various reset modalities will be\ntreated as reset modes, using the same mode facitlities as sleep.\nRefer to section 8.3.4 Shutdown Management for the shutdown management facility’s\ninterface definitions.\n\n### Sleep\n\n[SWS_EcuM_02188] ⌈No wakeup event shall be missed in the SLEEP phase. The\nHalt or Poll Sequences shall not be entered if a wakeup event has occurred in the Go\nSleep sequence.⌋()\n[SWS_EcuM_02957] ⌈The ECU Manager module may define a configurable set of\nsleep modes (seeEcuMSleepMode ) where each mode itself is a shutdown target.⌋()\n[SWS_EcuM_02958] ⌈The ECU Manager module shall allow mapping the MCU sleep\nmodes to ECU sleep modes and hence allow them to be addressed as shutdown tar-\ngets.⌋()\n[SWS_EcuM_04092] ⌈The ShutdownTarget Sleep shall put the all cores into sleep.⌋()\n65 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "216": {
    "node_id": "f0b87f6c-6c95-42a7-b309-3975a831179f",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Reset\n\n[SWS_EcuM_04005] ⌈The ECU Manager module shall define a configurable set of\nreset modes (seeEcuMResetMode and EcuM_ResetType ), where each mode itself\nis a shutdown target. The set will minimally contain targets for\n•Mcu_PerformReset\n•WdgM_PerformReset\n•Toggle I/O Pin via DIO / SPI\n⌋()\n[SWS_EcuM_04006] ⌈The ECU Manager module shall allow defining aliases for reset\ntargets (See EcuM180_Conf).⌋()\n[SWS_EcuM_04007] ⌈The ECU Manager module shall define a configurable set of\nreset causes (see EcuMShutdownCause and EcuM_ShutdownCauseType ). The\nset shall minimally contain targets for\n•ECU state machine entered a shutdown state\n•WdgM detected a failure\n•DCM requests shutdownI\nand the time of the reset.⌋()\n[SWS_EcuM_04008] ⌈The ECU Manager Module shall offer facilities to BSW modules\nand SW-Cs to\n•Record a shutdown cause\n•Get a set of recent shutdown causes\n⌋()\nSee also section 8.3.4 Shutdown Management.\n\n## Alarm Clock\n\nThe ECU Manager module provides an optional persistent clock service which remains\n\"active\" even during sleep. It thus guarantees that an ECU will be woken up at a\ncertain time in the future (assuming that the hardware does not fail) and provides clock\nservices for long-term activities (i.e. measured in hours to days, even years).\nGenerally, this service will be realized with timers in the ECU that can induce wakeups.\nIn some cases, external devices can also use a regular interrupt line to periodically\nwake the ECU up, however. Whatever the mechanism used, the service uses one\nwakeup source privately.\n66 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "217": {
    "node_id": "feecd2ef-12fe-4f09-9da0-1e337cabd379",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "The ECU Manager module maintains a master alarm clock whose value determines\nthe time at which the ECU will be woken up. Moreover the ECU manager manages an\ninternal clock, the EcuM clock, which is used to compare with the master alarm.\nNote that the alarm wakeup mechanisms are only relevant to the SLEEP phase. SW-\nCs and BSW modules can set and retrieve alarm values during the UP phase (and only\nduring the UP phase), which will be respected during the SLEEP phase, however.\nCompared to other timing/wakeup mechanisms that could be implemented using gen-\neral ECU Manager module facilities, the Alarm Clock service will not initiate the\nWakeupRestart Sequence until the timer expires. When the ECU Module detects that\nits timer has caused a wakeup event, it increments its timer and returns immediately to\nsleep unless the clock time has exceeded the alarm time.\n[SWS_EcuM_04069] ⌈When the Alarm Clock service is present (seeEcuMAlarm-\nClockPresent ) the EcuM Manager module shall maintain an EcuM clock whose\ntime shall be the time in seconds since battery connect.⌋()\n[SWS_EcuM_04086] ⌈The EcuM clock shall track time in the UP and SLEEP phases.⌋\n()\n[SWS_EcuM_04087] ⌈Hardware permitting, the EcuM clock time shall not be reset by\nan ECU reset.⌋()\n[SWS_EcuM_04088] ⌈There shall be one and only one wakeup source assigned to\nthe EcuM Clock (seeEcuMAlarmWakeupSource ).⌋()\n\n### Alarm Clocks and Users\n\nSW-Cs and BSW modules can each maintain an alarm clock (user alarm clock).\nEach user alarm clock (seeEcuMAlarmClock ) is associated with anEcuMAlarm-\nClockUser which identifies the respective SW-C or BSW module.\n[SWS_EcuM_04070] ⌈Each EcuM User shall have at most one user alarm clock.⌋()\n[SWS_EcuM_04071] ⌈An EcuM User shall not be able to set the value of another\nuser’s alarm clock.⌋()\n[SWS_EcuM_04072] ⌈The ECU Manager module shall set always the master alarm\nclock value to the value of the earliest user alarm clock value.⌋()\nThis means as well that when an EcuM User issues an abort on its alarm clock and that\nuser alarm clock determines the current master alarm clock value, the ECU Manager\nmodule shall set the master alarm clock value to the next earliest user alarm clock\nvalue.\n[SWS_EcuM_04073] ⌈Only authorized EcuM Users can set the EcuM clock time (see\nEcuMSetClockAllowedUsers ).⌋()\n67 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "218": {
    "node_id": "f60c032a-4bdc-4e15-80ee-dc4b7b4baf46",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Rationale for [SWS_EcuM_04073]: Generally EcuM Users shall not be able to set the\nEcuM clock time. The EcuM clock time can be set to an arbitrary time to allow testing\nalarms that take days to expire.\n\n### EcuM Clock Time\n\n[SWS_EcuM_04089] ⌈If the underlying hardware mechanism is tick based, the ECUM\nshall \"correct\" the time accordingly⌋()\n\n#### EcuM Clock Time in the UP Phase\n\nThe EcuM_MainFunction increments the EcuM clock during the UP Phase. It uses\nstandard OS mechanisms (alarms / counters) to derive its time. Note the difference\nin granularity between the counters and EcuM time, which is measured in seconds\n([SWS_EcuM_04069] ).\n\n#### EcuM Clock Time in the Sleep Phase\n\nThere are two alternatives to increment the EcuM clock during sleep depending on\nwhich sleep mode was selected (EcuMSleepModeSuspend parameter)\nWithin the Halt Sequence (see 7.5.2 Activities in the Halt Sequence) the GPT Driver\nmust be put in to a GPT_MODE_SLEEP to only configure those timer channels re-\nquired for the time base. It also requires the GPT to enable the timer based wakeup\nchannel using the Gpt_EnableWakeup API. Preferably the Gpt_StartTimer API will be\nset to 1 sec but if this value is not reachable the EcuM will need to be woken up more\noften to accumulate several timer wakeups until 1 sec has been accumulated to incre-\nment the clock value.\nWithin the Poll Sequence (see 7.5.3 Activities in the Poll Sequence) the EcuM clock can\nbe periodically updated during theEcuM_SleepActivity function using theEcuM_-\nSetClock function, assuming a notion of time is still available. The clock must only be\nincremented when 1 sec of time has been accumulated.\nIn both situations after the clock has been incremented during Sleep the ECU Manager\nmodule must evaluate if the master alarm has expired. If so the BswM will initiate a full\nstartup or set the ECU in Sleep again.\n[SWS_EcuM_04009] ⌈When leaving the Sleep state the ECU Manager Module will\nabort any active user alarm clock and the master alarm clock. This means that both\nclock induced and wakeups due to other events will result in clearing all alarms.⌋(SRS_-\nModeMgm_09187)\n68 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "219": {
    "node_id": "1861dc5f-256d-44a9-b368-580426b5788d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_04010] ⌈User alarms and the master alarm shall be cancelled during\nthe StartPreOS Sequence, in the WakeupRestart Sequence and the OffPreOS Se-\nquence.⌋(SRS_ModeMgm_09188)\n\n## MultiCore\n\nThe distribution of BSW modules onto different partitions was introduced.\nA partition can be seen as an independent section that is mapped on one core. So\nevery core (both in single and in multi core architectures) contains at least one but also\ncan contain arbitrary numbers of partitions. But no partition can span over more than\none core.\nThe BSW modules can be distributed over different partitions and therefore over differ-\nent cores. Some BSW modules as the BswM have to be included into every partition.\nOther modules like the OS or the EcuM have be included into one partition per core.\nAn example is shown in Figure 7.17.\nFigure 7.17: Partitions inside an ECU\nIn a multi core architecture the EcuM has to be distributed in a way, that one instance\nper core exists.\nThere is one designated master core in which the boot loader starts the master Ecu\nM viaEcuM_Init. The master EcuM starts some drivers, determines the Post Build\nconfiguration and starts all remaining cores with all their satellite EcuMs.\nEach EcuM now starts the core local OS and all core local BswMs (in every partition\nresides exactly one BswM).\n69 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "220": {
    "node_id": "971b567e-afaf-42d4-a5c0-2d5c3b1b53c9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "If the same image of EcuM is executed on every core of the ECU, the ECU Manager’s\nbehavior has to differ on the different cores. This can be accomplished by the ECU\nManager by testing first whether it is on a master or a slave core and act appropriately.\nThe ECU Manager module supports the same phases on a MultiCore ECU as are\navailable on conventional ECUs (i.e. STARTUP , UP , SHUTDOWN and SLEEP).\nIf safety mechanisms are used, The ECU State Manager has to run with full trust level.\nThis section uses previous ECU Manager terms for various ECU states, notably Run/\nPostRun. With flexible ECU management, the system integrator determines the ECU’s\nstates’ names and semantics. Methods to ensure a de-initialization phase must be\nupheld, however. The names used here are therefore not normative.\n\n### Master Core\n\nThere is one explicit master core. Which core the master core is, is determined by\nthe boot loader. The EcuM of the master core gets started as first BSW module and\nperforms initialization actions.\nThen is starts all other cores with all other EcuMs.\nWhen these are started, it initializes together with each satellite EcuM the core local\nOS and BswM.\n\n### Slave Core\n\nOn every slave core, one satellite EcuM has to run. If a core contains more than one\npartition, only on EcuM per core has to exist.\n\n### Master Core - Slave Core Signalling\n\nThis section discusses the general mechanisms with which BSW can communicate\nover cores. It presupposed general knowledge of the SchM, which is described and\nspecified in the RTE.\n\n#### BSW Level\n\nThe Operating System provides a basic mechanism for synchronizing the starts of the\noperating systems on the master and slave cores. The Scheduler Manager provides\nbasic mechanisms for communication of BSW modules across partition boundaries.\nOne BSW Mode Manager per core is responsible for starting and stopping the RTE.\n70 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "221": {
    "node_id": "5673ab94-bfbf-4652-a765-e9546d82e4d9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Refer to the Guide to Mode Management [23] for a more complete description of the\nsolution approaches and for a discussion of the considerations in choosing between\nthem.\n\n#### Example for Shutdown Synchronization\n\nBefore calling ShutdownAllCores, the \"master\" ECU Manager Module must start\nthe shutdown of all \"slave\" ECU Manager Modules and has to wait until all modules\nhave de-initialized the BSW modules for which they are responsible and successfully\nshutdown.\nTherefore the master ECU Manager Module sets a shutdown flag which can be read by\nall slave modules. The EcuM activates afterwards tasks for every configured slave core.\nThe slave modules read the flag inside the main routine and shutdown if requested.\nThe task name is \"EcuM_SlaveCore<X>_Task\", where X is a number. The task need\nto be configured by the integrator. The number of tasks which need to be activated can\nbe calculated by counting the instances of EcuMPartitionRef minus one, because one\nEcuMFlexPartionRef is used for the master.\nExample: Three instances of EcuMPartitionRef are configured. Then during call of\nEcuM_GoDownHaltPoll() \"EcuM_SlaveCore1_Task\" and \"EcuM_SlaveCore2_Task\"\nwould be started. The slave modules read the flag inside the main routine and shut-\ndown if requested.\nThe Operating System extends the OSEK SetEvent function across cores. A task on\none core can wait for an event set on another core. Figure 18 illustrates how this ap-\nplies to the problem of synchronizing the cores before callingShutdownAllCores\n(whereby the de-initialization details have been omitted). The Set/WaitEvent functions\naccept a bitmask which can be used to indicate shutdown-readiness on the individ-\nual slave cores. Each SetEvent call from a \"slave\" ECU Manager module will stop\nthe \"master\" ECU Manager module’s wait. The \"master\" ECU Manager module must\ntherefore track the state of the individual slave cores and set the wait until all cores\nhave registered their readiness.\nThe WaitEvent() function can be replaced by a GetEvent() loop if the caller already has\ntaken a resource or spinlock.\n71 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "222": {
    "node_id": "d76b9a7a-61cc-4c3a-b245-2d3ca2b4da4a",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0005 \u0006 \u0007 \b \t \n \u000b \n \f \n \n \u000e \f \u000b \n \u000f \t\n\u000f \t\n\u0010\n\f\n\u0011\n\u000b \u0006\n\u0012 \u0013\n\u000f\n\u0012\n\u0006\nSlave Core nMaster Core\n«module»\nMaster: EcuM\n«module»\nSlave n: EcuM\n«module»\n:McOs\n«module»\n:BswM\n«module»\nMaster: McOs\n«module»\nSlave n: SchM\nalt loop until all cores done\n[resource or spinlock already taken]\n\u0002 \u0014 \u0015 \u000b \u0016 \u000f \u0017 \t \u0018 \n \f \u0019 \n\u0011 \u0012\n\u0006 \f \u0016\n\u001a \u001b\n\u000b \u0014 \u0006\n\u0011\n\n \f\n\u001c\n\u0006\n\u001d\n\u000f\n\u0012\n\u0006\n\u001e \t\n\u0011\n\u0006 \u000b \u000b \u0014 \u0006\n\u0011\n\u0014 \u0015 \u000b \u0016 \u000f \u0017 \t \u0018 \n \f \u0019\n\u0001 \u0002 \u0003 \u0005 \u0006 \u0007 \b \t \n \u000b \n \f \n \n \u000e \f \u000b \n \u000f \t \u000f \t\n\u0002 \n \f\n\u001c\n\u0006\n\u0013\n\u000f\n\u0012\n\u0006\n\u0002 \u0006 \u000b \f\n\u0011\n\u0014 \u0015 \u000b \u0016 \u000f \u0017 \t \u0018 \n \f \u0019\n\u0017 \u0014 \n\u001d\n\u0014\n\u001d\n\f \t\n\u001a\n\u0006\n\u0012\n\u0006 \f \u0016\n\u001a \u001b\n\f \n \n \u001f\n\u001d\n\u0015\n\u0010 \u0011\n\u000f \u0018 \f \n \n\n\u0011\n\n \f\n\u001c\n\u0006\n\u001d\n\u000f\n\u0012\n\u0006\n\u0011\nGetEvent(Mask)\nShutdownAllCores(StatusType)\nSetEvent(TaskId, Mask)\nEcuM_GoDownHaltPoll\n(Std_ReturnType, EcuM_UserType)\nEcuM_MainFunction()\nWaitEvent(Mask)\nFigure 7.18: Master / Slave Core Shutdown Synchronization (this is an example)\nNote: Figure 7.18 is an example of the logical control flow on the master core. The API\nEcuM_GoDownHaltPoll needs to be offered on every core managed by the EcuM.\nThe behavior of this function on slave cores is implementation specific.\nIntegration note: If synchronization between master and slave cores is achieved by\nmeans SetEvent/WaitEvent, then EcuM_GoDownHaltPoll will be called by the\n72 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "223": {
    "node_id": "fdb0d3c1-1b07-49f8-9efc-8bdb898b2967",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "BswM in the context of its main function task (deferred processing of mode arbitration).\nThis additionally requires that the main function task is an extended task.\n\n### UP Phase\n\nFrom the hardware perspective, it is possible that wakeup interrupts could occur on all\ncores. Then the whole ECU gets woken up and the EcuM running on that processes\nthe wakeup event.\n[SWS_EcuM_04011] ⌈The EcuM_MainFunction shall run in all EcuM instances.⌋()\n[SWS_EcuM_04012] ⌈Each instance of the ECU Manager module shall process the\nwakeup events of its core.⌋()\nAs in the single-core case, the BswM (as configured by the integrator) has the respon-\nsibility for controlling ECU resources, establishing that the local core can be powered\ndown or halted as well as de-initializing the appropriate applications and BSW before\nhanding control over to the EcuM of its core.\n\n### STARTUP Phase\n\nThe ECU Manager module functions nearly identically on all cores. That is, as for the\nsingle-core case, the ECU Manager module performs the steps specified for Startup;\nmost importantly starting the OS, initializing the SchM and starting the core local\nBswMs.\nThe master EcuM activates all slave cores after calling InitBlock 1 and doing the reset\n/ wakeup housekeeping. After being activated, the slave cores execute their startup\nroutines, which callEcuM_Init on their core.\n[SWS_EcuM_04146] ⌈If EcuMEcucCoreDefinitionRef is missing then the initial-\nization call shall only be performed on the master core.⌋()\nNote: If you need to initialize a module on multiple cores you have to add the module\nfor each core to the specific initialization list. Please be aware that in such cases the\ninit() function might be called in parallel from different cores and init() functions are\nnormally defined to be non-reentrant.\nAfter each EcuM has called StartOs on its core, the OS synchronizes the cores before\nexecuting the core-individual startup hooks and synchronizes the cores again before\nexecuting the first tasks on each core.\nStartPostOS is executed on each core and the SchM is initialized on each core. All\ncore local BswMs are initialized by each EcuM.\nOne BswM on every partition has to start the RTE for that core.\n73 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "224": {
    "node_id": "b1a2a15c-75d7-47b4-b0c9-847b72ec1093",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_04093] ⌈The ECU Manager module shall start the SchM and the OS on\nevery core.⌋()\n[SWS_EcuM_04014] ⌈The ECU Manager module shall callBswM_Init for all core\nlocal BswMs on the master and all slave cores.⌋()\n\n#### Master Core STARTUP\n\n[SWS_EcuM_04015] ⌈\n74 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "225": {
    "node_id": "015a3a61-d256-45d9-8cfd-ecfea68be056",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nOs\n«module»\nMcu\n«module»\nEcuM\nIntegration Code «module»\nMcOs\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u0001\nopt Configuration data inconsistent\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u000b\n\f \n\n\u0003\n\u000e\n\t\n\u000f\n\u0007 \u0007 \u0002\n\u0010 \u0011 \u0010 \u0012 \u0012 \u0010\n\u0004\n\u0013 \u0012\n\u0002\n\u000e \u0014\nloop FOR all configured cores\nStartOS(ECUM_DEFAULT_APP_MODE)\nEcuM_ErrorHook(ECUM_E_CONFIGURATION_DATA_INCONSISTE NT)\nStartCore(CoreIdType,\nStatusType**)\nEcuM_AL_DriverInitZero()\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nMcu_GetResetReason(Mcu_ResetType)\nCheck consistency of configuration\ndata()\nMap reset reason to wakeup\nsource()\nGetCoreID(CoreIdType)\nEcuM_DeterminePbConfiguration(const\nEcuM_ConfigType*)\nEcuM_LoopDetection()\nMcu_GetResetReason()\nEcuM_AL_DriverInitOne()\nFigure 7.19: Master Core StartPreOS Sequence\n⌋\n()\n[SWS_EcuM_04016] ⌈\n75 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "226": {
    "node_id": "d2983f19-1758-4c0e-a2dc-0dc2988779cc",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nSchM\n«module»\nEcuM\n«module»\nBswM\n«module»\nMcOs\nloop over every BswM running in this core\nBswM_Init(const BswM_ConfigType *)\nSchM_Start():\nStd_ReturnType\nGetCoreID(CoreIdType)\nSchM_StartTiming(const SchM_ConfigType*)\nSchM_Init(const SchM_ConfigType*)\nFigure 7.20: Master Core StartPostOS Sequence\n⌋\n()\n\n#### Slave Core STARTUP\n\n[SWS_EcuM_04145] ⌈The EcuM EcuM_AL_DriverInitZero and EcuM_AL_-\nDriverInitOne functions shall be called by theEcuM_Init function on each core.\nThe implementation of these callout functions shall ensure that only those MCAL mod-\nules are initialized that run on the currently active core.⌋()\n[SWS_EcuM_04017] ⌈\n76 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "227": {
    "node_id": "de99fad8-7ccd-4f03-96c5-61e52e6cef69",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nOs\n«module»\nEcuM\n«module»\nMcOs\nIntegration Code\nopt Configuration data inconsistent\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u000b\n\f \n\n\u0003\n\u000e\n\t\n\u000f\n\u0007 \u0007 \u0002\n\u0010 \u0011 \u0010 \u0012 \u0012 \u0010\n\u0004\n\u0013 \u0012\n\u0002\n\u000e \u0014\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u0015\nStartOS(ECUM_DEFAULT_APP_MODE)\nEcuM_DeterminePbConfiguration(EcuM_ConfigType*)\nEcuM_AL_DriverInitOne(const EcuM_ConfigType*)\nEcuM_AL_DriverInitZero()\nGetCoreID(CoreIdType)\nEcuM_ErrorHook(ECUM_E_CONFIGURATION_DATA_INCONSISTE NT)\nFigure 7.21: Slave Core StartPreOS Sequence\n⌋\n()\n[SWS_EcuM_04018] ⌈\n77 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "228": {
    "node_id": "464a2a7d-6bec-46cc-8f82-ac4582e3cc0d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nSchM\n«module»\nEcuM\n«module»\nBswM\n«module»\nMcOs\nloop over every BswM running in this core\nGetCoreID(CoreIdType)\nSchM_Start():\nStd_ReturnType\nBswM_Init(const BswM_ConfigType *)\nSchM_Init(const SchM_ConfigType*)\nSchM_StartTiming()\nFigure 7.22: Slave Core StartPostOS Sequence\n⌋\n()\n\n### SHUTDOWN Phase\n\nIndividual core shutdown (i.e. while the rest of the ECU continues to run) is currently\nnot supported. All cores are shut down simultaneously.\nWhen the ECU shall be shut down, the master ECU Manager module callsShutdow-\nnAllCores rather than somehow callingShutdownOS on the individual cores. The\nShutdownAllCores stops the OS on all cores and stops all cores as well.\nSince the master core could issue theShutdownAllCores before all slave cores are\nfinished processing, the cores must be synchronized before entering SHUTDOWN.\nThe BswM (which is distributed over all partitions) ascertains that the ECU should\nbe shut down and synchronizes with each BwsM in the ECU. All BswMs induce de-\ninitialization of all the partition’s BSWs, SWCs and CDDs and send appropriate signals\nto the other BswMs to indicate their readiness to shut down.\n78 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "229": {
    "node_id": "9e84a089-c022-4efd-874f-183abe5c3239",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "For a shutdown of the ECU, the BswM (which lies in the same partition of the master\nEcuM) ultimately calls GoOff on the master core which distributes that request to all\nslave cores. The \"master\" EcuM de-initializes the BswM, and the SchM. The EcuMs\non the slave cores de-initialize their SchM and BswM and then send a signal to indicate\nthat the core is ready for ShutdownOS (again, see section section 7.9.3 Master Core -\nSlave Core Signalling for details).\nThe master EcuM waits for the signal from each slave core EcuM and then initiates\nshutdown as usual on the master core (the master EcuM callsShutdownAllCores,\nand the ECU is put to bed with the global shutdown hook)\n79 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "230": {
    "node_id": "369cb915-802a-4491-967e-ee1376ac21fb",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### Master Core SHUTDOWN\n\n«module»\nEcuM\n«module»\nSchM\n«module»\nBswM\n«module»\nMcOs\nIntegration Code\nopt Pending wakeup events?\nloop over every BswM running in this core\nloop FOR all configured cores\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0005 \u0007 \u0004 \u0003 \u0007 \b \u0005 \t \n \u000b \u0002 \f \n \u000e \u000f\nEcuM_OnGoOffOne()\nShutdownAllCores(StatusType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nBswM_Deinit()\nWaitEvent(Mask)\nSchM_Deinit()\nGetCoreID(CoreIdType)\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nFigure 7.23: Master Core OffPreOS Sequence\n80 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "231": {
    "node_id": "112cf2fa-80c4-4393-bd3b-f4dd35ecca1c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_04020] ⌈\nIntegration Code«module»\nEcuM\n«module»\nMcOs\nalt Shutdown Target\n[Reset]\n[Off]\nGetCoreID(CoreIdType)\nEcuM_AL_SwitchOff()\nEcuM_AL_Reset(EcuM_ResetType)\nEcuM_OnGoOffTwo()\nFigure 7.24: Master Core OffPostOS Sequence\n⌋\n()\n81 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "232": {
    "node_id": "5e03bb58-94be-4602-b4ee-d15fa794f3c5",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### Slave Core SHUTDOWN\n\n«module»\nEcuM\n«module»\nMcOs\n«module»\n:SchM\nIntegration Code «module»\nBswM\nloop over every BswM running in this core\nSetEvent(TaskId, Mask)\nGetCoreID(CoreIdType)\nSchM_Deinit()\nBswM_Deinit()\nEcuM_OnGoOffOne()\nFigure 7.25: Slave Core OffPreOS Sequence\n[SWS_EcuM_04022] ⌈\n82 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "233": {
    "node_id": "3f94aa9f-1cd0-4343-a420-8adc8f811e18",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n«module»\nMcOs\nIntegration Code\nEcuM_OnGoOffTwo()\nGetCoreID(CoreIdType)\nFigure 7.26: Slave Core OffPostOS Sequence\n⌋\n()\n\n### SLEEP Phase\n\nWhen the shutdown target Sleep is requested, all cores are put to sleep simultaneously.\nThe MCU must issue a halt for each core. As task timing and priority are local to a\ncore in the OS, neither the scheduler nor the RTE must be synchronized after a halt.\nBecause the master core could issue the MCU halt before all slave cores are finished\nprocessing, the cores must be synchronized before entering GoHalt.\nThe BswMs ascertain that sleep should be initiated and distribute an appropriate ECU\nmode to each core. The BSWs, SWCs and CDDs on the slave cores must be informed\nby their partition local BswM, de-initialize appropriately and send appropriate mode\nrequests to the BswM to indicate their readiness.\nIf the ECU is put to sleep, the \"halt\"s must be synchronized so that all slave cores are\nhalted before the master core computes the checksum. The ECU Manager module on\nthe master core uses the same \"signal\" mechanism as for synchronizing cores on Go\nOff.\nSimilarly, the ECU Manager module on the master core must validate the checksum\nbefore releasing the slave cores from the \"halt\" state\n83 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "234": {
    "node_id": "4247bb0e-4e57-4e0b-a63e-9cc4e71085bd",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### Master Core SLEEP\n\n[SWS_EcuM_04023] ⌈\n«module»\nEcuM\n«module»\nOs\nIntegration Code «module»\n:BswM\nGetCoreID(CoreIdType)\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_NONE )\nFigure 7.27: Master Core GoSleep Sequence\n⌋\n()\n[SWS_EcuM_04024] ⌈\n84 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "235": {
    "node_id": "1fcc6c4a-f79e-4384-b928-2af5a838aaf3",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \b \t \n \u000b \n \f \f \n \n \u000e \f \t \u0004 \u000f\nIntegration Code «module»\n:BswM\n«Peripheral»\nWakeup Source\n«module»\nMcu\n«module»\nEcuM\n«module»\nWakeup Source\n«module»\nOs",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "236": {
    "node_id": "ae3640b9-240a-43c6-a835-105073c4d1e9",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "opt RAM check failed\nalt Validation Needed\n[Yes]\n[No]\nalt AlarmClock Service Present\n[EcuM_AlarmClock only pending event AND Alarm not expired]\n\u0010 \u0011 \u0012 \u0013\n\n \n \u000e \f \t \u0004 \n\n\u0014 \u0015\n\u0007 \b \n\n\u0016 \u0010 \u0017\n\n \u0006 \u000e \n \u0003\n\u0014\n\t\n\u0006\n\u0014\n\t \n \u0003 \t \u000e \n \u0004 \u0018 \u0003 \n \u0002 \n \u0002 \n \u0003 \t \n \n \f \f \u000e \u0019 \n \u0007 \u001a\n\u0014\n\u000b \n \u001b\nEcuM_GenerateRamHash()\nEcuM_CheckRamHash(uint8)\nReturn from\ninterrupt()\nWait for all SlaveCores to be ready to\nsleep()\nEcuM_ErrorHook(uint16)\nMcu_SetMode()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nSignal all SlaveCores\nto continue()\nDisableAllInterrupts()\n<Module>_CheckWakeup()\nBswM_EcuM_CurrentWakeup(Sources,\nECUM_WKSTATUS_VALIDATED)\nMcu_SetMode(Mcu_ModeType)\nInterrupt()\nEcuM_GenerateRamHash()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_PENDING)\nActivate\nPLL()\nFigure 7.28: Master Core Halt Sequence\n85 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "237": {
    "node_id": "ecb9dda4-afce-4062-b4fc-6d46f70dc827",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "⌋(SRS_ModeMgm_09239)\n[SWS_EcuM_04025] ⌈\n«module»\nEcuM\n«module»\n:BswM\nIntegration Code «module»\nMcu\n«module»\nWakeup Source\n«module»\nOs\nloop WHILE no pending/validated events\nloop FOR all wakeup sources that need polling\nopt Wakeup detected\nalt \n[Yes]\n[No]\n\u0001 \u0002 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0007 \b \n \u0005 \u0006 \u000b \u0003 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0004 \u0005 \f \u0005 \u0005 \n \u000e \u000f \u0010 \u0003 \b \u0011 \u0012 \u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0017 \u0011 \u0013 \u0018 \u0003 \u0015 \u0011 \u0019 \u0013 \u0011 \u001a \u0011 \u0006 \u0004 \u0001 \u001b \u001c\n\u001d\n\u0015\n\u001e \u001f  \n\u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0005 \u0006 \b\n!\n\n \u0011 \u0006 \u0002 \u0003 \u0006\n\"\n\u0011 \u0018 \u0011 \u0006 \u0004 \u0001 \u001b \u001c \u0001 \b \u0007 \u0013 \u0014 \u0006 \u0005 \u0004 \u0011\n#\n\n \u0003 \u0013 \u0011 \u0002\n$\nEnableAllInterrupts()\nSignal SlaveCores to\ncontinue()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEcuM_SleepActivity()\n<Module>_CheckWakeup()\nMcu_SetMode\n(Mcu_ModeType)\nBswMEcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_VALIDATED)\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_PENDING)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nFigure 7.29: Master Core Poll Sequence\n⌋\n()\n[SWS_EcuM_04026] ⌈\n86 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "238": {
    "node_id": "1f376637-9db9-4054-9cb0-c976818b9a84",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nMcu\n«module»\nOs\n«module»\nEcuM\nIntegration Code\nMcu_SetMode(Mcu_ModeType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nEcuM_AL_DriverRestart()\nFigure 7.30: Master Core WakeupRestart Sequence\n⌋\n()\n\n#### Slave Core SLEEP\n\n[SWS_EcuM_04027] ⌈\n87 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "239": {
    "node_id": "52b2e6c3-e58c-49ec-848d-fe3e0712849f",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n«module»\nOs\n«module»\n:BswM\nIntegration Code\nGetCoreID(CoreIdType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_NONE )\nFigure 7.31: Slave Core GoSleep Sequence\n⌋\n()\n[SWS_EcuM_04028] ⌈\n88 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "240": {
    "node_id": "214a2bbd-b35f-418b-b8e4-75392cf4e10e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Integration Code «module»\nWakeup Source\n«module»\nEcuM\n«module»\nMcu\n«Peripheral»\nWakeup Source\n«module»\nOs\n«module»\n:BswM",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "241": {
    "node_id": "b5d490ca-ea44-4dc6-8be5-986e6aef917f",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "alt Validation Needed\n[Yes]\n[No]\nMcu_SetMode()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nInterrupt()\nSignal MasterCore that Slave is ready to sleep()\nReturn from\ninterrupt()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nBswM_EcuM_CurrentState(ECUM_WKSTATUS_PENDING)\nWait for MasterCore to continue()\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(Sources, ECUM_WKSTATUS_VALI DATED)\n<Module>_CheckWakeup()\nEnableAllInterrupts()\nMcu_SetMode(Mcu_ModeType)\nFigure 7.32: Slave Core Halt Sequence\n⌋\n()\n[SWS_EcuM_04029] ⌈\n89 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "242": {
    "node_id": "6b8bc870-b884-40c8-822c-4ee7b37577f9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n«module»\nWakeup Source\n«module»\nMcu\nIntegration Code «module»\nOs\n«module»\nBswM\nloop WHILE no pending/validated events\nloop FOR all wakeup sources that need polling\nopt Wakeup detected\nalt \n[Yes]\n[No]\n\u0001 \u0002 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0007 \b \n \u0005 \u0006 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u000b \u0004 \u0005 \f \u0005 \u0005 \n \u000e\n\u000f \u0010\n\u0003 \b\n\u0011 \u0012\n\u0001 \b \u0007\n\u0013 \u0014\n\n \b \u0005\n\u0015 \u0016 \u0017 \u0011 \u0013 \u0018\n\u0003\n\u0015 \u0011 \u0019 \u0013 \u0011\n\u000b\n\u0011\n\u0006 \u0004\n\u0001 \u001a \u001b \u001c\n\u0015\n\u001d \u001e \u001f \u0001 \b \u0007\n\u0013 \u0014\n\n \b \u0005\n\u0015 \u0016\n\u0005 \u0006 \b  \n\n\u0011\n\u0006 \u0002 \u0003 \u0006 !\n\u0011 \u0018\u0011\n\u0006 \u0004\n\u0001 \u001a \u001b \u0001 \b \u0007\n\u0013 \u0014\n\u0006 \u0005 \u0004\n\u0011 \"\n\n \u0003\n\u0013 \u0011\n\u0002\n#\nMcu_SetMode(Mcu_ModeType)\nWait for signal from MasterCore to continue()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\n<Module>_CheckWakeup()\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_PEND ING)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_VALI DATED)\nEcuM_SleepActivity()\nFigure 7.33: Slave Core Poll Sequence\n⌋\n()\n[SWS_EcuM_04030] ⌈\n90 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "243": {
    "node_id": "82c4073e-d1bc-4348-835c-797d199101ec",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nMcu\n«module»\nOs\n«module»\nEcuM\nIntegration Code\nMcu_SetMode(Mcu_ModeType)\nDisableAllInterrupts()\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nFigure 7.34: Slave Core WakeupRestart Sequence\n⌋\n()\n\n### Runnables and Entry points\n\n\n\n#### Internal behavior\n\n[SWS_EcuM_03018] ⌈The definition of the internal behavior of the the ECU Manager\nmodule shall be as follows. This detailed description is only needed for the configura-\ntion of the local RTE.\nInternalBehavior EcuStateManager {\n// Runnable entities of the EcuStateManager\nRunnableEntity SelectShutdownTarget\nsymbol \"EcuM_SelectShutdownTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetShutdownTarget\n91 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "244": {
    "node_id": "a6650138-e319-4cf7-8366-04326866c1da",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "symbol \"EcuM_GetShutdownTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetLastShutdownTarget\nsymbol \"EcuM_GetLastShutdownTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SelectShutdownCause\nsymbol \"EcuM_SelectShutdownCause\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetShutdownCause\nsymbol \"EcuM_GetShutdownCause\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SelectBootTarget\nsymbol \"EcuM_SelectBootTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetBootTarget\nsymbol \"EcuM_GetBootTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SetRelWakeupAlarm\nsymbol \"EcuM_SetRelWakeupAlarm\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SetAbsWakeupAlarm\nsymbol \"EcuM_SetAbsWakeupAlarm\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity AbortWakeupAlarm\nsymbol \"EcuM_AbortWakeupAlarm\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetCurrentTime\nsymbol \"EcuM_GetCurrentTime\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetWakeupTime\nsymbol \"EcuM_GetWakeupTime\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SetClock\nsymbol \"EcuM_SetClock\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity RequestRUN\nsymbol \"EcuM_RequestRUN\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity ReleaseRUN\nsymbol \"EcuM_ReleaseRUN\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity RequestPOSTRUN\nsymbol \"EcuM_RequestPOST_RUN\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity ReleasePOSTRUN\nsymbol \"EcuM_ReleasePOST_RUN\"\ncanbeInvokedConcurrently = TRUE\n// Port present for each user. There are NU users\nSR000.RequestRUN -> RequestRUN\nSR000.ReleaseRUN -> ReleaseRUN\nSR000.RequestPOSTRUN -> RequestPOSTRUN\nSR000.ReleasePOSTRUN -> RequestPOSTRUN\nPortArgument {port=SR000, value.type=EcuM_UserType,\nvalue.value=EcuMUser[0].User }\n92 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "245": {
    "node_id": "55140578-2768-4f06-a1a7-4d3f5d4498cc",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "(...)\nSRnnn.RequestRUN -> RequestRUN\nSRnnn.ReleaseRUN -> ReleaseRUN\nSRnnn.RequestPOSTRUN -> RequestPOSTRUN\nSRnnn.ReleasePOSTRUN -> RequestPOSTRUN\nPortArgument {port=SRnnn, value.type=EcuM_UserType,\nvalue.value=EcuMUser[nnn].User }\nshutDownTarget.SelectShutdownTarget -> SelectShutdownTarget\nshutDownTarget.GetShutdownTarget -> GetShutdownTarget\nshutDownTarget.GetLastShutdownTarget -> GetLastShutdownTarget\nshutDownTarget.SelectShutdownCause -> SelectShutdownCause\nshutDownTarget.GetShutdownCause -> GetShutdownCause\nbootTarget.SelectBootTarget -> SelectBootTarget\nbootTarget.GetBootTarget -> GetBootTarget\nalarmClock.SetRelWakeupAlarm-> SetRelWakeupAlarm\nalarmClock.SetAbsWakeupAlarm -> SetAbsWakeupAlarm\nalarmClock.AbortWakeupAlarm -> AbortWakeupAlarm\nalarmClock.GetCurrentTime -> GetCurrentTime\nalarmClock.GetWakeupTime -> GetWakeupTime\nalarmClock.SetClock -> SetClock\n};\n⌋()\n\n## EcuM Mode Handling\n\nThe ECU State Manager provides interfaces for SW-Cs to request and release the\nmodes RUN and POST_RUN optionally.\nEcuMFlex arbitrates the requests and releases made by SW-Cs and propagates the\nresult to BswM. The cooperation between EcuM and BswM is necessary as only the\nBswM can decide when a transition to a different mode can be made. Due to the\nfact that the EcuM does not have an own state machine, the EcuM relies on the state\ntransitions made by BswM. Therefore the EcuM does not request a state. Furthermore\nit notifies the BswM about the current arbitration of all requests. And the BswM is\nnotified when the RTE has executed all Runnables belonging to a certain mode.\nArchitecturalComponentsofECUModeHandling\n93 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "246": {
    "node_id": "d4277d7d-911d-44dd-be93-54af4793e49e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Figure 7.35: Architectural Components of ECU Mode Handling\nFigure 7.35 illustrates the architectural components of ECU Mode Handling.\n[SWS_EcuM_04115] ⌈ECU Mode Handling shall be applied whenEcuMModeHan-\ndling is configured to true.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04116] ⌈When the BswM sets a state of the EcuM byEcuM_SetState,\nthe EcuM shall indicate the corresponding mode to the RTE.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04117] ⌈When the last RUN request has been released, ECU\nState Manager module shall indicate this to BswM using the API BswM_EcuM_-\nRequestedState(ECUM_STATE_APP_RUN, ECUM_RUNSTATUS_RELEASED).⌋\n(SRS_ModeMgm_09116)\nIf a SW-C needs post run activity during POST_RUN (e.g. shutdown preparation),\nthen it must request POST_RUN before releasing the RUN request. Otherwise it is not\nguaranteed that this SW-C will get a chance to run its POST_RUN code.\n[SWS_EcuM_04118] ⌈When the ECU State Manager is not in the state which is re-\nquested by a SWC, it shall inform BswM about requested states using theBswM_-\nEcuM_RequestedState API.⌋(SRS_ModeMgm_09116)\nPOST_RUN state provides a post run phase for SW-C’s and allows them to save im-\nportant data or switch off peripherals.\n[SWS_EcuM_04144] ⌈When the first RUN or POST_RUN request has been received,\nECU State Manager module shall indicate this to BswM usingBswM_EcuM_Request-\nedState(ECUM_STATE_APP_RUN, ECUM_RUNSTATUS_REQUESTED).⌋()\n[SWS_EcuM_04119] ⌈When the last POST_RUN request has been released, ECU\nState Manager module shall indicate this to BswM using the APIBswM_EcuM_Re-\nquestedState(ECUM_STATE_APP_POST_RUN, ECUM_RUNSTATUS_RELEASED).⌋\n(SRS_ModeMgm_09116)\n94 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "247": {
    "node_id": "1b7dd8f6-c083-4e2c-bbd0-072a91860d9f",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Hint: To prevent, that the mode machine instance of ECU Mode lags behind and the\nstates EcuM and the RTE get out of phase, the EcuM can use acknowledgement feed-\nback for the mode switch notification.\nNote that EcuM only requests Modes from and to RUN and POST_RUN, the SLEEP\nMode has to be set by BswM, as the EcuM has no information about when this Mode\ncan be entered.\nState Description\nSTARTUP Initial value. Set by Rte when\nRte_Start() has been called.",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "248": {
    "node_id": "36e97167-d1ac-46a5-be50-feaaebdea32c",
    "title": "RUN",
    "level": 2,
    "type": "clause",
    "content": "As soon as all necesseray BSW\nmodules are inistialized, BswM\nswitches to this Mode.\nPOST_RUN\nEcuM requests POST_RUN,\nwhen no RUN requests are\navailable.",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "249": {
    "node_id": "2383a991-f61e-4017-b95c-754e4a2c4063",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "EcuM requests SLEEP Mode\nwhen no RUN and POST_RUN\nrequests are available and Shut-\ndown Target is set to SLEEP .",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "250": {
    "node_id": "31439966-a034-4415-afe7-97fc116ff575",
    "title": "SHUTDOWN",
    "level": 2,
    "type": "clause",
    "content": "EcuM requests SHUTDOWN\nMode when no RUN and POST_\nRUN requests are available and\nShutdown Target is set to SHUT -\nDOWN.\nTable 7.8: EcuM Modes\n[SWS_EcuM_04143] ⌈EcuM shall notify BswM about the current State by calling the in-\nterface BswM_EcuM_CurrentState(EcuM_StateType State). A new state shall\nbe set by EcuM when RTE has given its feedback via the acknowledgement port.⌋()\n\n## Advanced Topics\n\n\n\n### Relation to Bootloader\n\nThe Bootloader is not part of AUTOSAR. Still, the application needs an interface to\nactivate the bootloader. For this purpose, two functions are provided:EcuM_Select-\nBootTarget and EcuM_GetBootTarget .\n95 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "251": {
    "node_id": "c0d2ee95-a348-407d-98cc-3d8d7b56a590",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Reset\nBoot Menu\nBoot Target\nBootloader\nApplication",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "252": {
    "node_id": "0c45e2c8-4d9e-4035-b0fc-a2a4750aa9e6",
    "title": "SS",
    "level": 2,
    "type": "clause",
    "content": "Bootloader\nFigure 7.36: Selection of Boot Targets\nBootloader, system supplier bootloader and application are separate program images,\nwhich in many cases even can be flashed separately. The only way to get from one\nimage to another is through reset. The boot menu will branch into the one or other\nimage depending on the selected boot target.\n\n### Relation to Complex Drivers\n\nIf a complex driver handles a wakeup source, it must follow the protocol for handling\nwakeup events specified in this document.\n\n### Handling Errors during Startup and Shutdown\n\n[SWS_EcuM_02980] ⌈The ECU Manager module shall ignore all types of errors that\noccur during initialization, e.g. values returned by init functions⌋()\nInitialization is a configuration issue (see EcuMDriverInitListZero , EcuM-\nDriverInitListOne and EcuMDriverRestartList ) and therefore cannot be\nstandardized.\nBSW modules are responsible themselves for reporting errors occurring during their ini-\ntialization directly to the DEM module or the DET module, as specified in their SWSs.\nThe ECU Manager module does not report the errors. The BSW module is also re-\nsponsible for taking any special measures to react to errors occurring during their ini-\ntialization.\n\n## ErrorHook\n\n[SWS_EcuM_04033] ⌈In the unrecoverable error situations defined in the first column\nof Table in [SWS_EcuM_04032], the ECU Manager module shall call theEcuM_Er-\nrorHook callout with the parameter value set to the corresponding related error code.⌋\n()\n96 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "253": {
    "node_id": "cdc86c0d-e8e0-4a71-9336-0b2eee15ec91",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Clarification to [SWS_EcuM_04033]: EcuM shall assume that theEcuM_ErrorHook\nwill not return (integrator’s code).\nClarification to [SWS_EcuM_04033]: In case a Dem error is needed, it is integrator’s\nresponsibility to define a strategy to handle it (e.g.: As EcuM does not directly call Dem,\nset the Dem error after a reset recovery).\n[SWS_EcuM_04139] ⌈If an OS function call fails and no other fault reaction is defined,\nthe EcuM shall not change the requested state. In such cases an error reporting via\nEcuM_ErrorHook shall be performed.⌋()\nNote: The exact error code used when callingEcuM_ErrorHook depends on the OS\nfunction and their return value and is not standardized.\n\n## Error classification\n\nSection \"Error Handling\" of the document [6] describes the error handling of the Basic\nSoftware in detail. Above all, it constitutes a classification scheme consisting of five\nerror types which may occur in BSW modules.\nBased on this foundation, the following section specifies particular errors arranged in\nthe respective subsections below.\nAUTOSAR BSW modules normally report their errors to Det (development errors) or\nDem (production errors).\nThe EcuM handles errors differently and does not report its errors to Dem/Det.\nIf a reporting of errors to Dem/Det is needed the user can perform these actions in the\nEcuM_ErrorHook .\nThe following subchapters contains all error codes which might be reported from the\nEcuM (besides those individual error codes defined by the integrator).\n\n### Development Errors\n\n[SWS_EcuM_04032] ⌈\nType of error Related error code Error value\nMultiple requests by the same user were detectedECUM_E_MULTIPLE_RUN_REQUESTS Assigned by\nImplementation\nA function was called which was disabled by\nconfiguration\nECUM_E_SERVICE_DISABLED Assigned by\nImplementation\nA service was called prior to initialization ECUM_E_UNINIT Assigned by\nImplementation\n▽\n97 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "254": {
    "node_id": "acc0306b-b453-40d6-b11e-b05b38f4cd13",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nType of error Related error code Error value\nAn unknown wakeup source was passed as a\nparameter to an API\nECUM_E_UNKNOWN_WAKEUP_SOURCE Assigned by\nImplementation\nThe initialization failed ECUM_E_INIT_FAILED Assigned by\nImplementation\nA state, passed as an argument to a service, was\nout of range (specific parameter test)\nECUM_E_STATE_PAR_OUT_OF_RANGE Assigned by\nImplementation\nA parameter was invalid (unspecific) ECUM_E_INVALID_PAR Assigned by\nImplementation\nA invalid pointer was passed as an argument ECUM_E_PARAM_POINTER Assigned by\nImplementation\nA previous matching request for the provided user\nwas not found\nECUM_E_MISMATCHED_RUN_RELEASE Assinged by\nImplementation\n⌋(SRS_BSW_00327, SRS_BSW_00337, SRS_BSW_00350, SRS_BSW_00385)\n\n### Runtime Errors\n\n[SWS_EcuM_91003] ⌈\nType of error Related error code Error value\nPostbuild configuration data is inconsistent ECUM_E_CONFIGURATION_DATA_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "255": {
    "node_id": "2938a217-fac9-48e2-963a-107ea1a494d9",
    "title": "INCONSISTENT",
    "level": 2,
    "type": "clause",
    "content": "Assigned by\nImplementation\nThe RAM check during wakeup failed ECUM_E_RAM_CHECK_FAILED Assigned by\nImplementation\n⌋()\n\n### Transient Faults\n\nThere are no transient faults.\n\n### Production Errors\n\nThere are no production errors.\n\n### Extended Production Errors\n\nThere are no extended production errors.\n98 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "256": {
    "node_id": "e19cd18a-0549-4ee6-ac51-53079b96ccf8",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# API specification\n\n\n\n## Imported Types\n\nThis section lists all types imported by the ECU Manager module from the correspond-\ning AUTOSAR modules.\n[SWS_EcuM_02810] ⌈\nModule Header File Imported Type\nAdc Adc.h Adc_ConfigType\nBswM BswM.h BswM_ConfigType\nCan Can.h Can_ConfigType\nCanTrcv CanTrcv.h CanTrcv_ConfigType\nComStack_Types.h NetworkHandleTypeComStack_Types\nComStack_Types.h PNCHandleType\nDem Dem.h Dem_ConfigType\nDet Det.h Det_ConfigType\nEth Eth.h Eth_ConfigType\nEthSwt EthSwt.h EthSwt_ConfigType\nEthTrcv EthTrcv.h EthTrcv_ConfigType\nFls Fls.h Fls_ConfigType\nFr Fr.h Fr_ConfigType\nFrTrcv FrTrcv.h FrTrcv_ConfigType\nGpt Gpt.h Gpt_ConfigType\nIcu Icu.h Icu_ConfigType\nIoHwAb IoHwAb.h IoHwAb<Init_Id>_ConfigType\nLin Lin.h Lin_ConfigType\nLinTrcv LinTrcv.h LinTrcv_ConfigType\nOs.h AppModeTypeMcOs\nOs.h CoreIdType\nMcu.h Mcu_ConfigType\nMcu.h Mcu_ModeType\nMcu\nMcu.h Mcu_ResetType\nOcu Ocu.h Ocu_ConfigType\nOs Os.h StatusType\nPort Port.h Port_ConfigType\nPwm Pwm.h Pwm_ConfigType\nSchM SchM.h SchM_ConfigType\nSpi Spi.h Spi_ConfigType\nStd_Types.h Std_ReturnTypeStd\nStd_Types.h Std_VersionInfoType\nWdg Wdg.h Wdg_ConfigType\n⌋()\n99 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "257": {
    "node_id": "1c8b321b-0a2d-4f6c-9991-e59a67192a7c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_03019] ⌈ECUM_E_EARLIER_ACTIVE and ECUM_E_PAST shall be of\ntype Std_ReturnType and represent the following values\n•ECUM_E_EARLIER_ACTIVE = 3\n•ECUM_E_PAST = 4\n⌋()\n\n## Type definitions\n\n\n\n### EcuM_ConfigType\n\n[SWS_EcuM_04038] ⌈\nName EcuM_ConfigType\nKind Structure\n-\nType –\nElements\nComment The content of this structure depends on the post-build configuration of\nEcuM.\nDescription A pointer to such a structure shall be provided to the ECU State Manager initialization routine for\nconfiguration.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02801] ⌈The structure defined by type EcuM_ConfigType shall hold the\npost-build configuration parameters for the ECU Manager module as well as pointers to\nall ConfigType structures of modules that are initialized by the ECU Manager module.⌋\n()\nThe ECU Manager module Configuration Tool must generate the structure defined by\nthe EcuM_ConfigType type specifically for a given set of basic software modules that\ncomprise the ECU configuration. The set of basic software modules is derived from\nthe corresponding EcuM parameters\n[SWS_EcuM_02794] ⌈The structure defined in the EcuM_ConfigType type shall con-\ntain an additional post-build configuration variant identifier (uint8/uint16/uint32 depend-\ning on algorithm to compute the identifier).⌋()\nSee also Chapter 7.3.4 Checking Configuration Consistency.\n[SWS_EcuM_02795] ⌈The structure defined by the EcuM_ConfigType type shall con-\ntain an additional hash code that is tested against the configuration parameterEcuM-\nConfigConsistencyHash for checking consistency of the configuration data.⌋()\nSee also section 7.3.4 Checking Configuration Consistency.\n100 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "258": {
    "node_id": "6079248d-ae58-4ce4-abe9-46c0a23be76b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "For each given ECU configuration, the ECU Manager module Configuration Tool must\ngenerate an instance of this structure that is filled with the post-build configuration pa-\nrameters of the ECU Manager module as well as pointers to instances of configuration\nstructures for the modules mentioned above. The pointers are derived from the corre-\nsponding EcuM parameters.\n\n### EcuM_RunStatusType\n\n[SWS_EcuM_04120] ⌈\nName EcuM_RunStatusType\nKind Type\nDerived from uint8\nECUM_RUNSTATUS_UNKNOWN 0 Unknown status. Init Value.\nECUM_RUNSTATUS_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "259": {
    "node_id": "85f3bfe9-b701-44f5-ac68-9f3b4b605f52",
    "title": "REQUESTED",
    "level": 2,
    "type": "clause",
    "content": "# Status requested from EcuM\n\nRange\nECUM_RUNSTATUS_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "260": {
    "node_id": "b9697ace-792d-4d28-a8a7-e05b5090b29a",
    "title": "RELEASED",
    "level": 2,
    "type": "clause",
    "content": "# Status released from EcuM.\n\nDescription Result of the Run Request Protocol sent to BswM\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04121] ⌈The ECU Manager module shall inform BswM about the state of\nthe Run Request Protocol as listed in the EcuM_RunStatusType.⌋(SRS_ModeMgm_-\n09116)\n\n### EcuM_WakeupSourceType\n\n[SWS_EcuM_04040] ⌈\nName EcuM_WakeupSourceType\nKind Type\nDerived from uint32\nECUM_WKSOURCE_POWER 0x01 Power cycle (bit 0)\nECUM_WKSOURCE_RESET\n(default)\n0x02 Hardware reset (bit 1).\nIf the Mcu driver cannot\ndistinguish between a power cycle\nand a reset reason, then this shall\nbe the default wakeup source.\n▽\n101 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "261": {
    "node_id": "37e42d8b-3c8e-46a6-b496-728c23af7b88",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nECUM_WKSOURCE_\nINTERNAL_RESET\n0x04 Internal reset ofµC (bit 2)\nThe internal reset typically only\nresets theµC core but not\nperipherals or memory controllers.\nThe exact behavior is hardware\nspecific. This source may also\nindicate an unhandled exception.\nECUM_WKSOURCE_\nINTERNAL_WDG\n0x08 Reset by internal watchdog (bit 3)\nECUM_WKSOURCE_\nEXTERNAL_WDG\n0x10 Reset by external watchdog (bit\n4), if detection supported by\nhardware\nDescription EcuM_WakeupSourceType defines a bitfield with 5 pre-defined positions (see Range). The bitfield\nprovides one bit for each wakeup source.\nIn WAKEUP , all bits cleared indicates that no wakeup source is known.\nIn STARTUP , all bits cleared indicates that no reason for restart or reset is known. In this case,\nECUM_WKSOURCE_RESET shall be assumed.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02165] ⌈Additional wakeup sources (to the pre-defined sources) shall be\nassigned individually to bitfield positions 5 to 31 by configuration. The bit assignment\nshall be done by the configuration tool.⌋()\n[SWS_EcuM_02166] ⌈The EcuMWakeupSourceId (see ECUC_EcuM_00151) field in\nthe EcuMWakeupSource container shall define the position corresponding to that\nwakeup source in all instances the EcuM_WakeupSourceType bitfield.⌋()\n\n### EcuM_WakeupStatusType\n\n[SWS_EcuM_04041] ⌈\nName EcuM_WakeupStatusType\nKind Type\nDerived from uint8\nECUM_WKSTATUS_NONE 0 No pending wakeup event was\ndetected\nECUM_WKSTATUS_PENDING 1 The wakeup event was detected\nbut not yet validated\nECUM_WKSTATUS_VALIDATED 2 The wakeup event is valid\nRange\nECUM_WKSTATUS_EXPIRED 3 The wakeup event has not been\nvalidated and has expired\ntherefore\nDescription The type describes the possible states of a wakeup source.\nAvailable via EcuM.h\n⌋() NOTE: This declaration has to be changed to a mode. The name has to be\nchanged.\n102 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "262": {
    "node_id": "076b6b65-a8db-4daa-9c0b-b9a269ba6748",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuM_ResetType\n\n[SWS_EcuM_04044] ⌈\nName EcuM_ResetType\nKind Type\nDerived from uint8\nECUM_RESET_MCU 0 Microcontroller reset via Mcu_\nPerformReset\nECUM_RESET_WDG 1 Watchdog reset via WdgM_\nPerformReset\nRange\nECUM_RESET_IO 2 Reset by toggeling an I/O line.\nDescription This type describes the reset mechanisms supported by the ECU State Manager. It can be\nextended by configuration.\nAvailable via EcuM.h\n⌋()\n\n### EcuM_StateType\n\n[SWS_EcuM_91005] ⌈\nName EcuM_StateType\nKind Type\nDerived from uint8\nECUM_SUBSTATE_MASK 0x0f –\nECUM_STATE_STARTUP 0x10 –\nECUM_STATE_RUN 0x32 –\nECUM_STATE_POST_RUN 0x33 –\nECUM_STATE_SHUTDOWN 0x40 –\nRange\nECUM_STATE_SLEEP 0x50 –\nDescription ECU State Manager states.\nAvailable via EcuM.h\n⌋(SRS_BSW_00331)\n[SWS_EcuM_02664] ⌈The ECU Manager module shall define all states as listed in the\nEcuM_StateType.⌋()\n\n## Function Definitions\n\nThis is a list of functions provided for upper layer modules.\n103 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "263": {
    "node_id": "d6ff67e8-0b69-4b37-b161-43fbf76dc945",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### General\n\n\n\n#### EcuM_GetVersionInfo\n\n[SWS_EcuM_02813] ⌈\nService Name EcuM_GetVersionInfo\nSyntax void EcuM_GetVersionInfo (\nStd_VersionInfoType* versioninfo\n)\nService ID [hex] 0x00\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) versioninfo Pointer to where to store the version information of this module.\nReturn value None\nDescription Returns the version information of this module.\nAvailable via EcuM.h\n⌋(SRS_BSW_00407, SRS_BSW_00411)\n\n### Initialization and Shutdown Sequences\n\n\n\n#### EcuM_GoDownHaltPoll\n\n[SWS_EcuM_91002] ⌈\nService Name EcuM_GoDownHaltPoll\nSyntax Std_ReturnType EcuM_GoDownHaltPoll (\nEcuM_UserType UserID\n)\nService ID [hex] 0x2c\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) UserID Id of the user calling this API. Only configured users are allowed\nto call this function.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_NOT_OK: The request was not accepted.\nE_OK: If the ShutdownTargetType is SLEEP the call successfully\nreturns, the ECU has left the sleep again.\nIf the ShutdownTargetType is RESET or OFF this call will not\nreturn.\nDescription Instructs the ECU State Manager module to go into a sleep mode, Reset or OFF depending on\nthe previously selected shutdown target.\n▽\n104 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "264": {
    "node_id": "7e24f7d9-8548-4ad3-92d7-acd45c2067f8",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_Init\n\n[SWS_EcuM_02811] ⌈\nService Name EcuM_Init\nSyntax void EcuM_Init (\nvoid\n)\nService ID [hex] 0x01\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Initializes the ECU state manager and carries out the startup procedure. The function will never\nreturn (it calls StartOS)\nAvailable via EcuM.h\n⌋(SRS_BSW_00358, SRS_BSW_00414, SRS_BSW_00101)\n\n#### EcuM_StartupTwo\n\n[SWS_EcuM_02838] ⌈\nService Name EcuM_StartupTwo\nSyntax void EcuM_StartupTwo (\nvoid\n)\nService ID [hex] 0x1a\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This function implements the STARTUP II state.\n▽\n105 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "265": {
    "node_id": "60b9d231-aa62-485b-9f98-78f122848dc4",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02806] ⌈Caveats of EcuM_StartupTwo: This function must be called\nfrom a task, which is started directly as a consequence of StartOS. I.e. either the\nEcuM_StartupTwo function must be called from an autostart task or the EcuM_Startup\nTwo function must be called from a task, which is explicitly started.⌋()\nClarification to [SWS_EcuM_02806] : The OS offers different mechanisms to activate\na task on startup. Normally EcuM_StartupTwo would be configured as an autostart\ntask in the default application mode.\nThe integrator can configure the OS to activate the EcuM_StartupTwo task by any\nmechanism, as long as it is started immediately after StartOS is called. The task can\nalso be activated from within another task and this other task could be an autostart\ntask.\nStarting EcuM_StartupTwo as an autostart task is an implicit activation. The other\nmechanisms would be an explicit activation.\n\n#### EcuM_Shutdown\n\n[SWS_EcuM_02812] ⌈\nService Name EcuM_Shutdown\nSyntax void EcuM_Shutdown (\nvoid\n)\nService ID [hex] 0x02\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Typically called from the shutdown hook, this function takes over execution control and will carry\nout GO OFF II activities.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09114)\n106 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "266": {
    "node_id": "01afcbd9-0d48-4974-ae30-3728b0b10138",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### State Management\n\n\n\n#### EcuM_ SetState\n\n[SWS_EcuM_04122] ⌈\nService Name EcuM_SetState\nSyntax void EcuM_SetState (\nEcuM_StateType state\n)\nService ID [hex] 0x2b\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) state State indicated by BswM.\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Function called by BswM to notify about State Switch.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_04123] ⌈The EcuM_SetState function shall set the EcuM State to the\nvalue of the State parameter.\nIf the State parameter is not a valid value, the EcuM_SetState function shall not change\nthe State and if Development Error Reporting is turned on, the EcuM_SetState function\nshall additionally send an ECUM_E_STATE_PAR_OUT_OF_RANGE error message to\nthe DET module.⌋(SRS_ModeMgm_09116)\n\n#### EcuM_RequestRUN\n\n[SWS_EcuM_04124] ⌈\nService Name EcuM_RequestRUN\nSyntax Std_ReturnType EcuM_RequestRUN (\nEcuM_UserType user\n)\nService ID [hex] 0x03\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user ID of the entity requesting the RUN state.\nParameters (inout) None\nParameters (out) None\n▽\n107 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "267": {
    "node_id": "9e19e1aa-9db3-4bcf-ba4a-58d10fa4dad0",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nReturn value Std_ReturnType E_OK: The request was accepted by EcuM.\nE_NOT_OK: The request was not accepted by EcuM\nDescription Places a request for the RUN state. Requests can be placed by every user made known to the\nstate manager at configuration time.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_04125] ⌈Requests of EcuM_RequestRUN cannot be nested, i.e. one\nuser can only place one request but not more. Additional or duplicate user requests by\nthe same user shall be reported to DET. Of course the DET will only be notified under\ndevelopment conditions.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04126] ⌈An implementation must track requests for each user known on\nthe ECU. Run requests are specific to the user.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03024] ⌈If development error detection is enabled and there are multiple\nrequests by the same user detected byEcuM_RequestRUN the function shall report\nECUM_E_MULTIPLE_RUN_REQUESTS to Det.⌋()\n\n#### EcuM_ReleaseRUN\n\n[SWS_EcuM_04127] ⌈\nService Name EcuM_ReleaseRUN\nSyntax Std_ReturnType EcuM_ReleaseRUN (\nEcuM_UserType user\n)\nService ID [hex] 0x04\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user ID of the entity releasing the RUN state.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The release request was accepted by EcuM\nE_NOT_OK: The release request was not accepted by EcuM\nDescription Releases a RUN request previously done with a call to EcuM_RequestRUN. The service is\nintended for implementing AUTOSAR ports.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03023] ⌈If development error detection is enabled and EcuM_Re-\nleaseRUN did not find a previous matching request for the provided user, then the\nfunction shall reportECUM_E_MISMATCHED_RUN_RELEASE to Det.⌋()\nConfiguration of EcuM_ReleaseRUN: Refer to EcuM_UserType for more information\nabout user IDs and their generation.\n108 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "268": {
    "node_id": "29feba30-ed50-4a50-8c5e-744978f37c94",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### EcuM_RequestPOST_RUN\n\n[SWS_EcuM_04128] ⌈\nService Name EcuM_RequestPOST_RUN\nSyntax Std_ReturnType EcuM_RequestPOST_RUN (\nEcuM_UserType user\n)\nService ID [hex] 0x0a\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user ID of the entity requesting the POST RUN state.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The request was accepted by EcuM\nE_NOT_OK: The request was not accepted by EcuM\nDescription Places a request for the POST RUN state. Requests can be placed by every user made known\nto the state manager at configuration time. Requests for RUN and POST RUN must be tracked\nindependently (in other words: two independent variables). The service is intended for\nimplementing AUTOSAR ports.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03025] ⌈If development error detection is enabled and there are multiple\nrequests by the same user detected byEcuM_RequestPOST_RUN the function shall\nreport ECUM_E_MULTIPLE_RUN_REQUESTS to Det.⌋()\nAll requirements of 8.3.3.2 EcuM_RequestRUN apply accordingly to the function Ecu\nM_RequestPOST_RUN.\nConfiguration of EcuM_RequestPOST_RUN: Refer to EcuM_UserType for more infor-\nmation about user IDs and their generation.\n\n#### EcuM_ReleasePOST_RUN\n\n[SWS_EcuM_04129] ⌈\nService Name EcuM_ReleasePOST_RUN\nSyntax Std_ReturnType EcuM_ReleasePOST_RUN (\nEcuM_UserType user\n)\nService ID [hex] 0x0b\nSync/Async Synchronous\nReentrancy Reentrant\n▽\n109 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "269": {
    "node_id": "95e47186-095f-4cdd-999c-633c6edbf321",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nParameters (in) user ID of the entity releasing the POST RUN state.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The release request was accepted by EcuM\nE_NOT_OK: The release request was not accepted by EcuM\nDescription Releases a POST RUN request previously done with a call to EcuM_RequestPOST_RUN. The\nservice is intended for implementing AUTOSAR ports.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03026] ⌈If development error detection is enabled andEcuM_Release-\nPOST_RUN did not find a previous matching request for the provided user, then the\nfunction shall reportECUM_E_MISMATCHED_RUN_RELEASE to Det.⌋()\nConfiguration of EcuM_ReleasePOST_RUN: Refer to EcuM_UserType for more infor-\nmation about user IDs and their generation.\n\n### Shutdown Management\n\n\n\n#### EcuM_SelectShutdownTarget\n\n[SWS_EcuM_02822] ⌈\nService Name EcuM_SelectShutdownTarget\nSyntax Std_ReturnType EcuM_SelectShutdownTarget (\nEcuM_ShutdownTargetType shutdownTarget,\nEcuM_ShutdownModeType shutdownMode\n)\nService ID [hex] 0x06\nSync/Async Synchronous\nReentrancy Reentrant\nshutdownTarget The selected shutdown target.Parameters (in)\nshutdownMode The identfier of a sleep mode (if target is ECUM_SHUTDOWN_\nTARGET_SLEEP) or a reset mechanism (if target is ECUM_\nSHUTDOWN_TARGET_RESET) as defined by configuration.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The new shutdown target was set\nE_NOT_OK: The new shutdown target was not set\nDescription EcuM_SelectShutdownTarget selects the shutdown target. EcuM_SelectShutdownTarget is\npart of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09114, SRS_ModeMgm_09128, SRS_ModeMgm_09235)\n110 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "270": {
    "node_id": "27b2cdce-a6bc-40b3-9f9d-32dcc5580e09",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_00624] ⌈The EcuM_SelectShutdownTarget function shall set the shut-\ndown target to the value of the shutdownTarget parameter.⌋(SRS_ModeMgm_09114,\nSRS_ModeMgm_09235)\n[SWS_EcuM_02185] ⌈The parameter mode of the function EcuM_SelectShutdown\nTarget shall be the identifier of a sleep or reset mode. The mode parameter shall\nonly be used if the target parameter equals ECUM_SHUTDOWN_TARGET_SLEEP or\nECUM_SHUTDOWN_TARGET_RESET. In all other cases, it shall be ignored. Only\nsleep or reset modes that are defined at configuration time and are stored in the Ecu\nMCommonConfiguration container (see ECUC_EcuM_00181) are allowed as parame-\nters.⌋(SRS_ModeMgm_09114)\n[SWS_EcuM_02585] ⌈EcuM_SelectShutdownTarget shall not initiate any setup activi-\nties but only store the value for later use in the SHUTDOWN or SLEEP phase.⌋(SRS_-\nModeMgm_09114)\nImplementation hint: The ECU Manager module does not define any mechanism to\nresolve conflicts arising from requests from different sources. The shutdown target is\nalways the last value set.\n\n#### EcuM_GetShutdownTarget\n\n[SWS_EcuM_02824] ⌈\nService Name EcuM_GetShutdownTarget\nSyntax Std_ReturnType EcuM_GetShutdownTarget (\nEcuM_ShutdownTargetType* shutdownTarget,\nEcuM_ShutdownModeType* shutdownMode\n)\nService ID [hex] 0x09\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nshutdownTarget One of these values is returned: ECUM_SHUTDOWN_TARGET_\nSLEEP ECUM_SHUTDOWN_TARGET_RESET ECUM_\nSHUTDOWN_TARGET_OFF\nParameters (out)\nshutdownMode If the out parameter \"shutdownTarget\" is ECUM_SHUTDOWN_\nTARGET_SLEEP , sleepMode tells which of the configured sleep\nmodes was actually chosen. If \"shutdownTarget\" is ECUM_\nSHUTDOWN_TARGET_RESET, sleepMode tells which of the\nconfigured reset modes was actually chosen.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service has failed, e.g. due to NULL pointer\nbeing passed\nDescription EcuM_GetShutdownTarget returns the currently selected shutdown target as set by EcuM_\nSelectShutdownTarget. EcuM_GetShutdownTarget is part of the ECU Manager Module port\ninterface.\n▽\n111 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "271": {
    "node_id": "d97322c3-7378-496e-b2e1-bae490e24798",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09128, SRS_ModeMgm_09235)\n[SWS_EcuM_02788] ⌈If the pointer to the shutdownMode parameter is NULL, EcuM_\nGetShutdownTarget shall simply ignore the shutdownMode parameter. If Development\nError Detection is activated,EcuM_GetShutdownTarget shall send the ECUM_E_\nPARAM_POINTER development error to the DET module.⌋()\n\n#### EcuM_GetLastShutdownTarget\n\n[SWS_EcuM_02825] ⌈\nService Name EcuM_GetLastShutdownTarget\nSyntax Std_ReturnType EcuM_GetLastShutdownTarget (\nEcuM_ShutdownTargetType* shutdownTarget,\nEcuM_ShutdownModeType* shutdownMode\n)\nService ID [hex] 0x08\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nshutdownTarget One of these values is returned: ECUM_SHUTDOWN_TARGET_\nSLEEP ECUM_SHUTDOWN_TARGET_RESET ECUM_\nSHUTDOWN_TARGET_OFF\nParameters (out)\nshutdownMode If the out parameter \"shutdownTarget\" is ECUM_SHUTDOWN_\nTARGET_SLEEP , sleepMode tells which of the configured sleep\nmodes was actually chosen. If \"shutdownTarget\" is ECUM_\nSHUTDOWN_TARGET_RESET, sleepMode tells which of the\nconfigured reset modes was actually chosen.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service has failed, e.g. due to NULL pointer\nbeing passed\nDescription EcuM_GetLastShutdownTarget returns the shutdown target of the previous shutdown process.\nEcuM_GetLastShutdownTarget is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09128, SRS_ModeMgm_09235)\n[SWS_EcuM_02156] ⌈EcuM_GetLastShutdownTarget shall return the ECU state from\nwhich the last wakeup or power up occurred in the shutdownTarget parameter. EcuM_\nGetLastShutdownTarget shall always return the same value until the next shutdown.⌋\n(SRS_ModeMgm_09235)\n[SWS_EcuM_02336] ⌈If the call of GetLastShutdownTarget() passes ECU_STATE_\nSLEEP in the parameter shutdownTarget, in the parameter shutdownMode it returns\nwhich of the configured sleep modes was actually chosen.\n112 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "272": {
    "node_id": "4d7f5b62-d613-42c5-8d15-13dce41a1b5f",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "If the call of GetLastShutdownTarget() passes ECU_STATE_RESET in the parameter\nshutdownTarget, in the parameter sleepMode it returns which of the configured reset\nmodes was actually chosen.⌋()\n[SWS_EcuM_02337] ⌈If the pointer to the shutdownMode parameter is NULL, Ecu\nM_GetLastShutdownTarget shall simply ignore the shutdownMode parameter and re-\nturn the last shutdown target regardless of whether it was SLEEP or not. If Develop-\nment Error Detection is activated, EcuM_GetShutdownTarget shall send the ECUM_\nE_PARAM_POINTER development error to the DET module.⌋()\n[SWS_EcuM_02157] ⌈EcuM_GetLastShutdownTarget may return a shutdown target in\na STARTUP phase that set late in a previous SHUTDOWN phase. If so, implementation\nspecific limitations shall be clearly documented.⌋()\nRationale for [SWS_EcuM_02157]\nThe EcuM_GetLastShutdownTarget function is intended primarily for use in the\nECU STARTUP or RUN states. To simplify implementation, it is acceptable if the value\nis set in late shutdown phase for use during the next startup.\n\n#### EcuM_SelectShutdownCause\n\n[SWS_EcuM_04050] ⌈\nService Name EcuM_SelectShutdownCause\nSyntax Std_ReturnType EcuM_SelectShutdownCause (\nEcuM_ShutdownCauseType target\n)\nService ID [hex] 0x1b\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) target The selected shutdown cause.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The new shutdown cause was set\nE_NOT_OK: The new shutdown cause was not set\nDescription EcuM_SelectShutdownCause elects the cause for a shutdown. EcuM_SelectShutdownCause\nis part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_GetShutdownCause\n\n[SWS_EcuM_04051] ⌈\n113 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "273": {
    "node_id": "b22c4772-9317-4c61-b8b2-0ea64354005e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_GetShutdownCause\nSyntax Std_ReturnType EcuM_GetShutdownCause (\nEcuM_ShutdownCauseType* shutdownCause\n)\nService ID [hex] 0x1c\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) shutdownCause The selected cause of the next shutdown.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service has failed, e.g. due to NULL pointer\nbeing passed\nDescription EcuM_GetShutdownCause returns the selected shutdown cause as set by EcuM_Select\nShutdownCause. EcuM_GetShutdownCause is part of the ECU Manager Module port\ninterface.\nAvailable via EcuM.h\n⌋()\n\n### Wakeup Handling\n\n\n\n#### EcuM_GetPendingWakeupEvents\n\n[SWS_EcuM_02827] ⌈\nService Name EcuM_GetPendingWakeupEvents\nSyntax EcuM_WakeupSourceType EcuM_GetPendingWakeupEvents (\nvoid\n)\nService ID [hex] 0x0d\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value EcuM_WakeupSource\nType\nAll wakeup events\nDescription Gets pending wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_01156] ⌈EcuM_GetPendingWakeupEvents shall return wakeup\nevents which have been set to pending but not yet validated as bits set in aEcuM_-\nWakeupSourceType bitmask.⌋()\n114 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "274": {
    "node_id": "cbb5ea68-5678-46fe-a673-08238aea8d18",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_02172] ⌈EcuM_GetPendingWakeupEvents shall be callable from in-\nterrupt context, from OS context and an OS-free context.⌋()\n[SWS_EcuM_03003] ⌈Caveat of EcuM_GetPendingWakeupEvents: This function\nonly returns the wakeup events with status ECUM_WKSTATUS_PENDING.⌋()\n\n#### EcuM_ClearWakeupEvent\n\n[SWS_EcuM_02828] ⌈\nService Name EcuM_ClearWakeupEvent\nSyntax void EcuM_ClearWakeupEvent (\nEcuM_WakeupSourceType sources\n)\nService ID [hex] 0x16\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) sources Events to be cleared\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Clears wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_02683] ⌈EcuM_ClearWakeupEvent clears all pending events passed as\na bit set in the sources in parameter (EcuM_WakeupSourceType bitmask) from the\ninternal pending wakeup events variable, the internal validated events variable and the\ninternal expired events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02807] ⌈EcuM_ClearWakeupEvent shall be callable from interrupt con-\ntext, from OS context and an OS-free context.⌋()\nIntegration note: The clearing of wakeup sources shall take place during ECU shut-\ndown prior to the call of Dem_Shutdown() and NvM_WriteAll(). This can be achieved\nby configuring BswMRules in the BswM module containing BswMActions of type\nBswMUserCallout with their BswMUserCalloutFunction parameter set to \"EcuM_Clear\nWakeupEvents(<sources>)\". Hereby <sources> needs to be derived from the Ecu\nMWakeupSourceIds in the EcuM configuration. These BswMRules must then be con-\nfigured in a way that they get triggered during ECU shutdown prior to the call of Dem_\nShutdown() and NvM_WriteAll().\n115 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "275": {
    "node_id": "dd168cbb-47a3-4f4b-8a25-0724ece657c3",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### EcuM_GetValidatedWakeupEvents\n\n[SWS_EcuM_02830] ⌈\nService Name EcuM_GetValidatedWakeupEvents\nSyntax EcuM_WakeupSourceType EcuM_GetValidatedWakeupEvents (\nvoid\n)\nService ID [hex] 0x15\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value EcuM_WakeupSource\nType\nAll wakeup events\nDescription Gets validated wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_02533] ⌈EcuM_GetValidatedWakeupEvent shall return wakeup\nevents which have been set to validated in the internal validated events variable as\nbits set in aEcuM_WakeupSourceType bitmask.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02532] ⌈EcuM_GetValidatedWakeupEvent shall be callable from in-\nterrupt context, from OS context and an OS-free context.⌋()\n\n#### EcuM_GetExpiredWakeupEvents\n\n[SWS_EcuM_02831] ⌈\nService Name EcuM_GetExpiredWakeupEvents\nSyntax EcuM_WakeupSourceType EcuM_GetExpiredWakeupEvents (\nvoid\n)\nService ID [hex] 0x19\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) None\nParameters (inout) None\nParameters (out) None\n▽\n116 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "276": {
    "node_id": "9f7c8c9c-0234-45ac-8cab-89c6c4c25e23",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nReturn value EcuM_WakeupSource\nType\nAll wakeup events: Returns all events that have been set and for\nwhich validation has failed. Events which do not need validation\nmust never be reported by this function.\nDescription Gets expired wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_04076] ⌈EcuM_GetExpiredWakeupEvents shall return wakeup\nevents which have been set to validated in the internal expired events variable as bits\nset in aEcuM_WakeupSourceType bitmask.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02589] ⌈EcuM_GetExpiredWakeupEvents shall be callable from in-\nterrupt context, from OS context and an OS-free context.⌋()\n\n### Alarm Clock\n\n\n\n#### EcuM_SetRelWakeupAlarm\n\n[SWS_EcuM_04054] ⌈\nService Name EcuM_SetRelWakeupAlarm\nSyntax Std_ReturnType EcuM_SetRelWakeupAlarm (\nEcuM_UserType user,\nEcuM_TimeType time\n)\nService ID [hex] 0x22\nSync/Async Synchronous\nReentrancy Reentrant\nuser The user that wants to set the wakeup alarm.Parameters (in)\ntime Relative time from now in seconds.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nECUM_E_EARLIER_ACTIVE: An earlier alarm is already set\nDescription EcuM_SetRelWakeupAlarm sets a user’s wakeup alarm relative to the current point in time.\nEcuM_SetRelWakeupAlarm is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09186, SRS_ModeMgm_09190)\n[SWS_EcuM_04055] ⌈If the relative time from now is earlier than the current wakeup\ntime, EcuM_SetRelWakeupAlarm shall update the wakeup time.⌋(SRS_ModeMgm_-\n09186)\n117 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "277": {
    "node_id": "9b22916b-e555-42e8-a5ab-f4f8010585e1",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_04056] ⌈If the relative time from now is later than the current wakeup\ntime, EcuM_SetRelWakeupAlarm shall not update the wakeup time and shall return\nECUM_E_EARLIER_ACTIVE.⌋(SRS_ModeMgm_09186)\n\n#### EcuM_SetAbsWakeupAlarm\n\n[SWS_EcuM_04057] ⌈\nService Name EcuM_SetAbsWakeupAlarm\nSyntax Std_ReturnType EcuM_SetAbsWakeupAlarm (\nEcuM_UserType user,\nEcuM_TimeType time\n)\nService ID [hex] 0x23\nSync/Async Synchronous\nReentrancy Reentrant\nuser The user that wants to set the wakeup alarm.Parameters (in)\ntime Absolute time in seconds. Note that, absolute alarms use\nknowledge of the current time.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nECUM_E_EARLIER_ACTIVE: An earlier alarm is already set\nECUM_E_PAST: The given point in time has already passed\nDescription EcuM_SetAbsWakeupAlarm sets the user’s wakeup alarm to an absolute point in time. EcuM_\nSetAbsWakeupAlarm is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09186, SRS_ModeMgm_09199)\n[SWS_EcuM_04058] ⌈If the time parameter is earlier than the current wakeup\ntime, EcuM_SetAbsWakeupAlarm shall update the wakeup time.⌋(SRS_ModeMgm_-\n09186)\n[SWS_EcuM_04059] ⌈If the time parameter is later than the current wakeup time,\nEcuM_SetAbsWakeupAlarm shall not update the wakeup time and shall return\nECUM_E_EARLIER_ACTIVE.⌋(SRS_ModeMgm_09186)\n[SWS_EcuM_04060] ⌈If the time parameter is earlier than now,EcuM_SetAbsWake-\nupAlarm shall not update the wakeup time and shall return ECUM_E_PAST.⌋(SRS_-\nModeMgm_09186)\n\n#### EcuM_AbortWakeupAlarm\n\n[SWS_EcuM_04061] ⌈\n118 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "278": {
    "node_id": "7c982b94-a28d-4167-85c1-2985b1c04919",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_AbortWakeupAlarm\nSyntax Std_ReturnType EcuM_AbortWakeupAlarm (\nEcuM_UserType user\n)\nService ID [hex] 0x24\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user The user that wants to cancel the wakeup alarm.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nECUM_E_NOT_ACTIVE: No owned alarm found\nDescription Ecum_AbortWakeupAlarm aborts the wakeup alarm previously set by this user. EcuM_Abort\nWakeupAlarm is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_GetCurrentTime\n\n[SWS_EcuM_04062] ⌈\nService Name EcuM_GetCurrentTime\nSyntax Std_ReturnType EcuM_GetCurrentTime (\nEcuM_TimeType* time\n)\nService ID [hex] 0x25\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) time Absolute time in seconds since battery connect.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: time points to NULL or the module is not initialized\nDescription EcuM_GetCurrentTime returns the current value of the EcuM clock (i.e. the time since battery\nconnect). EcuM_GetCurrentTime is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_GetWakeupTime\n\n[SWS_EcuM_04063] ⌈\n119 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "279": {
    "node_id": "129e3e96-697e-4f26-8781-6efa229fce60",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_GetWakeupTime\nSyntax Std_ReturnType EcuM_GetWakeupTime (\nEcuM_TimeType* time\n)\nService ID [hex] 0x26\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) time Absolute time in seconds for next wakeup. 0xFFFFFFFF means\nno active alarm.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: time points to NULL or the module is not initialized\nDescription EcuM_GetWakeupTime returns the current value of the master alarm clock (the minimum\nabsolute time of all user alarm clocks). EcuM_GetWakeupTime is part of the ECU Manager\nModule port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_SetClock\n\n[SWS_EcuM_04064] ⌈\nService Name EcuM_SetClock\nSyntax Std_ReturnType EcuM_SetClock (\nEcuM_UserType user,\nEcuM_TimeType time\n)\nService ID [hex] 0x27\nSync/Async Synchronous\nReentrancy Reentrant\nuser User that wants to set the clockParameters (in)\ntime Absolute time in seconds since battery connect.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nDescription EcuM_SetClock sets the EcuM clock time to the provided value. This API is useful for testing\nthe alarm services; Alarms that take days to expire can be tested. EcuM_SetClock is part of the\nECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09194)\n120 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "280": {
    "node_id": "ec7595d5-95c7-4959-9e96-3b4c52108db2",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Miscellaneous\n\n\n\n#### EcuM_SelectBootTarget\n\n[SWS_EcuM_02835] ⌈\nService Name EcuM_SelectBootTarget\nSyntax Std_ReturnType EcuM_SelectBootTarget (\nEcuM_BootTargetType target\n)\nService ID [hex] 0x12\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) target The selected boot target.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The new boot target was accepted by EcuM\nE_NOT_OK: The new boot target was not accepted by EcuM\nDescription EcuM_SelectBootTarget selects a boot target. EcuM_SelectBootTarget is part of the ECU\nManager Module port interface.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02247] ⌈The service EcuM_SelectBootTarget shall store the se-\nlected target in a way that is compatible with the boot loader.⌋()\nExplanation for [SWS_EcuM_02247]: This may mean format AND location. The imple-\nmenter must ensure that the boot target information is placed at a safe location which\nthen can be evaluated by the boot manager after a reset.\n[SWS_EcuM_03000] ⌈Caveat for the functionEcuM_SelectBootTarget: This ser-\nvice may depend on the boot loader used. This service is only intended for use by\nSW-C’s related to diagnostics (boot management).⌋()\n\n#### EcuM_GetBootTarget\n\n[SWS_EcuM_02836] ⌈\nService Name EcuM_GetBootTarget\nSyntax Std_ReturnType EcuM_GetBootTarget (\nEcuM_BootTargetType * target\n)\nService ID [hex] 0x13\n▽\n121 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "281": {
    "node_id": "404cccfc-ff6c-427e-83d9-50e999c16cad",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) target The currently selected boot target.\nReturn value Std_ReturnType E_OK: The service always succeeds.\nDescription EcuM_GetBootTarget returns the current boot target - see EcuM_SelectBootTarget. EcuM_Get\nBootTarget is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_BSW_00172)\n\n## Callback Definitions\n\n\n\n### Callbacks from Wakeup Sources\n\n\n\n#### EcuM_CheckWakeup\n\nSee EcuM_StartCheckWakeup ([SWS_EcuM_02929]) for a description of the\nEcuM_CheckWakeup function.\nThis serviceEcuM_CheckWakeup is a Callout of the ECU Manager module as well as\na Callback that wakeup sources invoke when they process wakeup interrupts.\n\n#### EcuM_SetWakeupEvent\n\n[SWS_EcuM_02826] ⌈\nService Name EcuM_SetWakeupEvent\nSyntax void EcuM_SetWakeupEvent (\nEcuM_WakeupSourceType sources\n)\nService ID [hex] 0x0c\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) sources Value to be set\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Sets the wakeup event.\nAvailable via EcuM.h\n⌋(SRS_BSW_00359, SRS_BSW_00360, SRS_BSW_00440, SRS_ModeMgm_-\n09098)\n122 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "282": {
    "node_id": "50c7ae52-a235-424d-b6b8-92fdba2d059f",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_01117] ⌈EcuM_SetWakeupEvent sets (OR-operation) all events\npassed as a bit set in the sources in parameter (EcuM_WakeupSourceType bitmask)\nin the internal pending wakeup events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02707] ⌈EcuM_SetWakeupEvent shall start the wakeup validation\ntimeout timer according toWakeup Validation Timeout.⌋()\nSee section 7.6.4.3 Wakeup Validation Timeout.\n[SWS_EcuM_02867] ⌈If Development Error Reporting is turned on and parame-\nter \"sources\" contains an unknown (unconfigured) wakeup source,EcuM_SetWake-\nupEvent shall not update its internal variable and shall send the ECUM_E_UN-\nKNOWN_WAKEUP_SOURCE error message to the DET module instead.⌋()\n[SWS_EcuM_02171] ⌈EcuM_SetWakeupEvent must be callable from interrupt con-\ntext, from OS context and an OS-free context.⌋(SRS_BSW_00333)\n[SWS_EcuM_04138] ⌈EcuM_SetWakeupEvent shall ignore all events passed in the\nsources parameter that are not associated to the selected sleep mode.⌋()\n\n#### EcuM_ValidateWakeupEvent\n\n[SWS_EcuM_02829] ⌈\nService Name EcuM_ValidateWakeupEvent\nSyntax void EcuM_ValidateWakeupEvent (\nEcuM_WakeupSourceType sources\n)\nService ID [hex] 0x14\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) sources Events that have been validated\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription After wakeup, the ECU State Manager will stop the process during the WAKEUP VALIDATION\nstate/sequence to wait for validation of the wakeup event.This API service is used to indicate to\nthe ECU Manager module that the wakeup events indicated in the sources parameter have\nbeen validated.\nAvailable via EcuM.h\n⌋(SRS_BSW_00359, SRS_BSW_00360, SRS_BSW_00440)\n[SWS_EcuM_04078] ⌈EcuM_ValidateWakeupEvent sets (OR-operation) all events\npassed as a bit set in the sources in parameter (EcuM_WakeupSourceType bitmask)\nin the internal validated wakeup events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n123 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "283": {
    "node_id": "39eb8969-2bd3-476b-be3d-2cab7f8090d4",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "[SWS_EcuM_04079] ⌈EcuMValidateWakeupEvent shall invoke BswM_EcuM_Current\nWakeup with its sources parameter and state value ECUM_WKSTATUS_VALIDATED.⌋\n()\n[SWS_EcuM_02645] ⌈EcuM_ValidateWakeupEvent shall invoke ComM_EcuM_\nWakeUpIndication for each wakeup event if the EcuMComMChannelRef parameter\n(see ECUC_EcuM_00101) in the EcuMWakeupSource configuration container for the\ncorresponding wakeup source is configured.⌋()\n[SWS_EcuM_02868] ⌈If Development Error Reporting is turned on and the sources\nparameter contains an unknown (unconfigured) wakeup source,EcuM_Validate-\nWakeupEvent shall ignore the call and send the ECUM_E_UNKNOWN_WAKEUP_\nSOURCE error message to the DET module.⌋()\n[SWS_EcuM_02345] ⌈EcuM_ValidateWakeupEvent shall be callable from interrupt\ncontext and task context.⌋(SRS_BSW_00333)\n[SWS_EcuM_02790] ⌈EcuM_ValidateWakeupEvent shall return without effect for\nall sources except communication channels when called while the ECU Manager mod-\nule is in the RUN state.⌋()\n[SWS_EcuM_02791] ⌈EcuM_ValidateWakeupEvent shall have full effect in any\nECU Phase for those sources that correspond to a communication channel (see\n[SWS_EcuM_02645]).⌋()\n[SWS_EcuM_04140] ⌈EcuM_ValidateWakeupEvent shall invoke ComM_EcuM_\nPNCWakeUpIndication for each wakeup event and for every referenced PNC if at least\none EcuMComMPNCRef parameter (see ECUC_EcuM_00228) in the EcuMWakeup\nSource configuration container for the corresponding wakeup source is configured.⌋()\n\n## Callout Definitions\n\nCallouts are code fragments that must be added to the ECU Manager module during\nECU integration. The content of most callouts is hand-written code. The ECU Manager\nmodule configuration tool generates a default implementation for some callouts which\nis edited manually by the integrator. Conceptually, these callouts belong to the ECU\nintegration code.\n\n### Generic Callouts\n\n\n\n#### EcuM_ErrorHook\n\n[SWS_EcuM_02904] ⌈\n124 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "284": {
    "node_id": "f890fb01-3885-4773-a2b4-e92998255d4a",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_ErrorHook\nSyntax void EcuM_ErrorHook (\nuint16 reason\n)\nService ID [hex] 0x30\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) reason Reason for calling the error hook\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The ECU State Manager will call the error hook if the error codes \"ECUM_E_RAM_CHECK_\nFAILED\" or \"ECUM_E_CONFIGURATION_DATA_INCONSISTENT\" occur. In this situation it is\nnot possible to continue processing and the ECU must be stopped. The integrator may choose\nthe modality how the ECU is stopped, i.e. reset, halt, restart, safe state etc.\nAvailable via EcuM_Externals.h\n⌋() The ECU Manager module can invokeEcuM_ErrorHook: in all phases\nClass ofEcuM_ErrorHook: Mandatory\nEcuM_ErrorHook is integration code and the integrator is free to define additional\nindividual error codes to be passed as the reason parameter. These codes shall not\nconflict with the development and production error codes as defined in Table 7.1 and\nTable 7.13.1 nor with the standard error codes, i.e. E_OK, E_NOT_OK, etc.\n\n### Callouts from the STARTUP Phase\n\n\n\n#### EcuM_AL_SetProgrammableInterrupts\n\n[SWS_EcuM_04085] ⌈\nService Name EcuM_AL_SetProgrammableInterrupts\nSyntax void EcuM_AL_SetProgrammableInterrupts (\nvoid\n)\nService ID [hex] 0x4A\nSync/Async Asynchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\n▽\n125 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "285": {
    "node_id": "128700c9-9595-4caa-ab29-a400bf70ebfa",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nDescription If the configuration parameter EcuMSetProgrammableInterrupts is set to true, this callout Ecu\nM_AL_SetProgrammableInterrupts is executed and shall set the interrupts on ECUs with\nprogrammable interrupts.\nAvailable via EcuM_Externals.h\n⌋()\n\n#### EcuM_AL_DriverInitZero\n\n[SWS_EcuM_02905] ⌈\nService Name EcuM_AL_DriverInitZero\nSyntax void EcuM_AL_DriverInitZero (\nvoid\n)\nService ID [hex] 0x31\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall provide driver initialization and other hardware-related startup activities for\nloading the post-build configuration data. Beware: Here only pre-compile and link-time\nconfigurable modules may be used.\nAvailable via EcuM_Externals.h\n⌋() The ECU Manager module invokesEcuM_AL_DriverInitZero early in the Pre\nOS Sequence (see section 7.3.2 Activities in StartPreOS Sequence)\nThe ECU Manager module configuration tool must generate a default implementation\nof theEcuM_AL_DriverInitZero callout ([SWS_EcuM_02905]) from the sequence\nof modules defined in the EcuMDriverInitListZero configuration container (see ECUC_\nEcuM_00114). See also [SWS_EcuM_02559] and [SWS_EcuM_02730].\n\n#### EcuM_DeterminePbConfiguration\n\n[SWS_EcuM_02906] ⌈\n126 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "286": {
    "node_id": "4f344464-205a-4ad2-8e29-1f4cfe767b13",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_DeterminePbConfiguration\nSyntax const EcuM_ConfigType* EcuM_DeterminePbConfiguration (\nvoid\n)\nService ID [hex] 0x32\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value const EcuM_ConfigType* Pointer to the EcuM post-build configuration which contains\npointers to all other BSW module post-build configurations.\nDescription This callout should evaluate some condition, like port pin or NVRAM value, to determine which\npost-build configuration shall be used in the remainder of the startup process. It shall load this\nconfiguration data into a piece of memory that is accessible by all BSW modules and shall\nreturn a pointer to the EcuM post-build configuration as a base for all BSW module post-build\nconfigrations.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokesEcuM_DeterminePbConfiguration early in the\nPreOS Sequence (see section 7.3.2 Activities in StartPreOS Sequence)\n\n#### EcuM_AL_DriverInitOne\n\n[SWS_EcuM_02907] ⌈\nService Name EcuM_AL_DriverInitOne\nSyntax void EcuM_AL_DriverInitOne (\nvoid\n)\nService ID [hex] 0x33\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall provide driver initialization and other hardware-related startup activities in\ncase of a power on reset.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_AL_DriverInitOne in the PreOS Sequence\n(see section 7.3.2 Activities in StartPreOS Sequence)\n127 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "287": {
    "node_id": "1c6d7d87-de28-42b5-8212-839ce5a15fd7",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "The ECU Manager module configuration tool must generate a default implementation\nof the EcuM_AL_DriverInitOne callout from the sequence of modules defined in the\nEcuMDriverInitListOne configuration container (see ECUC_EcuM_00111). See also\n[SWS_EcuM_02559] and [SWS_EcuM_02730].\nBesides driver initialization, the following initialization sequences should be considered\nin this block: MCU initialization according to AUTOSAR_SWS_Mcu_Driver chapter 9.1.\n\n#### EcuM_LoopDetection\n\n[SWS_EcuM_04137] ⌈\nService Name EcuM_LoopDetection\nSyntax void EcuM_LoopDetection (\nvoid\n)\nService ID [hex] 0x4B\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription If the configuration parameter EcuMResetLoopDetection is set to true, this callout EcuM_Loop\nDetection is called on every startup.\nAvailable via EcuM_Externals.h\n⌋()\n\n### Callouts from the SHUTDOWN Phase\n\n\n\n#### EcuM_OnGoOffOne\n\n[SWS_EcuM_02916] ⌈\nService Name EcuM_OnGoOffOne\nSyntax void EcuM_OnGoOffOne (\nvoid\n)\nService ID [hex] 0x3C\nSync/Async Synchronous\nReentrancy Non Reentrant\n▽\n128 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "288": {
    "node_id": "48379b65-0b65-434e-a28f-f9a5b4e03864",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This call allows the system designer to notify that the GO OFF I state is about to be entered.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_OnGoOffOne on entry to the OffPreOS Se-\nquence (see section 7.4.1 Activities in the OffPreOS Sequence).\n\n#### EcuM_OnGoOffTwo\n\n[SWS_EcuM_02917] ⌈\nService Name EcuM_OnGoOffTwo\nSyntax void EcuM_OnGoOffTwo (\nvoid\n)\nService ID [hex] 0x3D\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This call allows the system designer to notify that the GO OFF II state is about to be entered.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_OnGoOffTwo on entry to the OffPostOS\nSequence (see section 7.4.2 Activities in the OffPostOS Sequence).\n\n#### EcuM_AL_SwitchOff\n\n[SWS_EcuM_02920] ⌈\n129 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "289": {
    "node_id": "daba529f-deb6-4808-a4f8-ddd322375dda",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_AL_SwitchOff\nSyntax void EcuM_AL_SwitchOff (\nvoid\n)\nService ID [hex] 0x3E\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall take the code for shutting off the power supply of the ECU. If the ECU cannot\nunpower itself, a reset may be an adequate reaction.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_AL_SwitchOff as the last activity in the Off\nPostOS Sequence (see section 7.4.2 Activities in the OffPostOS Sequence).\nNote: In some cases of HW/SW concurrency, it may happen that during the power\ndown in EcuM_AL_SwitchOff (endless loop) some hardware (e.g. a CAN transceiver)\nswitches on the ECU again. In this case the ECU may be in a deadlock until the\nhardware watchdog resets the ECU. To reduce the time until the hardware watchdog\nfixes this deadlock, the integrator code in EcuM_AL_SwitchOff as last action can limit\nthe endless loop and after a sufficient long time reset the ECU using Mcu_Perform\nReset().\n\n#### EcuM_AL_Reset\n\n[SWS_EcuM_04065] ⌈\nService Name EcuM_AL_Reset\nSyntax void EcuM_AL_Reset (\nEcuM_ResetType reset\n)\nService ID [hex] 0x4C\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) reset Type of reset to be performed.\nParameters (inout) None\nParameters (out) None\nReturn value None\n▽\n130 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "290": {
    "node_id": "792212b4-3778-4b2d-8dc7-e8ccf634cea5",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nDescription This callout shall take the code for resetting the ECU.\nAvailable via EcuM_Externals.h\n⌋()\n\n### Callouts from the SLEEP Phase\n\n\n\n#### EcuM_EnableWakeupSources\n\n[SWS_EcuM_02918] ⌈\nService Name EcuM_EnableWakeupSources\nSyntax void EcuM_EnableWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x3F\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The ECU Manager Module calls EcuM_EnableWakeupSource to allow the system designer to\nnotify wakeup sources defined in the wakeupSource bitfield that SLEEP will be entered and to\nadjust their source accordingly.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_EnableWakeupSources in the GoSleep Se-\nquence (see section 7.5.1 Activities in the GoSleep Sequence)\n[SWS_EcuM_02546] ⌈The ECU Manager module shall derive the wakeup sources to\nbe enabled (and used as the wakeupSource parameter) from the EcuMWakeupSource\n(see ECUC_EcuM_00152) bitfield configured for the current sleep mode.⌋()\n\n#### EcuM_GenerateRamHash\n\n[SWS_EcuM_02919] ⌈\n131 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "291": {
    "node_id": "19663bc4-40d9-4281-85b9-bf378c684016",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_GenerateRamHash\nSyntax void EcuM_GenerateRamHash (\nvoid\n)\nService ID [hex] 0x40\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription see EcuM_CheckRamHash\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_GenerateRamHash: in the Halt Sequence\njust before putting the ECU physically to sleep (see section 7.5.2 Activities in the Halt\nSequence).\n\n#### EcuM_SleepActivity\n\n[SWS_EcuM_02928] ⌈\nService Name EcuM_SleepActivity\nSyntax void EcuM_SleepActivity (\nvoid\n)\nService ID [hex] 0x41\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout is invoked periodically in all reduced clock sleep modes. It is explicitely allowed to\npoll wakeup sources from this callout and to call wakeup notification functions to indicate the\nend of the sleep state to the ECU State Manager.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_SleepActivity periodically during the Poll\nSequence (see section 7.5.3 Activities in the Poll Sequence) if the MCU is not halted\n(i.e. clock is reduced).\n132 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "292": {
    "node_id": "a69635f1-55cd-4e88-9a05-ec5ef0f63fae",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Note: If called from the Poll sequence the EcuMcalls this callout functions in a blocking\nloop at maximum frequency. The callout implementation must ensure by other means\nif callout code shall be executed with a lower period. The integrator may choose any\nmethod to control this, e.g. with the help of OS counters, OS alarms, or Gpt timers.\n\n#### EcuM_StartCheckWakeup\n\n[SWS_EcuM_04096] ⌈\nService Name EcuM_StartCheckWakeup\nSyntax void EcuM_StartCheckWakeup (\nEcuM_WakeupSourceType WakeupSource\n)\nService ID [hex] 0x00\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) WakeupSource For this wakeup source the corresponding CheckWakeupTimer\nshall be started.\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This API is called by the ECU Firmware to start the CheckWakeupTimer for the corresponding\nWakeupSource. If EcuMCheckWakeupTimeout > 0 the CheckWakeupTimer for the Wakeup\nSource is started. If EcuMCheckWakeupTimeout <= 0 the API call is ignored by the EcuM.\nAvailable via EcuM_Externals.h\n⌋()\n\n#### EcuM_CheckWakeup\n\n[SWS_EcuM_02929] ⌈\nService Name EcuM_CheckWakeup\nSyntax void EcuM_CheckWakeup (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x42\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\n▽\n133 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "293": {
    "node_id": "dae33eeb-db9c-408e-aaee-ba6d701c3c9b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nDescription This callout is called by the EcuM to poll a wakeup source. It shall also be called by the ISR of a\nwakeup source to set up the PLL and check other wakeup sources that may be connected to\nthe same interrupt.\nAvailable via EcuM_Externals.h\n⌋()\n[SWS_EcuM_04098] ⌈If EcuM_SetWakeupEvent is called for the corresponding\nwakeup source the CheckWakeupTimer is cancelled.⌋()\n\n#### EcuM_EndCheckWakeup\n\n[SWS_EcuM_02927] ⌈\nService Name EcuM_EndCheckWakeup\nSyntax void EcuM_EndCheckWakeup (\nEcuM_WakeupSourceType WakeupSource\n)\nService ID [hex] 0x00\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) WakeupSource For this wakeup source the corresponding CheckWakeupTimer\nshall be canceled.\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This API is called by any SW Module whose wakeup source is checked asynchronously (e.g.\nasynchronous Can Trcv Driver) and the Check of the Wakeup returns a negative Result (no\nWakeup by this Source). The API cancels the CheckWakeupTimer for the WakeupSource. If\nthe correponding CheckWakeupTimer is canceled the check of this wakeup source is finished.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_CheckWakeup periodically during the Poll\nSequence (see section 7.5.3 Activities in the Poll Sequence) if the MCU is not halted,\nor when handling a wakeup interrupt.\nNote: If called from the Poll sequence the EcuMcalls this callout functions in a blocking\nloop at maximum frequency. The callout implementation must ensure by other means\nif callout code shall be executed with a lower period. The integrator may choose any\nmethod to control this, e.g. with the help of OS counters, OS alarms, or Gpt timers.\n[SWS_EcuM_04080] ⌈The ECU Manager module shall derive the wakeup sources\nto be checked (and used as the wakeupSource parameter) from the EcuMWakeup\nSource (see ECUC_EcuM_00152) bitfield configured for the current sleep mode. The\nintegration code used for this callout must determine which wakeup sources must be\nchecked.⌋()\n134 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "294": {
    "node_id": "31c1e2d6-3f51-463b-9d05-c85b25e81c23",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### EcuM_CheckRamHash\n\n[SWS_EcuM_02921] ⌈\nService Name EcuM_CheckRamHash\nSyntax uint8 EcuM_CheckRamHash (\nvoid\n)\nService ID [hex] 0x43\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value uint8 0: RAM integrity test failed\nelse: RAM integrity test passed\nDescription This callout is intended to provide a RAM integrity test. The goal of this test is to ensure that\nafter a long SLEEP duration, RAM contents is still consistent. The check does not need to be\nexhaustive since this would consume quite some processing time during wakeups. A well\ndesigned check will execute quickly and detect RAM integrity defects with a sufficient\nprobability. This specification does not make any assumption about the algorithm chosen for a\nparticular ECU. The areas of RAM which will be checked have to be chosen carefully. It\ndepends on the check algorithm itself and the task structure. Stack contents of the task\nexecuting the RAM check e.g. very likely cannot be checked. It is good practice to have the\nhash generation and checking in the same task and that this task is not preemptible and that\nthere is only little activity between hash generation and hash check. The RAM check itself is\nprovided by the system designer. In case of applied multi core and existence of Satellite-Ecu\nM(s): this API will be called by the Master-EcuM only.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_CheckRamHash early in the WakeupRestart\nSequence (see section 7.5.5 Activities in the WakeupRestart Sequence)\n[SWS_EcuM_02987] ⌈When the RAM check fails on wakeup the ECU Manager mod-\nule shall invokeEcuM_ErrorHook with the parameterECUM_E_RAM_CHECK_FAILED\n. It is left integrator’s discretion to allowEcuM_ErrorHook to relay the error to the DEM\nwhen he judges that the DEM will not write damaged NVRAM blocks.⌋(SRS_BSW_-\n00339)\nSee also section 7.5.2 Activities in the Halt Sequence.\n\n#### EcuM_DisableWakeupSources\n\n[SWS_EcuM_02922] ⌈\n135 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "295": {
    "node_id": "3f3b62b6-d4d5-48d6-a05e-1ba64001e119",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Service Name EcuM_DisableWakeupSources\nSyntax void EcuM_DisableWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x44\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The ECU Manager Module calls EcuM_DisableWakeupSources to set the wakeup source(s)\ndefined in the wakeupSource bitfield so that they are not able to wake the ECU up.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_DisableWakeupSources in the Wakeup\nRestart Sequence (see section 7.5.5 Activities in the WakeupRestart Sequence)\n[SWS_EcuM_04084] ⌈The ECU Manager module shall derive the wakeup sources\nto be disabled (and used as the wakeupSource parameter) from the internal pend-\ning events variable (NOT operation). The integration code used for this callout must\ndetermine which wakeup sources must be disabled.⌋()\n\n#### EcuM_AL_DriverRestart\n\n[SWS_EcuM_02923] ⌈\nService Name EcuM_AL_DriverRestart\nSyntax void EcuM_AL_DriverRestart (\nvoid\n)\nService ID [hex] 0x45\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall provide driver initialization and other hardware-related startup activities in the\nwakeup case.\nAvailable via EcuM_Externals.h\n⌋()\n136 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "296": {
    "node_id": "843ed15d-0528-4502-ab37-d7fe8af076bb",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "The ECU Manager module invokes EcuM_EcuM_AL_DriverRestart in the Wakeup\nRestart Sequence (see section 7.5.5 Activities in the WakeupRestart Sequence)\nThe ECU Manager module Configuration Tool shall generate a default implementation\nof the EcuM_AL_DriverRestart callout from the sequence of modules defined in the\nEcuMDriverRestartList configuration container (see ECUC_EcuM_00115). See also\n[SWS_EcuM_02561], [SWS_EcuM_02559] and [SWS_EcuM_02730].\n\n### Callouts from the UP Phase\n\n\n\n#### EcuM_StartWakeupSources\n\n[SWS_EcuM_02924] ⌈\nService Name EcuM_StartWakeupSources\nSyntax void EcuM_StartWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x46\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The callout shall start the given wakeup source(s) so that they are ready to perform wakeup\nvalidation.\nAvailable via EcuM_Externals.h\n⌋()\nThe EcuM Manager module invokes EcuM_StartWakeupSources in the WakeupVali-\ndation Sequence (see section 7.6.4 Activities in the WakeupValidation Sequence).\n\n#### EcuM_CheckValidation\n\n[SWS_EcuM_02925] ⌈\nService Name EcuM_CheckValidation\nSyntax void EcuM_CheckValidation (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x47\n▽\n137 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "297": {
    "node_id": "e473d5ae-fdde-4713-99af-87a903c3cc47",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout is called by the EcuM to validate a wakeup source. If a valid wakeup has been\ndetected, it shall be reported to EcuM via EcuM_ValidateWakeupEvent().\nAvailable via EcuM_Externals.h\n⌋()\nThe EcuM Manager module invokes EcuM_CheckValidation in the WakeupValidation\nSequence (see section 7.6.4 Activities in the WakeupValidation Sequence).\n\n#### EcuM_StopWakeupSources\n\n[SWS_EcuM_02926] ⌈\nService Name EcuM_StopWakeupSources\nSyntax void EcuM_StopWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x48\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The callout shall stop the given wakeup source(s) after unsuccessful wakeup validation.\nAvailable via EcuM_Externals.h\n⌋()\nThe EcuM Manager module invokes EcuM_StopWakeupSources in the WakeupVali-\ndation Sequence (see section 7.6.4 Activities in the WakeupValidation Sequence).\n\n## Scheduled Functions\n\nThese functions are directly called by Basic Software Scheduler. The following func-\ntions shall have no return value and no parameter. All functions shall be non reentrant.\n138 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "298": {
    "node_id": "678b54e4-1ece-4552-9dac-a7382c0f4213",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuM_MainFunction\n\n[SWS_EcuM_02837] ⌈\nService Name EcuM_MainFunction\nSyntax void EcuM_MainFunction (\nvoid\n)\nService ID [hex] 0x18\nDescription The purpose of this service is to implement all activities of the ECU State Manager while the\nOS is up and running.\nAvailable via SchM_EcuM.h\n⌋(SRS_BSW_00425, SRS_BSW_00373) To determine the period, the system de-\nsigner should consider:\n•The function will perform wakeup validation (see 7.8 Wakeup Validation Protocol).\nThe shortest validation timeout typically should limit the period.\n•As a rule of thumb, the period of this function should be approximately half as\nlong as the shortest validation timeout.\nEcuM_MainFunction should not be called from tasks that may invoke runnable entities.\n\n## Expected Interfaces\n\nIn this chapter all interfaces required from other modules are listed.\nThis chapter defines all interfaces which are required to fulfill the core functionality of\nthe module.\n[SWS_EcuM_02858] ⌈\nAPI Function Header File Description\nBswM_Deinit BswM.h Deinitializes the BSW Mode Manager.\nBswM_EcuM_CurrentWakeup BswM_EcuM.h Function called by EcuM to indicate the current state\nof a wakeup source.\nBswM_Init BswM.h Initializes the BSW Mode Manager.\nCanSM_StartWakeupSource CanSM.h This function shall be called by EcuM when a\nwakeup source shall be started.\nCanSM_StopWakeupSource CanSM.h This function shall be called by EcuM when a\nwakeup source shall be stopped.\nComM_EcuM_PNCWakeUpIndication ComM_EcuM.h Notification of a wake up on the corresponding\npartial network cluster.\nComM_EcuM_WakeUpIndication ComM_EcuM.h Notification of a wake up on the corresponding\nchannel.\n▽\n139 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "299": {
    "node_id": "9b64c922-4ebc-4d40-bd20-e36a5a104c22",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nAPI Function Header File Description\nDem_Init Dem.h Initializes or reinitializes this module.\nDem_PreInit Dem.h Initializes the internal states necessary to process\nevents reported by BSW-modules.\nDem_Shutdown Dem.h Shuts down this module.\nGetResource Os.h –\nMcu_GetResetReason Mcu.h The service reads the reset type from the hardware,\nif supported.\nMcu_Init Mcu.h This service initializes the MCU driver.\nMcu_PerformReset Mcu.h The service performs a microcontroller reset.\nMcu_SetMode Mcu.h This service activates the MCU power modes.\nReleaseResource Os.h –\nSchM_Deinit SchM.h SchM_Deinit is used to finalize Basic Software\nScheduler part of the RTE of the core on which it is\ncalled. This service releases all system resources\nallocated by the Basic Software Scheduler part on\nthat core.\nSchM_Init SchM.h SchM_Init is intended to allocate and initialize\nsystem resources used by the Basic Software\nScheduler part of the RTE for the core on which it is\ncalled.\nShutdownOS Os.h –\nStartOS Os.h –\n⌋()\n\n### Optional Interfaces\n\nThis chapter defines all interfaces which are required to fulfill an optional functionality\nof the module.\n[SWS_EcuM_02859] ⌈\nAPI Function Header File Description\nAdc_Init Adc.h Initializes the ADC hardware units and driver.\nCan_Init Can.h This function initializes the module.\nCanTrcv_Init CanTrcv.h Initializes the CanTrcv module.\nDet_Init Det.h Service to initialize the Default Error Tracer.\nDet_ReportError Det.h Service to report development errors.\nEth_Init Eth.h Initializes the Ethernet Driver\nEthSwt_Init EthSwt.h Initializes the Ethernet Switch Driver\nEthTrcv_Init EthTrcv.h Initializes the Ethernet Transceiver Driver\nFls_Init Fls.h Initializes the Flash Driver.\nFr_Init Fr.h Initializes the Fr.\nFrTrcv_Init FrTrcv.h This service initializes the FrTrcv.\nGetCoreID Os.h The function returns a unique core identifier.\n▽\n140 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "300": {
    "node_id": "0013845b-8a5d-4f91-8a5f-3a44c5c53fa9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nAPI Function Header File Description\nGpt_Init Gpt.h Initializes the GPT driver.\nIcu_Init Icu.h This function initializes the driver.\nIoHwAb_Init<Init_Id> IoHwAb.h Initializes either all the IO Hardware Abstraction\nsoftware or is a part of the IO Hardware Abstraction.\nLin_Init Lin.h Initializes the LIN module.\nLinTrcv_Init LinTrcv.h Initializes the Lin Transceiver Driver module.\nOcu_Init Ocu.h Service for OCU initialization.\nPort_Init Port.h Initializes the Port Driver module.\nPwm_Init Pwm.h Service for PWM initialization.\nShutdownAllCores Os.h After this service the OS on all AUTOSAR cores is\nshut down. Allowed at TASK level and ISR level and\nalso internally by the OS. The function will never\nreturn. The function will force other cores into a\nshutdown.\nSpi_Init Spi.h Service for SPI initialization.\nStartCore Os.h It is not supported to call this function after Start\nOS(). The function starts the core specified by the\nparameter CoreID. The OUT parameter allows the\ncaller to check whether the operation was\nsuccessful or not. If a core is started by means of\nthis function StartOS shall be called on the core.\nWdg_Init Wdg.h Initializes the module.\nWdgM_PerformReset WdgM.h Instructs the Watchdog Manager to cause a\nwatchdog reset.\n⌋()\n\n### Configurable interfaces\n\n\n\n#### Callbacks from the STARTUP phase\n\n[SWS_EcuM_91001] ⌈\nService Name EcuM_AL_DriverInitBswM_<x>\nSyntax void EcuM_AL_DriverInitBswM_<x> (\nvoid\n)\nService ID [hex] 0x28\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callback shall provide BSW module initializations to be called by the BSW Mode Manager.\n▽\n141 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "301": {
    "node_id": "10fa2b97-d549-448e-a12d-4222c84f1645",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nAvailable via EcuM.h\n⌋()\nThe EcuM_AL_DriverInitBswM_<x> callbacks are called by the BSW Mode Manager\nduring initialization. The ECU Manager module configuration tool must generate a\ndefault implementation of the EcuM_AL_DriverInitBswM_<x> callbacks from the se-\nquence of modules defined in the EcuMDriverInitListBswM configuration container (see\nECUC_EcuM_00226). See also [SWS_EcuM_04142].\n[SWS_EcuM_04114] ⌈EcuM_AL_DriverInitBswM_<x> is generated for every config-\nured EcuMDriverInitListBswM. The name of the generated functions shall be EcuM_\nAL_DriverInitBswM_<x>, where <x> represents the short name of the EcuMDriverInit\nListBswM container.⌋()\n\n## Specification of the Port Interfaces\n\nThis chapter specifies the port interfaces and ports needed to access the ECU Man-\nager module over the VFB.\n\n### Ports and Port Interface for EcuM_ShutdownTarget Interface\n\n\n\n#### General Approach\n\nThe EcuM_ShutdownTarget client-server interface allows an SW-C to select a shut-\ndown target which will be respected during the next shutdown phase. Note that the\nECU Manager module does not offer a port interface to allow a SW-C to initiate shut-\ndown, however.\n\n#### Service Interfaces\n\n[SWS_EcuM_03011] ⌈\nName EcuM_ShutdownTarget\nComment A SW-C can select a shutdown target using this interface\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\n142 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "302": {
    "node_id": "fccc9b16-f5d6-4a05-9c0e-9e536a2c843d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Operation GetLastShutdownTarget\nComment Returns the shutdown target of the previous shutdown\nVariation –\nshutdownTarget\nType EcuM_ShutdownTargetType\nDirection OUT\nComment The shutdown target of the previous shutdown\nVariation –\nshutdownMode\nType EcuM_ShutdownModeType\nDirection OUT\nComment The sleep mode (if target is ECUM_SHUTDOWN_TARGET_SLEEP) or the\nreset mechanism (if target is ECUM_SHUTDOWN_TARGET_RESET) of the\nshutdown\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation GetShutdownCause\nComment Returns the selected shutdown cause as set by the operation SelectShutdownCause.\nVariation –\nshutdownCause\nType EcuM_ShutdownCauseType\nDirection OUT\nComment The selected cause of the next shutdown\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation GetShutdownTarget\nComment Returns the currently selected shutdown target for the next shutdown as set by the operation\nSelectShutdownTarget.\nVariation –\nshutdownTarget\nType EcuM_ShutdownTargetType\nDirection OUT\nComment The shutdown target of the next shutdown\nVariation –\nshutdownMode\nType EcuM_ShutdownModeType\nDirection OUT\nComment The sleep mode (if target is ECUM_SHUTDOWN_TARGET_SLEEP) or the\nreset mechanism (if target is ECUM_SHUTDOWN_TARGET_RESET) of the\nshutdown\nParameters\nVariation –\n▽\n143 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "303": {
    "node_id": "3f58c396-ae66-429e-b670-aeaf3d218125",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "△\nPossible Errors E_OK\nE_NOT_OK\nOperation SelectShutdownCause\nComment –\nVariation –\nshutdownCause\nType EcuM_ShutdownCauseType\nDirection IN\nComment The selected shutdown cause\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation SelectShutdownTarget\nComment The SW-C selects the cause corresponding to the next shutdown target\nVariation –\nshutdownTarget\nType EcuM_ShutdownTargetType\nDirection IN\nComment The selected shutdown cause\nVariation –\nshutdownMode\nType EcuM_ShutdownModeType\nDirection IN\nComment The identfier of a sleep mode (if shutdownTarget is ECUM_SHUTDOWN_\nTARGET_SLEEP) or a reset mechanism (if shutdownTarget is ECUM_\nSHUTDOWN_TARGET_RESET) as defined by configuration.\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n[SWS_EcuM_02979] ⌈The shutdownMode parameter shall determine the specific\nsleep or reset mode (see ECUC_EcuM_00132) relevant to SelectShutdownTarget,\nGetShutdownTarget and GetLastShutdownTarget. The ECU Manager module shall\nonly use the shutdownMode parameter is if the shutdownTarget parameter is equal\nto ECUM_SHUTDOWN_TARGET_SLEEP or ECUM_SHUTDOWN_TARGET_RESET,\notherwise it shall be ignored.⌋()\n144 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "304": {
    "node_id": "9fc07615-9f7e-4757-ab73-6828fbbd0846",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Port Interface for EcuM_BootTarget Interface\n\n\n\n#### General Approach\n\nA SW-C that wants to select a boot target must require the client-server interface Ecu\nM_BootTarget.\n\n#### Service Interfaces\n\n[SWS_EcuM_03012] ⌈\nName EcuM_BootTarget\nComment A SW-C that wants to select a boot target must use the client-server interface EcuM_Boot\nTarget.\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\nOperation GetBootTarget\nComment Returns the current boot target\nVariation –\ntarget\nType EcuM_BootTargetType\nDirection OUT\nComment The currently selected boot target\nParameters\nVariation –\nPossible Errors E_OK\nOperation SelectBootTarget\nComment Selects a boot target\nVariation –\ntarget\nType EcuM_BootTargetType\nDirection IN\nComment The selected boot target\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n145 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "305": {
    "node_id": "cb4686c0-7b20-467b-b88e-ef1e5314b65c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### Port Interface for EcuM_AlarmClock Interface\n\n\n\n#### General Approach\n\nA SW-C that wants to use an alarm clock must require the client-server interface Ecu\nM_AlarmClock. The EcuM_AlarmClock interface uses port-defined argument values\nto identify the user that manages its alarm clock. See [SWS_Rte_1350] in the Specifi-\ncation of RTE [2] for a description of port-defined argument values.\n\n#### Service Interfaces\n\n[SWS_EcuM_04105] ⌈\nName EcuM_AlarmClock\nComment A SW-C that wants to use an alarm clock must use the client-server interface EcuM_Alarm\nClock.\nIsService true\nVariation {ecuc(EcuM/EcuMFlexGeneral/EcuMAlarmClockPresent)} == True\n\n# E_OK Operation successful\n\n\n\n# E_NOT_OK Operation failed\n\n\n\n# ECUM_E_EARLIER_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "306": {
    "node_id": "3d1d2e81-8e36-4943-9055-26c2016e8907",
    "title": "ACTIVE",
    "level": 2,
    "type": "clause",
    "content": "An earlier alarm is already set\n\n# ECUM_E_PAST The desired point in time has already passed\n\nPossible Errors\n\n# ECUM_E_NOT_ACTIVE No active alarm found\n\nOperation AbortWakeupAlarm\nComment Aborts the wakeup alarm previously set by this user\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nECUM_E_NOT_ACTIVE\nOperation SetAbsWakeupAlarm\nComment Sets the user’s wakeup alarm to an absolute point in time\nVariation –\ntime\nType EcuM_TimeType\nDirection IN\nComment Absolute time in seconds. Note that, absolute alarms use knowledge of the\ncurrent time\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nECUM_E_EARLIER_ACTIVE\nECUM_E_PAST\n146 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "307": {
    "node_id": "30e24f94-55ae-447c-a7a8-688e9f7a8bab",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Operation SetClock\nComment Sets the EcuM clock time to the provided value\nVariation –\ntime\nType EcuM_TimeType\nDirection IN\nComment Absolute time in seconds since battery connect\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation SetRelWakeupAlarm\nComment Sets a user’s wakeup alarm relative to the current point in time\nVariation –\ntime\nType EcuM_TimeType\nDirection IN\nComment Relative time from now in seconds\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nECUM_E_EARLIER_ACTIVE\n⌋()\n\n### Port Interface for EcuM_Time Interface\n\n\n\n#### General Approach\n\nA SW-C that wants to use the time functionality of the EucM must require the client-\nserver interface EcuM_Time.\n\n#### Data Types\n\nThe EcuM_Time service does not have any specific data types.\n\n#### Service Interfaces\n\n[SWS_EcuM_04109] ⌈\n147 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "308": {
    "node_id": "47e83aca-f976-4ba2-8732-f50375a72dd4",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuM_Time\nComment –\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\nOperation GetCurrentTime\nComment Returns the current value of the EcuM clock (i.e. the time in seconds since battery connect)\nVariation –\ntime\nType EcuM_TimeType\nDirection OUT\nComment Absolute time in seconds since battery connect\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation GetWakeupTime\nComment Returns the current value of the master alarm clock (the minimum absolute time of all user\nalarm clocks)\nVariation –\ntime\nType EcuM_TimeType\nDirection OUT\nComment Absolute time in seconds for next wakeup. 0xFFFFFFFF means no active\nalarm.\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n\n### Port Interface for EcuM_StateRequest Interface\n\n[SWS_EcuM_04130] ⌈The ECU State Manager module shall provide System Services\nfor the following functionalities when the container EcuMModeHandling (see 10.2.1) is\navailable:\n•requesting RUN\n•releasing RUN\n•requesting POST_RUN\n•releasing POST_RUN\n⌋(SRS_ModeMgm_09116)\n148 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "309": {
    "node_id": "32ea93af-66b4-495b-9754-b28c24ed4fd1",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### General Approach\n\nA SW-C which needs to keep the ECU alive or needs to execute any operations before\nthe ECU is shut down shall require the client-server interface EcuM_StateRequest.\nThis interface uses port-defined argument values to identify the user that requests\nmodes. See [SWS_Rte_1350] for a description of port-defined argument values.\n\n#### Data Types\n\nNo data types are needed for this interface.\n\n#### Service Interfaces\n\n[SWS_EcuM_04131] ⌈\nName EcuM_StateRequest\nComment Interface to request a specific ECU state\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\nOperation ReleasePOSTRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation ReleaseRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation RequestPOSTRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n149 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "310": {
    "node_id": "f9a07cce-db1e-4300-8d68-02e4600ef0e9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Operation RequestRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n\n### Port Interface for EcuM_CurrentMode Interface\n\n\n\n#### General Approach\n\n[SWS_EcuM_04132] ⌈The mode port of the ECU State Manager module shall declare\nthe following modes:\n•STARTUP\n•RUN\n•POST_RUN\n•SLEEP\n•SHUTDOWN\n⌋(SRS_ModeMgm_09116)\nThis definition is a simplified view of ECU Modes that applications do need to know. It\ndoes not restrict or limit in any way how application modes could be defined. Applica-\ntions modes are completely handled by the application itself.\n[SWS_EcuM_04133] ⌈Mode changes shall be notified to SW-Cs through the RTE\nmode ports when the mode change occurs.\nThis specification assumes that the port name is currentMode and that the direct API\nof RTE will be used. Under these conditions mode changes signaled by invoking\nRte_StatusType Rte_Switch_currentMode_currentMode(\nRte_ModeType_EcuM_Mode mode)\nwhere mode is the new mode to be notified. The value range is specified by the previ-\nous requirement. The return value shall be ignored.\nA SW-C which wants to be notified of mode changes should require the mode switch\ninterface EcuM_CurrentMode.⌋()\n150 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "311": {
    "node_id": "e698629d-c072-4671-a4b8-63f44f5b602d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "#### Data Types\n\nThe mode declaration group EcuM_Mode represents the modes of the ECU State\nManager module that will be notified to the SW-Cs.\nModeDeclarationGroup EcuM_Mode {\n{ STARTUP , RUN, POST_RUN, SLEEP , SHUTDOWN }\ninitialMode = STARTUP\n};\n[SWS_EcuM_04107] ⌈\nName EcuM_Mode\nKind ModeDeclarationGroup\nCategory ALPHABETIC_ORDER\nInitial mode STARTUP\nOn transition value –\nPOST_RUN –\nRUN –\nSHUTDOWN –\nSLEEP –\nModes\nSTARTUP –\nDescription –\n⌋()\n\n#### Service Interfaces\n\n[SWS_EcuM_04108] ⌈\nName EcuM_CurrentMode\nComment Interface to read the current ECU mode\nIsService true\nVariation –\nModeGroup currentMode EcuM_Mode\n⌋()\n\n### Definition of the ECU Manager Service\n\nThis section provides guidance on the definition of the ECU Manager module Service.\nNote that these definitions can only be completed during ECU configuration (since\ncertain ECU Manager module configuration parameters determine the number of ports\n151 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "312": {
    "node_id": "97cd0bc9-38bb-4312-8865-d64a9a0513ad",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "provided by the ECU Manager module service). Also note a SW-C’s implementation\ndoes not depend on these definitions.\nIn an AUTOSAR system, there are ports both above and below the RTE. The ECU\nManager module service description defines ports provided to the RTE and the de-\nscriptions of every SW-C that uses this service must contain \"service ports\" which\nrequired these ECU Manager module ports from the RTE.\nThe EcuM provides the following ports:\n[SWS_EcuM_04111] ⌈\nName ShutdownTarget_{UserName}\nKind ProvidedPort Interface EcuM_ShutdownTarget\nDescription Provides an interface to SW-Cs to select a new shutdown target and query the current shutdown\ntarget.\nVariation UserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUserConfig/Ecu\nMFlexUser.SHORT -NAME)}\n⌋()\n[SWS_EcuM_04110] ⌈\nName BootTarget_{UserName}\nKind ProvidedPort Interface EcuM_BootTarget\nDescription Provides an interface to SW-Cs to select a new boot target and query the current boot target.\nVariation UserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUserConfig/Ecu\nMFlexUser.SHORT -NAME)}\n⌋()\n[SWS_EcuM_03017] ⌈\nName AlarmClock_{UserName}\nKind ProvidedPort Interface EcuM_AlarmClock\nDescription Provides to SW-Cs an alarm clock. The EcuM_AlarmClock port uses port-defined argument values\nto identify the user that manages its alarm clock.\nType EcuM_UserTypePort Defined\nArgument Value(s) Value {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUser\nConfig/EcuMFlexUser.value)}\nVariation {ecuc(EcuM/EcuMFlexGeneral/EcuMAlarmClockPresent)} == true\nUserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMAlarm\nClock.SHORT -NAME)}\n⌋()\n[SWS_EcuM_04113] ⌈\n152 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "313": {
    "node_id": "e95f559a-f6da-463f-9fc0-fb78be952bc8",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name time\nKind ProvidedPort Interface EcuM_Time\nDescription Provides the EcuM’s time service to SWCs\nVariation –\n⌋()\n[SWS_EcuM_04135] ⌈\nName StateRequest_{UserName}\nKind ProvidedPort Interface EcuM_StateRequest\nDescription Provides an interface to SW-Cs to request state changes of the ECU state. The port uses\nport-defined argument values to identify the user.\nType EcuM_UserTypePort Defined\nArgument Value(s) Value {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUser\nConfig/EcuMFlexUser.value)}\nVariation UserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUserConfig/Ecu\nMFlexUser.SHORT -NAME)}\n⌋()\n[SWS_EcuM_04112] ⌈\nName currentMode\nKind ProvidedPort Interface EcuM_CurrentMode\nDescription –\nVariation –\n⌋()\nThe EcuM provides the following types:\n[SWS_EcuM_91004] ⌈\nName EcuM_UserType\nKind Type\nDerived from uint8\nDescription Unique value for each user.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04102] ⌈\n153 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "314": {
    "node_id": "d8713cad-ba61-47a3-aa97-eb13afa47b9b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuM_TimeType\nKind Type\nDerived from uint32\nDescription This data type represents the time of the ECU Manager module.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[] ⌈\nName EcuM_BootTargetType\nKind Type\nDerived from uint8\nECUM_BOOT_TARGET_APP 0 The ECU will boot into the\napplication\nECUM_BOOT_TARGET_OEM_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "315": {
    "node_id": "215e8edf-fd92-4e54-97ad-a2d65f79f058",
    "title": "BOOTLOADER",
    "level": 2,
    "type": "clause",
    "content": "# The ECU will boot into the OEM\n\nbootloader\nRange\nECUM_BOOT_TARGET_SYS_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "316": {
    "node_id": "46db3185-87a1-4be0-a165-a079c8f94abf",
    "title": "BOOTLOADER",
    "level": 2,
    "type": "clause",
    "content": "# The ECU will boot into the system\n\nsupplier bootloader\nDescription This type represents the boot targets the ECU Manager module can be configured with. The\ndefault boot target is ECUM_BOOT_TARGET_OEM_BOOTLOADER.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04045] ⌈\nName EcuM_ShutdownCauseType\nKind Type\nDerived from uint8\nECUM_CAUSE_UNKNOWN 0 No cause was set.\nECUM_CAUSE_ECU_STATE 1 ECU state machine entered a\nstate for shutdown\nECUM_CAUSE_WDGM 2 Watchdog Manager detected a\nfailure\nRange\nECUM_CAUSE_DCM 3 Diagnostic Communication\nManager requests a shutdown\ndue to a service request\nDescription This type describes the cause for a shutdown by the ECU State Manager. It can be extended by\nconfiguration.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04101] ⌈\n154 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "317": {
    "node_id": "492ef40a-0e5d-4b4c-91fc-1bd2e3296575",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuM_ShutdownModeType\nKind Type\nDerived from uint16\n{ecuc(EcuM/EcuMConfiguration/\nEcuMFlexConfiguration/Ecu\nMResetMode.SHORT -NAME)}\n{256 + ecuc(EcuM/Ecu\nMConfiguration/Ecu\nMFlexConfiguration/\nEcuMResetMode.Ecu\nMResetModeId)}\nConfigured Reset ModesRange\n{ecuc(EcuM/EcuMConfiguration/\nEcuMCommonConfiguration/Ecu\nMSleepMode.SHORT -NAME)}\n{ecuc(EcuM/ Ecu\nMConfiguration/Ecu\nMCommon\nConfiguration/Ecu\nMSleepMode.Ecu\nMSleepModeId)}\nConfigured Sleep Modes\nDescription This data type represents the modes of the ECU Manager module.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04136] ⌈\nName EcuM_ShutdownTargetType\nKind Type\nDerived from uint8\nECUM_SHUTDOWN_TARGET_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "318": {
    "node_id": "ad648dff-db00-4690-9675-f5bb3aa3bda6",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "0x0 –\nECUM_SHUTDOWN_TARGET_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "319": {
    "node_id": "a9e19a70-b48d-4e0f-837d-680463e827e9",
    "title": "RESET",
    "level": 2,
    "type": "clause",
    "content": "0x1 –\nRange\nECUM_SHUTDOWN_TARGET_",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "320": {
    "node_id": "90267e49-ed7f-46f5-a204-9dfafe71c3ae",
    "title": "OFF",
    "level": 2,
    "type": "clause",
    "content": "0x2 –\nDescription –\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04094] ⌈In the case of a MultiCore ECU, the EcuM AUTOSAR service\n(Standardized AUTOSAR Interfaces) may be offered on one or more cores.⌋()\nAlthough the EcuM service interfaces are available on every core (see section 7.9 Multi\nCore for details), the EcuC allows the provided ports to be bound to the interface on\na particular partition, and therefore to a particular core (see the Specification of ECU\nConfiguration [5]) and only that port will be visible to the VFB. In the case of Multi-Core,\nthis should be bound to the master core. SW-Cs and CDDs on the ECU that need to\naccess EcuM Services can access the master core via the IOC as generated by the\nRTE.\n[SWS_EcuM_04095] ⌈In the case of a MultiCore ECU, the EcuM C-API Interfaces\n(Standardized Interfaces) which are used by other BSW modules shall be offered in\nevery partition a EcuM runs in.⌋()\n155 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "321": {
    "node_id": "bea073a6-a6b1-4061-b21b-47db6637736e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "The C-API interfaces which are used by other BSW module to communicate with the\nEcuM are offered by every EcuM instance because every EcuM instance can do some\nindependent actions. If BSW modules want to use the EcuM but are inside partitions\nthat contain no own EcuM instance. These modules can use the SchM functions to\ncross partition boundaries.\n\n## API Parameter Checking\n\n[SWS_EcuM_03009] ⌈If Development Error Detection is enabled for this module, then\nall functions shall test input parameters and running conditions and use the following\nerror codes in an adequate way:\n•ECUM_E_UNINIT\n•ECUM_E_SERVICE_DISABLED\n•ECUM_E_PARAM_POINTER\n•ECUM_E_INVALID_PAR\nSpecific development errors are listed in the functions, where they apply.⌋(SRS_BSW_-\n00323)\n156 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "322": {
    "node_id": "c8ebffe9-a34b-4ffd-8d24-06757d530ecc",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Sequence Charts\n\n\n\n## State Sequences\n\nSequence charts showing the behavior of the ECU Manager module in various states\nare contained in the flow of the specification text. The following list shows all sequence\ncharts presented in this specification.\n•Figure 7.3 - STARTUP Phase\n•Figure 7.4 - StartPreOS Sequence\n•Figure 7.5 - StartPostOS Sequence\n•Figure 7.7 - SHUTDOWN Phase\n•Figure 7.8 - OffPreOS Sequence\n•Figure 7.9 - OffPostOS Sequence\n•Figure 7.10 - SLEEP Phase\n•Figure 7.11 - GoSleep Sequence\n•Figure 7.12 - Halt Sequence\n•Figure 7.13 - Poll Sequence\n•Figure 7.14 - WakeupRestart Sequence\n•Figure 7.16 - The WakeupValidation Sequence\n\n## Wakeup Sequences\n\nThe Wake-up Sequences show how a number of modules cooperate to put the ECU\ninto a sleep state to be able to wake up and startup the ECU when a wake up event\nhas occurred.\n\n### GPT Wakeup Sequences\n\nThe General Purpose Timer (GPT) is one of the possible wake up sources. Usually\nthe GPT is started before the ECU is put to sleep and the hardware timer causes an\ninterrupt when it expires. The interrupt wakes the microcontroller, and executes the\ninterrupt handler in the GPT module. It informs the ECU State Manager module that a\nGPT wake up has occurred. In order to distinguish different GPT channels that caused\nthe wake up, the integrator can assign a different wake up source identifier to each\nGPT channel. Figure 9.1 shows the corresponding sequence of calls.\n157 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "323": {
    "node_id": "d8cd4565-dfc8-42b2-a01b-aa2f90cf7bb2",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Integration Code «Peripheral»\nGPT Hardware\n«module»\nMcu\n«module»\nEcuM\n«module»\nOs\n«module»\nGpt\n\u0001 \u0002 \u0004 \u0005 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \n \u000e \u000b \u000b \u000f \u0010 \u0004 \u0011 \u0006 \u0012 \b \u0013 \n \u000e \f \u0006 \t \u0012 \u0014 \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u000e \u0004 \u000e \u0014 \u000f \u0010 \u0004 \u0012 \u0014 \u0014 \n \f \u0006 \t \u0004 \u0005 \u0012 \u0004 \u0004 \u0005 \u0006 \u0015 \f \u0010 \u0016 \f \u0012 \u0017 \u0002 \u000b \u0010 \n \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014\n\u0012 \u0002 \u0004 \u0006 \f\n\u0018 \u0019 \u001a \u001b\n\u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f \u0011 \u0006 \b \u0012 \n \u0014 \u0006 \f \u0006\n\u001c\n\u0014 \b \u0005 \u0006 \t \n \u000b \u000e \u000f \u0016 \u0004 \u0012\n\u001d\n\u0006 \u0014 \u0015 \u000b \u0012 \b \u0006 \u0012 \u0002 \u0004 \u0006 \f \u0010 \b \b \n \f \f \u0006 \u000f \b \u0006 \u0010 \u0002 \u0012 \u000f \u0001 \u0007\n\u001e \u001f\n\u0012 \u0004\n !",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "324": {
    "node_id": "63af778e-d83b-4be3-bb51-227a2f2060fb",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "325": {
    "node_id": "09853966-f00e-48f4-9b94-86df5db98f41",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "\" # \u0006 \b \n \u0004 \u000e \u0010 \u000f \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014 \u0012 \u0002 \u0004 \u0006 \f\n\u0018 \u0019 \u001a \u001b\n\u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f\n!",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "326": {
    "node_id": "02c86718-08a0-4381-a50f-ff84dfa23b17",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "327": {
    "node_id": "5f67ef3c-0815-44a6-be15-fe4be09c4368",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "\u0006 \u000b \u0006 \u0012 \u0014 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u0004 \u0010 \u0012 \u000b \u000b \u0010 \n \u0010 \u0004 \u0005 \u0006 \f \u0004 \u0012 \u0014\n\u001d\n\u0014 \u0004 \u0010 \f \n \u000f\n!\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nMcu_SetMode(Mcu_ModeType)\nDisableAllInterrupts()\nGpt_SetMode(Gpt_ModeType)\nGpt_SetMode(Gpt_ModeType)\nEnableAllInterrupts()\nEnableAllInterrupts()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources()\nGpt_CheckWakeup()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nReturn from\ninterrupt()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nGpt_EnableWakeup(Gpt_ChannelType)\nReleaseResource()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nWakeup\ninterrupt()\nMcu_SetMode()\nGpt_DisableWakeup(Gpt_ChannelType)\nMcu_SetMode()\nGpt_CheckWakeup(EcuM_WakeupSourceType)\nGpt_StartTimer(Gpt_ChannelType,\nGpt_ValueType)\nDisableAllInterrupts()\nMcu_SetMode(Mcu_ModeType)\nGpt_EnableWakeup()\nEcuM_CheckWakeup()\nGetResource()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nGpt_DisableWakeup()\nEcuM_SetWakeupEvent()\nEcuM_EnableWakeupSources()\nFigure 9.1: GPT wake up by interrupt\nIf the GPT hardware is capable of latching timer overruns, it is also possible to poll the\nGPT for wake ups as shown in Figure 9.2 .\n158 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "328": {
    "node_id": "0097ff7e-977d-4b8b-9b93-fa9f6f6c88cb",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \t \n \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \t \u000e \u000f \u0006 \u0007 \u0010 \u0007 \u0011 \t \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013\n\u0015\n\u0006 \u000e\n\u0016\n\u0006 \u0004 \u0011 \u0011 \u0005 \u0011\n\u0017 \u0018\n«module»\nEcuM\nIntegration Code «module»\nOs\n«module»\nMcu\n«module»\nGpt",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "329": {
    "node_id": "55edfccd-c3ad-4743-b87b-506b17d8e093",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "330": {
    "node_id": "78b1ddd0-b072-4cc0-8fc7-5b59f94abede",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "331": {
    "node_id": "faf5b1c0-ddb1-41f3-ab44-16f1da2f2122",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "loop WHILE no pending/validated events\nopt Wakeup detected\n\u0019\n\u0002 \u0004\n\u001a\n\u000b \u0007 \t\n\u0019\n\u000e \f \u0007\n\u001b \u001c\n\u000f \u0004 \t \u0013 \t \n \u0007\n\u0016\n\u0005 \u0002 \u0006 \u000e \u0002 \u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006 \u0005 \u0011\n\u0013 \u000e\n\u0016\n\u0007 \u000f \u000e \u001d \u0007 \u0006 \u0013 \u0012 \u0010\u0005 \u0011\n\u0017 \u0016\n\u000e \f \u0007\n\u0018\n\u001e \u0011 \t \n \u0005 \u0013\n\u0016\n\u000e \f \u0007\n\u0013 \u000e\n\u0015\n\t \u001d \u0012 \u0006 \u0007 \u0007\n\u001f\n\u0007 \u0002 \u0004 \t \u0005 \u000e \u0011 \u0002 \u000e \u0011 \t \u0005 \u0011 \u0004 \u0007 \u0013\n !\n\u0004 \t \u001d \u0005 \t \n\u0006 \u0007 \f \u0004 \u0002 \u0007 \f \u0002 \n \u000e \u0002 \u0014 \u0013 \u000f \u0007 \u0007 \f\n\u0018\n\"\n\u0007 \n \u0007 \u0012 \u0013 \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \u0006 \u0007 \u0013 \u000e \u0004 \u0006 \u0002 \u0007 \t \u000e \u0012 \n \n \u000e \u001d \u000e \t \n \u0007 \u0006\n\t \u0012 \u0013 \u0014 \u0013 \t \u000e \u0006 \u0004 \u0011\n\u0018\nEcuM_SetWakeupEvent()\nGpt_StartTimer(Gpt_ChannelType,\nGpt_ValueType)\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nGpt_EnableWakeup()\nGpt_DisableWakeup()\nGpt_CheckWakeup()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nReleaseResource()\nMcu_SetMode()\nEcuM_EnableWakeupSources()\nGpt_EnableWakeup(Gpt_ChannelType)\nEnableAllInterrupts()\nGpt_DisableWakeup(Gpt_ChannelType)\nMcu_SetMode(Mcu_ModeType)\nEcuM_SleepActivity()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources()\nDisableAllInterrupts()\nEcuM_SleepActivity()\nMcu_SetMode()\nGpt_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nGetResource()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nGpt_SetMode(Gpt_ModeType)\nGpt_SetMode(Gpt_ModeType)\nEcuM_CheckWakeup()\nFigure 9.2: GPT wake up by polling\n159 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "332": {
    "node_id": "7c637a24-6b59-4fd6-b59a-5d816f8b7f07",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### ICU Wakeup Sequences\n\nThe Input Capture Unit (ICU) is another wake up source. In contrast to GPT, the ICU\ndriver is not itself the wake up source. It is just the module that processes the wake\nup interrupt. Therefore, only the driver of the wake up source can tell if it was re-\nsponsible for that wake up. This makes it necessary for EcuM_CheckWakeup (see [\nSWS_EcuM_02929]) to ask the module that is the actual wake up source. In order to\nknow which module to ask, the ICU has to pass the identifier of the wake up source to\nEcuM_CheckWakeup. For shared interrupts the Integration Code may have to check\nmultiple wake up sources within EcuM_CheckWakeup (see [SWS_EcuM_02929]). To\nthis end, the ICU has to pass the identifiers of all wake up sources that may have\ncaused this interrupt to EcuM_CheckWakeup. Note that, EcuM_WakeupSourceType\n(see 8.2.3 EcuM_WakeupSourceType) contains one bit for each wake up source, so\nthat multiple wake up sources can be passed in one call. Figure 9.3 shows the result-\ning sequence of calls. Since the ICU is only responsible for processing the wake up\ninterrupt, polling the ICU is not sensible. For polling the wake up sources have to be\nchecked directly as shown in Figure 38.\n160 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "333": {
    "node_id": "d0b4a32c-eff8-4282-9ff2-035151109acc",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\nIntegration Code «module»\nWakeup Source\n«module»\nOs\n«module»\nMcu\n«module»\nIcu\n«Peripheral»\nICU Hardware",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "334": {
    "node_id": "65e9214e-7a71-4dfb-bb28-9a1bc1687fe3",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "335": {
    "node_id": "1bc5f8ba-4178-486d-a900-d31302291265",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "336": {
    "node_id": "36c68724-61cb-4ef1-9ac9-7d56f1d790a4",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "337": {
    "node_id": "d38900a4-77f3-495e-bb5d-29304c5534fe",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0002 \u0004 \u0005 \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \f \u0002 \u0005 \n \u000b \f \b \u0002 \u000e \n \u0004 \u0003 \u0003 \n \u000f \n \u000e \t \u0002 \f \u000e \u0004 \u0005 \u0010 \u0005 \u000e \n \f \u000b \u0011 \u0012\n\u0013 \u0014 \u0002 \b \u000b \u000e \u0015 \n \u0011 \b \n \u0011 \u000e \u0015 \u0011 \u000b \u0002 \u0005 \u0004 \u0016 \u000e \u0002 \f \u0017 \u0018 \u0019 \u001a \u0015 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0015 \n \u0011 \u0012\n\u001b\n\u0016 \u000e \t \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \u000f \u0015 \u0003 \u0003 \u0011 \n \u000e\n\u001c\n\u0002 \u0004 \b\n\u001d\n\u000b \u0015 \f \u0002 \n \u0004 \u0005 \f \u0002 \u0005 \n \u000b \f \b \u0002 \u0015 \u000e \u0015 \u0005 \u0011 \n \u000e \u0004 \u0005 \u0005 \u000b \f \u0002 \n \u000e \t \u0004 \u000e \u000e \t \u0002\n\u001e\n\f \n\n\u001f\n\f \u0004\n \n\u0016 \u0003 \n \u000f \b \n \u0011 \u000e \u0015 \u0011 \u000b \u0002 \u0005 \u0004 \u0016 \u000e \u0002 \f\n\u0017 \u0018 \u0019 \u001a \u0015 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0015 \n \u0011\n\u001c\n\u0002 \b \u0004 \u000b \u0005 \u0002 \f \u0002 ! \u0005 \b \t \u0002 \n \u000b \u0003 \u0015 \u0011\n\u001f\n\u000e \u0004 \u0010 \u0002 \u0005\n\u001e\n\u0003 \u0004 \b \u0002 \u0004 \u0016 \u000e \u0002 \f \n \b \b \u000b \f \f \u0002 \u0011 \b \u0002 \n \u0016 \u0004 \u0011\n\u001b\n\u0007 \u0001 \" \u0004 \u000e # \u0012\nIcu_DisableWakeup()\n<Module>_CheckWakeup()\nIcu_EnableWakeup()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources()\nReleaseResource()\nEnableAllInterrupts()\nEcuM_CheckWakeup()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nDisableAllInterrupts()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nEcuM_DisableWakeupSources()\nMcu_SetMode()\nIcu_DisableWakeup(Icu_ChannelType)\n<Module>_CheckWakeup\n(EcuM_WakeupSourceType)\nIcu_EnableWakeup(Icu_ChannelType)\nWakeup\ninterrupt()\nMcu_SetMode()\nactivate\nPLL()\nGetResource()\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nReturn from\ninterrupt()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nEnableAllInterrupts()\nEcuM_SetWakeupEvent()\nDisableAllInterrupts()\nFigure 9.3: ICU wake up by interrupt\n161 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "338": {
    "node_id": "8f4388e3-3a3f-4b96-84e8-483059da481e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### CAN Wakeup Sequences\n\nOn CAN a wake up can be detected by the transceiver or the communication con-\ntroller using either an interrupt or polling. Wake up source identifiers should be shared\nbetween transceiver and controller as the ECU State Manager module only needs to\nknow the network that has woken up and passes that on to the Communication Man-\nager module.\nIn interrupt case or in shared interrupt case it is not clear which specific wake up\nsource (CAN controller, CAN transceiver, LIN controller etc.) detected the wake\nup. Therefore the integrator has to assign the derived wakeupSource of EcuM_\nCheckWakeup(wakeupSource), which could stand for a shared interrupt or just for\nan interrupt channel, to specific wake up sources which are passed to CanIf_Check\nWakeup(WakeupSource). So here the parameters wakeupSource from EcuM_Check\nWakeup() could be different to WakeupSource of CanIf_CheckWakeup or they could\nequal. It depends on the hardware topology and the implementation in the integrator\ncode of EcuM_CheckWakeup().\nDuring CanIf_CheckWakeup(WakeupSource) the CAN Interface module (CanIf) will\ncheck if any device (CAN communication controller or transceiver) is configured with\nthe value of \"WakeupSource\". If this is the case, the device is checked for wake up via\nthe corresponding device driver module. If the device detected a wake up, the device\ndriver informs EcuM via EcuM_SetWakeupEvent(sources). The parameter \"sources\"\nis set to the configured value at the device. Thus it is set to the value CanIf_Check\nWakeup() was called with.\nMultiple devices might be configured with the same wake up source value. But if de-\nvices are connected to different bus medium and they are wake-able, it makes sense\nto configure them with different wake up sources.\nThe following CAN Wake-up Sequences are partly optional, because there is no spec-\nification for the \"Integration Code\". Thus it is implementation specific if e.g. during Ecu\nM_CheckWakeup() the CanIf is called to check the wake up source.\n162 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "339": {
    "node_id": "8f76bd7b-a0be-459b-860e-1d7fd262f954",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«Peripheral»\nCAN Transceiver\nHardware\n«Peripheral»\nCanController\n«module»\nCanTrcv\n«module»\nCan\n«module»\nCanIf\n«module»\nIcu\n«module»\nMcu\nIntegration\nCode\n«module»\nEcuM\n«module»\nOs\n\u0001 \u0002 \u0003 \u0002 \u0004 \u0005 \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \f \u0002 \u0005 \n \u000b \f \b \u0002 \u000e \n \u0004 \u0003 \u0003 \n \u000f \n \u000e \t \u0002 \f \u000e \u0004 \u0005 \u0010 \u0005 \u000e \n \f \u000b \u0011 \u0012\n\u0013 \u0014\n\u000e \t \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \u000f\n\u0015\n\u0003 \u0003 \u0011 \n \u000e\n\u0016\n\u0002 \u0004 \b\n\u0017\n\u000b\n\u0015\n\f \u0002 \n \u0004 \u0005 \f \u0002 \u0005 \n \u000b \f \b \u0002\n\u0015\n\u000e\n\u0015\n\u0005 \u0011 \n \u000e \u0004 \u0005 \u0005 \u000b \f \u0002 \n \u000e \t \u0004 \u000e \u000e \t \u0002\n\u0018\n\f \n\n\u0019\n\f \u0004\n\u001a \u0014\n\u0003 \n \u000f \b \n \u0011 \u000e\n\u0015\n\u0011 \u000b \u0002 \u0005 \u0004\n\u0014\n\u000e \u0002 \f\n\u001b \u001c \u001d \u001e \u0015\n\u0011 \u0005 \u000e \f \u000b \b \u000e\n\u0015\n\n \u0011\n\u0016\n\u0002 \b \u0004 \u000b \u0005 \u0002 \f \u0002\n\u001f\n\u0005 \b \t \u0002 \n \u000b \u0003\n\u0015\n\u0011\n\u0019\n\u000e \u0004 \u0010 \u0002 \u0005\n\u0018\n\u0003 \u0004 \b \u0002 \u0004\n\u0014\n\u000e \u0002 \f \n \b \b \u000b \f \f \u0002 \u0011 \b \u0002 \n\n\u0014\n\u0004 \u0011\n\u0013\n\u0007 \u0001\n \n\u0004 \u000e\n!\n\u0012",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "340": {
    "node_id": "39753088-6331-4565-9ada-f4c4920096bb",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "\" #\n\u0002 \b \u000b \u000e\n\u0015\n\n \u0011 \b \n \u0011 \u000e\n\u0015\n\u0011 \u000b \u0002 \u0005 \u0004\n\u0014\n\u000e \u0002 \f\n\u001b \u001c \u001d \u001e \u0015\n\u0011 \u0005 \u000e \f \u000b \b \u000e\n\u0015\n\n \u0011 \u0012\n \n\u0004 \u0011 \u0007\n$\n\u000f\n\u0015\n\u0003 \u0003 \t \u0004\n%\n\u0002 \b \u0004 \u0003 \u0003 \u0002 \n \n\u0004 \u0011\n\u0013 \u0014 &\n\u0007 \u0002 \u000e\n \n\n \u0011 \u000e \f \n \u0003 \u0003 \u0002 \f\n$\n\n \n \u0002 \u0004 \u0011 \n \n\u0004 \u0011\n\u0013 \u0014 &\n\u0007 \u0002 \u000e\n\u001e\n\f \u0004 \u0011 \u0005 \b \u0002\n\u0015 %\n\u0002 \f\n$\n\n \n \u0002 \u000f \t \u0002 \u0011\n\u0019\n\n\n\u0015\n\u0011\n\u0019\n\u000e \n \u0005 \u0003 \u0002 \u0002\n\u0018\n\u0012",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "341": {
    "node_id": "a46da1cd-cadf-4579-98b0-0c7d0c5c6112",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "342": {
    "node_id": "25bc9061-6378-4e76-bcfa-3dbaa2f1e909",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "343": {
    "node_id": "1f705594-7972-43db-b8fc-c14bdad01a77",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "344": {
    "node_id": "cc2c7851-a824-4616-9bb1-24cdb5bfc3b3",
    "title": "WAKEUP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "345": {
    "node_id": "908b7aaf-dfdf-4515-bd2d-1ce572a802c7",
    "title": "VALIDATION",
    "level": 2,
    "type": "clause",
    "content": "EcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nCanIf_SetTrcvWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nCanTrcv_SetWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nWakeup\ninterrupt()\nCanTrcv_SetWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nMcu_SetMode()\nactivate\nPLL()\nGetResource(uint8)\nCanIf_CheckWakeup(EcuM_WakeupSourceType):\nStd_ReturnType\nReturn from\ninterrupt()\nEnableAllInterrupts()\nCanTrcv_CheckWakeup(uint8):\nStd_ReturnType\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nReleaseResource(uint8)\nEnableAllInterrupts()\nCanIf_SetTrcvWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nMcu_SetMode\n(Mcu_ModeType)\nDisableAllInterrupts()\nIcu_DisableWakeup(Icu_ChannelType)\nDisableAllInterrupts()\nIcu_EnableWakeup(Icu_ChannelType)\nFigure 9.4: CAN transceiver wake up by interrupt\n163 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "346": {
    "node_id": "c4eacaa5-428e-4382-a176-eacdc96a2af0",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Figure 9.4 shows the CAN transceiver wakeup via interrupt. The interrupt is usually\nhandled by the ICU Driver as described in Chapter 9.2.2.\nA CAN controller wakeup by interrupt works similar to the GPT wakeup. Here the\ninterrupt handler and the CheckWakeup functionality are both encapsulated in the CAN\nDriver module, as shown in Figure 9.5 .\n«Peripheral»\nCanController\n«module»\nCanTrcv\n«module»\nIcu\nIntegration\nCode\n«module»\nCanIf\n«module»\nCan\n«module»\nMcu\n«module»\nEcuM\n«module»\nOs\n«Peripheral»\nCAN Transceiver\nHardware",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "347": {
    "node_id": "688b1fd4-042c-4da3-b113-0c0c5b02653b",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e \u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t \u0013",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "348": {
    "node_id": "ab92142d-9fe6-499a-8863-ccd8ee60acbd",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "\u0014 \f \t \u0015 \u0016 \u0017 \u0007 \u0018 \u0018 \u0019 \f \u001a \u0003 \u0004 \f \u0018 \u0018 \u0003 \u001b \u0014 \f \t \u001c \n \u001d \u0015 \u0003 \u0006 \u0014 \b \t \u0006 \u000e \b \u0018 \u0018 \u0003 \u000e \u0016 \b \u001b \u0003 \f \t \u001b \u0014 \f \t \u001c \n \u001d \u0015 \u0003 \u0006 \u0012 \u000e \f \t \u000b \u0004 \u0003 \u0007 \u001a \u0003 \u000e \u0016 \b \u001b \u0003 \u0017 \u0019 \u0003 \t \u001e \b \u0007 \t \u001e \u0006 \b \u000b \u0018 \u0003 \u0003 \u001f \u0013",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "349": {
    "node_id": "0899034e-9321-409f-8b59-ef44017b0d32",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "\u0006 \u0019 \u0003 \u0015 \u0004 \u0019 \u0003 \u001b \u0005 \u0018 \u0003 \u000e \u0017 \u0007 \u0018 \u0018 \t \b \u0006  \u0003 \f \u0004 ! \u0005 \u0007 \u000e \u0003 \u001b \f \u000b \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0007 \u0006 \u0007 \u000b \t \b \u0006 \f \u000b \u000b \u0005 \u000e \u0003 \u001b \u0006 \u0019 \f \u0006 \u0006 \u0019 \u0003 \u001f \u000e \b \u001e \u000e \f \" \n \u0018 \b \u0017 \u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e\n\u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t  \u0003 \u0004 \f \u0005 \u000b \u0003 \u000e \u0003\n#\n\u000b \u0004 \u0019 \u0003 \u001b \u0005 \u0018 \u0007 \t \u001e \u0006 \f\n$\n\u0003 \u000b \u001f \u0018 \f \u0004 \u0003 \f \n \u0006 \u0003 \u000e \b \u0004 \u0004 \u0005 \u000e \u000e \u0003 \t \u0004 \u0003 \b \n \f \t \u001c \u0015\n%\n\u0014 \f \u0006\n&\n\u0013",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "350": {
    "node_id": "31bc1072-9cb5-47d4-92f1-c63ae0ad7f76",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "351": {
    "node_id": "5b12a8cd-c6e7-4e13-88e8-5284cf8896bc",
    "title": "WAKEUP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "352": {
    "node_id": "622a81ef-3b29-4267-b5bd-a2cebf2db988",
    "title": "VALIDATION",
    "level": 2,
    "type": "clause",
    "content": "%\n\u0003 \u0018 \u0003 \f \u000b \u0003 \u0015 \u0004 \u0019 \u0003 \u001b \u0005 \u0018 \u0003 \u000e \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0006 \b \f \u0018 \u0018 \b \u0017 \b \u0006 \u0019 \u0003 \u000e \u0006 \f \u000b\n$\n\u000b \u0006 \b \u000e \u0005 \t \u0013\nDisableAllInterrupts()\nEnableAllInterrupts()\nCanIf_CheckWakeup(EcuM_WakeupSourceType):\nStd_ReturnType\nReleaseResource(uint8)\nGetResource(uint8)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nDisableAllInterrupts()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nReturn from\ninterrupt()\nActivate\nPLL()\nMcu_SetMode()\nCan_CheckWakeup(Std_ReturnType, uint8)\nWakeup\ninterrupt()\nFigure 9.5: CAN controller wake up by interrupt\n164 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "353": {
    "node_id": "a3a604ab-6750-4a68-b53c-961beaa9203c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Wake up by polling is possible both for CAN transceiver and controller. The ECU State\nManager module will regularly check the CAN Interface module, which in turn asks\neither the CAN Driver module or the CAN Transceiver Driver module depending on the\nwake up source parameter passed to the CAN Interface module, as shown in Figure\n9.6 .\n165 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "354": {
    "node_id": "22bcfff3-ae8f-4303-89c6-f9ff46b16cc5",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \t \n \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \t \u000e \u000f \u0006 \u0007 \u0010 \u0007 \u0011 \t \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \u0015 \u0006 \u000e \u0016 \u0006 \u0004 \u0011 \u0011 \u0005 \u0011 \u0017 \u0018\n«Peripheral»\nCAN Transceiver\nHardware\n«Peripheral»\nCanController\n«module»\nCanTrcv\n«module»\nCan\n«module»\nCanIf\n«module»\nIcu\n«module»\nMcu\nIntegration Code«module»\nEcuM\n«module»\nOs",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "355": {
    "node_id": "02f2be7a-e894-44b2-806f-80b0db4c62f2",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "356": {
    "node_id": "683ae3fd-8c6f-43f6-a440-3ef21881e8ac",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "357": {
    "node_id": "08b35750-be24-4bd7-94fa-f7a08c99412b",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "358": {
    "node_id": "99ecae74-fb2a-4e65-a6c8-bbd5df0d08cc",
    "title": "WAKEUP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "359": {
    "node_id": "25bb964c-f926-4add-9321-be15dadef63d",
    "title": "VALIDATION",
    "level": 2,
    "type": "clause",
    "content": "loop WHILE no pending/validated events\nalt WakeupSource parameter of CanIf_CheckWakeup()\n[CAN Controller]\n[CAN Transceiver]\n\u0019\n\u0012 \u0011 \u000b\n\u001a \u001b\n\u0005 \n \n \n \u0012 \u0010 \u0007 \u0002 \u0012 \n \n \u0007 \f\n\u0019\n\u0012 \u0011\n\u001c\n\u0015\n\u001d\n\u000b \u0007 \t\n\u0019\n\u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006\n\u001a\n\u000e \f \u0007 \u0012 \u0011 \f\n\u0019\n\u0012 \u0011\n\u001c\n\u0015\n\u001d\n\u000b \u0007 \t\n\u001e\n\u0006 \u0012 \u0011 \u0013 \u0002 \u0007 \u0005 \u0010 \u0007 \u0006\n\u001a\n\u000e \f \u0007\n\u001b\n\n \u0007 \u0011 \u0017 \u000e \u0005 \u0011 \u0017 \t \u000e \u0013 \n \u0007 \u0007 \u000f \u0018\nopt Wakeup Detected\nopt Wakeup Detected\n\u001f \u0007 \n \u0007 \u0012 \u0013 \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \u0006 \u0007 \u0013 \u000e \u0004 \u0006 \u0002 \u0007 \t \u000e \u0012 \n \n \u000e\n\u001b\n\u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \t \u000e \u0006 \u0004 \u0011 \u0018\n\u001a\n\u0002 \u0004\n\u001d\n\u000b \u0007 \t\n\u001a\n\u000e \f \u0007\n !\n\u000f \u0004 \t \u0013 \t \n \u0007 \u0016 \u0005 \u0002 \u0006 \u000e \u0002 \u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006 \u0005 \u0011\n\u0013 \u000e \u0016 \u0007 \u000f \u000e\n\u001b\n\u0007 \u0006 \u0013 \u0012 \u0010 \u0005 \u0011 \u0017 \u0016 \u000e \f \u0007 \u0018\n\u001c\n\u0011 \t \n \u0005 \u0013 \u0016 \u000e \f \u0007\n\u0013 \u000e \u0015 \t\n\u001b\n\u0012 \u0006 \u0007 \u0007\n\"\n\u0007 \u0002 \u0004 \t \u0005 \u000e \u0011 \u0002 \u000e \u0011 \t \u0005 \u0011 \u0004 \u0007 \u0013\n# $\n\u0004 \t\n\u001b\n\u0005 \t \n\u0006 \u0007 \f \u0004 \u0002 \u0007 \f \u0002 \n \u000e \u0002 \u0014 \u0013 \u000f \u0007 \u0007 \f \u0018\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode()\nMcu_SetMode\n(Mcu_ModeType)\nCanTrcv_CheckWakeup(Std_ReturnType, uint8)\nCan_CheckWakeup(Std_ReturnType, uint8)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_SleepActivity()\nEnableAllInterrupts()\nEnableAllInterrupts()\nGetResource(uint8)\nReleaseResource(uint8)\nDisableAllInterrupts()\nDisableAllInterrupts()\nCanIf_CheckWakeup(EcuM_WakeupSourceType):\nStd_ReturnType\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nFigure 9.6: CAN controller or transceiver wake up by polling\n166 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "360": {
    "node_id": "7478d64a-480e-4199-8348-e77baf3540cf",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "After the detection of a wake up event from the CAN transceiver or controller by either\ninterrupt or polling, the wake up event can be validated (see [SWS_EcuM_02566]).\nThis is done by switching on the corresponding CAN transceiver and controller in\nEcuM_StartWakeupSources (see [SWS_EcuM_02924]). It depends on the used\nCAN transceivers and controllers, which function calls in Integrator Code EcuM_Start\nWakeupSource are necessary. In Figure 9.7 e.g. the needed function calls to start and\nstop the wake up sources from CAN state manager module are mentioned.\nNote that, although controller and transceiver are switched on, no CAN message will\nbe forwarded by the CAN interface module (CanIf) to any upper layer module.\nOnly when the corresponding PDU channel modes of the CanIf are set to \"Online\", it\nwill forward CAN messages.\nThe CanIf recognizes the successful reception of at least one message and\nrecords it as a successful validation. During validation the ECU State Manager\nmodule regularly checks the CanIf in Integrator Code EcuM_CheckValidation (see\n[SWS_EcuM_02925]).\nThe ECU State Manager module will, after successful validation, continue the normal\nstartup of the CAN network via the Communication Manager module.\nOtherwise, it will shutdown the CAN controller and transceiver in EcuM_StopWakeup\nSources (see [SWS_EcuM_02926]) and go back to sleep.\nThe resulting sequence is shown in Figure 9.7 .\n167 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "361": {
    "node_id": "de737fef-ebe7-4242-9e55-1c46f8440996",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«module»\nEcuM\n\u0001 \u0002 \u0004 \u0005 \u0006 \u0007 \b \t \t \n \u0007 \u0007 \u000b \b \f \n \u000e \f \u000f \u0010 \u000e \u0011 \u000f \u0012 \u0002 \u000f \u0007 \u000f \u0002 \u0010 \u000f \t \u000e \u0011 \n \u0010 \u0013 \u0014\n\u000e \t \u0012\n\u0015 \u0015\n\n \t \u0011 \f \u0014\n\u0015\n\n \t \n \u000f \n \n \u0010\n\u0016\n\n \u0007 \u0007 \u000e\n\u0017\n\n\u0018\nIntegration Code «module»\nMcu\n«module»\nIcu\n«module»\nCanIf\n«module»\nCanSM",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "362": {
    "node_id": "2584b217-609e-4d7c-a5bc-d6a11ec04d22",
    "title": "WAKEUP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "363": {
    "node_id": "ad84f5c9-9e7f-4f77-9759-6e4008dbdd27",
    "title": "VALIDATION",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "364": {
    "node_id": "c561c2f2-d916-4350-94de-9fce5f64dfca",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "loop Validate Wakeup Event\nalt Check Validation Result\n[SUCCESSFUL VALIDATION]\n[NO VALIDATION YET]\n[VALIDATION TIMEOUT]\nEcuM_StartWakeupSources(EcuM_WakeupSourceType)\nEcuM_ValidateWakeupEvent(EcuM_WakeupSourceType)\nStart validation\ntimeout()\nStop validation\ntimeout()\nEcuM_StopWakeupSources(EcuM_WakeupSourceType)\nCanIf_CheckValidation(EcuM_WakeupSourceType)\nCanSM_StopWakeupSource(Std_ReturnType,\nNetworkHandleType)\nEcuM_CheckValidation(EcuM_WakeupSourceType)\nDetect validation\ntimeout()\nCanSM_StartWakeupSource(Std_ReturnType,\nNetworkHandleType)\nFigure 9.7: CAN wake up validation\n168 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "365": {
    "node_id": "9b01f7a9-05a7-4a5d-a68f-d264536ed1f1",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### LIN Wakeup Sequences\n\nFigure 9.8 shows the LIN transceiver wakeup via interrupt. The interrupt is usually\nhandled by the ICU Driver as described in Chapter 9.2.2 .\n169 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "366": {
    "node_id": "1f8dab16-bed7-4f97-af8f-aa8c7c924bdd",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "«Peripher...\nLin Transceiver\nHardware\n«module»\nLinIf\n«module»\nLin\n«module»\nIcu\n«module»\nMcu\nIntegration\nCode\n«module»\nEcuM\n«module»\nOs\n«module»\nLinTrcv",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "367": {
    "node_id": "a1630ce5-1be2-4820-8023-c8c62cfd5dac",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e \u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t \u0013",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "368": {
    "node_id": "4a90fa43-0ea9-4ea3-9024-757c3b495357",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "\u0011 \u0007 \t\n\u0014 \u0015 \u0016\n\u0007\n\u0017 \u0017\n\f\n\u0017\n\u000e \u0003 \f\n\u0018 \u0019 \u001a\n\f\n\u001b\n\u0003 \u0004 \f\n\u0017 \u0017\n\u0003\n\u0018\n\u0011 \u0007 \t\n\u001c\n\n\n\u001d \u001e\n\b \u0006 \b\n\u0014 \u0017\n\u0003 \u0003\n\u001f \u0016 \u001a\n\u0003 \t \u0004\n\u001a\n\f \t\n \n\u0007 \t\n \n\u0006 \b\n! \" \u001d # \" \u0015\n\u000b \u0006 \f \u0006 \u0003 \u0013\n\u001c\n\t\n\u0014 \u0017\n\u0003 \u0003\n\u001f\n\u000b \u0006 \f \u0006 \u0003 \u0006\n\u001a\n\u0003 \u0011\n\u001c ! #\n\b \t \u0006 \u000e \b\n\u0017 \u0017\n\u0003 \u000e \u0007 \u000b\n\u0016\n\f $ \u0003 \f %\n\u0017\n\u0003 \b \u000e \t \b \u0006 %\n\u0019\n\u0004 \b \t \n \u0007\n \n\u0005 \u000e \f \u0006 \u0007 \b \t \u0013",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "369": {
    "node_id": "77254e76-3c24-43e7-b395-a6e63858f024",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "\u0006\n\u001a\n\u0003\n\u0014\n\u0004\n\u001a\n\u0003\n\u0018\n\u0005\n\u0017\n\u0003 \u000e\n\u0016\n\u0007\n\u0017 \u0017\n\t \b \u0006 % \u0003 \f \u0004 & \u0005 \u0007 \u000e \u0003\n\u0018\n\f \u000b \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0007 \u0006 \u0007 \u000b \t \b \u0006 \f \u000b \u000b \u0005 \u000e \u0003\n\u0018\n\u0006\n\u001a\n\f \u0006 \u0006\n\u001a\n\u0003\n\u001f\n\u000e \b\n \n\u000e \f ' \n\n\u0017\n\b\n\u0016\n\u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e\n\u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t % \u0003 \u0004 \f \u0005 \u000b \u0003 \u000e \u0003\n(\n\u000b \u0004\n\u001a\n\u0003\n\u0018\n\u0005\n\u0017\n\u0007 \t\n \n\u0006 \f $ \u0003 \u000b\n\u001f \u0017\n\f \u0004 \u0003 \f \n \u0006 \u0003 \u000e \b \u0004 \u0004 \u0005 \u000e \u000e \u0003 \t \u0004 \u0003 \b \n \f \t\n\u001c \u0014 ) #\n\f \u0006\n*\n\u0013\n)\n\u0003\n\u0017\n\u0003 \f \u000b \u0003\n\u0014\n\u0004\n\u001a\n\u0003\n\u0018\n\u0005\n\u0017\n\u0003 \u000e \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0006 \b \f\n\u0017 \u0017\n\b\n\u0016\n\b \u0006\n\u001a\n\u0003 \u000e \u0006 \f \u000b $ \u000b \u0006 \b \u000e \u0005 \t \u0013",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "370": {
    "node_id": "b12b6b9e-3c7a-4a50-a1a5-950fd6c552b8",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "EnableAllInterrupts()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nActivate\nPLL()\nEnableAllInterrupts()\nLinTrcv_CheckWakeup(uint8)\nMcu_SetMode()\nIcu_DisableWakeup(Icu_ChannelType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nLinIf_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nWakeup\ninterrupt()\nDisableAllInterrupts()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nIcu_EnableWakeup(Icu_ChannelType)\nReleaseResource(uint8)\nReturn from\ninterrupt()\nDisableAllInterrupts()\nGetResource(uint8)\nFigure 9.8: LIN transceiver wake up by interrupt\n170 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "371": {
    "node_id": "946cae8b-2750-4146-a257-50c5b419ce72",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "As shown in Figure 9.9 , the LIN controller wake up by interrupt works similar to the\nCAN controller wake up by interrupt. In both cases the Driver module encapsulates the\ninterrupt handler.\n«module»\nLinIf\n«module»\nLin\n«module»\nIcu\n«module»\nMcu\nIntegration Code«module»\nEcuM\n«module»\nOs\n«module»\nLinTrcv\n«Peripheral»\nLinController/UART\n\u0001 \u0002 \u0003 \u0002 \u0004 \u0005 \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \f \u0002 \u0005 \n \u000b \f \b \u0002 \u000e \n \u0004 \u0003 \u0003 \n \u000f \n \u000e \t \u0002 \f \u000e \u0004 \u0005 \u0010 \u0005 \u000e \n \f \u000b \u0011 \u0012",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "372": {
    "node_id": "751081ad-098a-4f46-a998-f25d286915eb",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "\u0013 \u0014 \u0011 \u0007 \u0015 \u000f \u0014 \u0003 \u0003 \u0004 \u0003 \f \u0002 \u0004 \n \u0016 \t \u0004 \u0017 \u0002 \b \u0004 \u0003 \u0003 \u0002 \n \u0013 \u0014 \u0011 \u0018 \u0019 \u001a \u001b \n \u000e \n \u0007 \u0003 \u0002 \u0002 \u001c \u000f \t \u0002 \u0011 \b \t \u0004 \u0011 \u001d \u0014 \u0011 \u001d \u000e \n \u001e \u001f \u001a  \u001f \u0015 \u0005 \u000e \u0004 \u000e \u0002 \u0012\n\u0018 \u0011 \u0007 \u0003 \u0002 \u0002 \u001c \u0005 \u000e \u0004 \u000e \u0002 \u000e \t \u0002 \u0013 \u0018 \u001e  \n \u0011 \u000e \f \n \u0003 \u0003 \u0002 \f \u0014 \u0005 \u000f \u0004 \u0010 \u0002 \u0004\n!\n\u0003 \u0002 \n \f \u0011 \n \u000e\n!\n\u0016 \b \n \u0011 \u0019 \u0014 \u001d \u000b \f \u0004 \u000e \u0014 \n \u0011 \u0012\n\u001e \n \u000e \t \u0014 \u0011 \u001d \u000e \n\n!\n\u0002 \n \n \u0011 \u0002 \u0014 \u0011 \u000e \t \u0014 \u0005 \b \u0004 \u0003 \u0003 \n \u000b \u000e \u0012\n\" \b \u000b \u0015 \u000f \u0014 \u0003 \u0003 \u0003 \u0004 \u000e \u0002 \f \u0014 \u0011 \u0019 \n \f #  \n # \u0015 \u0004\n!\n\n \u000b \u000e \u000e \t \u0002 \u000f \u0004 \u0010 \u0002 \u000b \u001c \u000f \t \u0014 \b \t \u0014 \u0011 \u000e \u000b \f \u0011 \u000f \u0014 \u0003 \u0003 \u0014 \u0011 \u0019 \n \f #\n\u0013 \u0014 \u0011 \u0007 \u0015\n$\n\u000f \t \u0014 \b \t \u000f \u0014 \u0003 \u0003 \u000e \t \u0002 \u0011 \b \u0004 \u0003 \u0003 \u0013 \u0014 \u0011 \u0018 \u0019 \u001a\n%\n\u0004 \u0010 \u0002 \u000b \u001c \u0012",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "373": {
    "node_id": "8aa01a5f-4724-4f26-a16b-6b9fd01aedcc",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "\u0018 \u0019 \u000e \t \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \u000f \u0014 \u0003 \u0003 \u0011 \n \u000e\n!\n\u0002 \u0004 \b & \u000b \u0014 \f \u0002 \n \u0004 \u0005 \f \u0002 \u0005 \n \u000b \f \b \u0002 \u0014 \u000e \u0014 \u0005 \u0011 \n \u000e \u0004 \u0005 \u0005 \u000b \f \u0002 \n \u000e \t \u0004 \u000e \u000e \t \u0002 \u001c \f \n \u001d \f \u0004 # \u0019 \u0003 \n \u000f \b \n \u0011 \u000e \u0014 \u0011 \u000b \u0002 \u0005 \u0004 \u0019 \u000e \u0002 \f\n' ( \u0013 ) \u0014 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0014 \n \u0011\n!\n\u0002 \b \u0004 \u000b \u0005 \u0002 \f \u0002 * \u0005 \b \t \u0002 \n \u000b \u0003 \u0014 \u0011 \u001d \u000e \u0004 \u0010 \u0002 \u0005 \u001c \u0003 \u0004 \b \u0002 \u0004 \u0019 \u000e \u0002 \f \n \b \b \u000b \f \f \u0002 \u0011 \b \u0002 \n \u0019 \u0004 \u0011 \u0018 \u0007 \u0001  \u0004 \u000e + \u0012",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "374": {
    "node_id": "4742b912-4853-4446-85af-9c0ec4750f16",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "\" , \u0002 \b \u000b \u000e \u0014 \n \u0011 \b \n \u0011 \u000e \u0014 \u0011 \u000b \u0002 \u0005 \u0004 \u0019 \u000e \u0002 \f ' ( \u0013 ) \u0014 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0014 \n \u0011 \u0012",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "375": {
    "node_id": "709c28f5-fc4d-4bfb-a101-884e9933cefa",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "EcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nDisableAllInterrupts()\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nActivate\nPLL()\nWakeup\ninterrupt()\nDisableAllInterrupts()\nLin_CheckWakeup(uint8)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nReturn from\ninterrupt()\nMcu_SetMode(Mcu_ModeType)\nEnableAllInterrupts()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode()\nMcu_SetMode(Mcu_ModeType)\nLinIf_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nFigure 9.9: LIN controller wake up by interrupt\n171 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "376": {
    "node_id": "69b86a79-4095-4676-aa22-42f66683423b",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Wake up by polling is possible for LIN transceiver and controller. The ECU State Man-\nager module will regularly check the LIN Interface module, which in turn asks either the\nLIN Driver module or the LIN Transceiver Driver module, as shown in Figure 9.10 .\n«Peripheral»\nLin Transceiver\nHardware\n«module»\nLinIf\n«module»\nLin\n«module»\nIcu\n«module»\nMcu\nIntegration Code«module»\nEcuM\n«module»\nOs\n«module»\nLinTrcv",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "377": {
    "node_id": "afdaf239-0674-43e4-90c2-13b032fcd0cb",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "378": {
    "node_id": "f779b8ca-4a6d-409f-8848-1c0ef87aceda",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "379": {
    "node_id": "d4b2039f-ef79-44b2-be39-d33335779d30",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "loop WHILE no pending/validated events\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0007 \u0002 \b \b \t \b \n \u000b \t \f \n \u000e \t \u000f \u000b \u0010 \t \b \b \u000b \f \u0001 \u0002 \u0003 \u0011 \u0012 \u0013 \u0014 \u0015 \u0016 \u0015 \u0004 \b \u000b \u000b \u0017 \u0007 \u000e \u000b \u0003 \u0010 \u000e \t \u0003 \u0018 \u0002 \u0003 \u0018 \u0016 \u0015 \u0019 \u001a \u0013 \u001b \u001a \u0005 \u001c \u0016 \t \u0016 \u000b \u001d\n\u0011 \u0003 \u0004 \b \u000b \u000b \u0017 \u001c \u0016 \t \u0016 \u000b \u0016 \u000e \u000b \u0001 \u0011 \u0019 \u001b \u0015 \u0003 \u0016 \n \u0015 \b \b \u000b \n \u0002 \u001c \u0007 \t\n\u001e\n\u000b \t\n\u001f\n\b \u000b \u0015 \n \u0003 \u0015 \u0016\n\u001f\n\n \u0010 \u0015 \u0003 \u0012 \u0002 \u0018\n \n\n \t \u0016 \u0002 \u0015 \u0003 \u001d\n\u0019 \u0015 \u0016 \u000e \u0002 \u0003 \u0018 \u0016 \u0015\n\u001f\n\u000b \f \u0015 \u0003 \u000b \u0002 \u0003 \u0016 \u000e \u0002 \u001c \u0010 \t \b \b \u0015\n \n\u0016 \u001d\nalt WakeupSource parameter of LinIf_CheckWakeup()\n!\n\u0010\n\"  \n\u0002 \n \u000b \u0016 \u000e \u000b \u0004 \u0010 \u000e \u000b \f\n \n\b \u000b \n \u0016 \u0015 \u0017 \n \u000b \u000f \u000b \u0003 \u0016 \u0015 \u0016 \u000e \u000b \n \u0016 \t \u001c\n\u001e\n\u001c \u0012 \n \u0015\n#\n\n \n\u0003 \u0003 \u0002 \u0003 \u0018 \u001d\n$ \u000b \b \u000b \t \u001c \u000b \u0004 \u0010 \u000e \u000b \f\n \n\b \u000b \n \n \u000b \u001c \u0015\n \n\n \u0010 \u000b \u0016 \u0015 \t \b \b \u0015 \u0007 \u0015 \u0016 \u000e \u000b \n \u0016 \t \u001c\n\u001e\n\u001c \u0016 \u0015 \n \n\u0003 \u001d\n\u0005 \u0010\n \n\u0013 \u0004 \u000b \u0016 \u0005 \u0015 \f \u000b\n% &\n\u0017\n \n\u0016 \u001c \u0016 \u000e \u000b\n#\n\u0002 \u0010 \n \u0015 \u0010 \u0015 \u0003 \u0016 \n \u0015 \b \b \u000b \n \u0002 \u0003\n\u001c \u0015\n#\n\u000b \u0017 \u0015 \u0007 \u000b \n \u001c \t \u000f \u0002 \u0003 \u0018\n#\n\u0015 \f \u000b \u001d \u0011 \u0003 \u0016 \u000e \u0002 \u001c\n#\n\u0015 \f \u000b\n\u001c \u0015 \u0012 \u0016 \u0007 \t \n \u000b \u000b\n'\n\u000b \u0010\n \n\u0016 \u0002 \u0015 \u0003 \u0010 \u0015 \u0003 \u0016 \u0002 \u0003\n \n\u000b \u001c\n( \u001f  \n\u0016 \u0007 \u0002 \u0016 \u000e\n\n \u000b \f\n \n\u0010 \u000b \f \u0010 \b \u0015 \u0010\n\u001e\n\u001c \u0017 \u000b \u000b \f \u001d\nGetResource(uint8)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nLin_CheckWakeup(uint8)\nLinIf_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nReleaseResource(uint8)\nLinTrcv_CheckWakeup(uint8)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\n*\nFigure 9.10: LIN controller or transceiver wake up by polling\nNote that LIN does not require wakeup validation.\n172 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "380": {
    "node_id": "bd53b22a-6c69-4351-9e95-011df02239d9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### FlexRay Wakeup Sequences\n\nFor FlexRay a wake up is only possible via the FlexRay transceivers. There are two\ntransceivers for the two different channels in a FlexRay cluster. They are treated as\nbelonging to one network and thus, there should be only one wake up source identifier\nconfigured for both channels. Figure 9.11 shows the FlexRay transceiver wakeup via\ninterrupt. The interrupt is usually handled by the ICU Driver as described in Chapter\n9.2.2.\n173 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "381": {
    "node_id": "221a02c6-e22e-4d10-8d1a-55b383d4aa07",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "\u0001 \u0002 \u0004 \u0005 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \n \u000e \u000b \u000b \u000f \u0010 \u0004 \u0011 \u0006 \u0012 \b \u0013 \n \u000e \f \u0006 \t \u0012 \u0014 \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u000e \u0004 \u000e \u0014 \u000f \u0010 \u0004 \u0012 \u0014 \u0014 \n \f \u0006 \t \u0004 \u0005 \u0012 \u0004 \u0004 \u0005 \u0006 \u0015 \f \u0010 \u0016 \f \u0012 \u0017 \u0002 \u000b \u0010 \n \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014 \u0012 \u0002 \u0004 \u0006 \f\n\u0018 \u0019 \u001a \u001b \u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f \u0011 \u0006 \b \u0012 \n \u0014 \u0006 \f \u0006 \u001c \u0014 \b \u0005 \u0006 \t \n \u000b \u000e \u000f \u0016 \u0004 \u0012 \u001d \u0006 \u0014 \u0015 \u000b \u0012 \b \u0006 \u0012 \u0002 \u0004 \u0006 \f \u0010 \b \b \n \f \f \u0006 \u000f \b \u0006 \u0010 \u0002 \u0012 \u000f \u0001 \u0007 \u001e \u001f \u0012 \u0004  !\n«Peripheral»\nFlexRay Transceiver\nHardware\n«module»\nOs\n«module»\nEcuM\nIntegration\nCode\n«module»\nMcu\n«module»\nIcu\n«module»\nFrIf\n«module»\nFr\n«module»\nFrTrcv\n«Peripheral»\nFlexRay\nController",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "382": {
    "node_id": "7d6009f6-c570-468c-8ac9-11384302068c",
    "title": "HALT",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "383": {
    "node_id": "d95cee91-91e8-4555-91ad-94e0dd70a005",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "384": {
    "node_id": "58001ef4-c0c6-46ce-bae1-0393c95c7e1d",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "385": {
    "node_id": "fb11b7b3-cb20-414f-9afb-1602d97d4109",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "opt Wakeup detected\n\" # \u0006 \b \n \u0004 \u000e \u0010 \u000f \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014 \u0012 \u0002 \u0004 \u0006 \f \u0018 \u0019 \u001a \u001b \u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f !\n\u001b \u0005 \u000e \u0014 \b \u0012 \u000b \u000b \u0005 \u0012 \u0014 \u0004 \u0010 \u0011 \u0006 \f \u0006 \u0015 \u0006 \u0012 \u0004 \u0006 \t \u0002 \u0010 \f \u0011 \u0010 \u0004 \u0005 $ \u000b \u0006 # \u001e \u0012 % \b \u0005 \u0012 \u000f \u000f \u0006 \u000b \u0014 \u0010 \u000f\n\u0004 \u0005 \u0006 \u0014 \u0012 \u0017 \u0006 \u000f \u0006 \u0004 \n \u0010 \f \u001d\n&\n\u000e ! \u0006 ! $ \u000b \u0006 # \u001e \u0012 % \b \u000b \n \u0014 \u0004 \u0006 \f\n' (\n\u001e \u0006 \u000b \u0006 \u0012 \u0014 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u0004 \u0010 \u0012 \u000b \u000b \u0010 \n \u0010 \u0004 \u0005 \u0006 \f \u0004 \u0012 \u0014 \u001d \u0014 \u0004 \u0010 \f \n \u000f !\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEnableAllInterrupts()\nFrTrcv_CheckWakeupByTransceiver(uint8)\nGetResource()\nMcu_SetMode()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nIcu_EnableWakeup(Icu_ChannelType)\nEcuM_CheckWakeup()\nIcu_EnableWakeup()\nIcu_DisableWakeup(Icu_ChannelType)\nFrIf_CheckWakeupByTransceiver()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode()\nEcuM_SetWakeupEvent()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nIcu_DisableWakeup()\nDisableAllInterrupts()\nFrIf_CheckWakeupByTransceiver(uint8,\nFr_ChannelType)\nEcuM_DisableWakeupSources()\nEnableAllInterrupts()\nWakeup\ninterrupt()\nReturn from\ninterrupt()\nMcu_SetMode(Mcu_ModeType)\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nactivate\nPLL()\nReleaseResource()\nMcu_SetMode(Mcu_ModeType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources()\nFrTrcv_CheckWakeupByTransceiver()\nDisableAllInterrupts()\nFigure 9.11: FlexRay transceiver wake up by interrupt\n174 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "386": {
    "node_id": "88737219-ffb0-4001-bede-746f8799d503",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Note that in EcuM_CheckWakeup (see [SWS_EcuM_02929]) there need to be two\nseparate calls to FrIf_WakeupByTransceiver, one for each FlexRay channel.\n«Peripheral»\nFlexRay Transceiver\nHardware\n«Periphe...\nFlexRay\nController\n«module»\nFrTrcv\n«module»\nFr\n«module»\nFrIf\n«module»\nIcu\n«module»\nMcu\nIntegration\nCode\n«module»\nEcuM\n«module»\nOs",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "387": {
    "node_id": "113876a6-2723-45e0-ada5-3210fb232708",
    "title": "GOSLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "388": {
    "node_id": "23eb7404-2ad5-4fd3-9b1d-5b8056f51620",
    "title": "SLEEP",
    "level": 2,
    "type": "clause",
    "content": "",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "389": {
    "node_id": "69b64ab9-3c73-43f6-8658-424023991f5b",
    "title": "WAKEUP I",
    "level": 2,
    "type": "clause",
    "content": "loop WHILE no pending/validated events\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \t \n \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \t \u000e \u000f \u0006 \u0007 \u0010 \u0007 \u0011 \t \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \u0015 \u0006 \u000e \u0016 \u0006 \u0004 \u0011 \u0011 \u0005 \u0011 \u0017 \u0018\nopt Wakeup detected\n\u0019\n\u0002 \u0004\n\u001a\n\u000b \u0007 \t\n\u0019\n\u000e \f \u0007\n\u001b \u001c\n\u000f \u0004 \t \u0013 \t \n \u0007 \u0016 \u0005 \u0002 \u0006 \u000e \u0002 \u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006 \u0005 \u0011\n\u0013 \u000e \u0016 \u0007 \u000f \u000e \u001d \u0007 \u0006 \u0013 \u0012 \u0010 \u0005 \u0011 \u0017 \u0016 \u000e \f \u0007 \u0018 \u001e \u0011 \t \n \u0005 \u0013 \u0016 \u000e \f \u0007\n\u0013 \u000e \u0015 \t \u001d \u0012 \u0006 \u0007 \u0007\n\u001f\n\u0007 \u0002 \u0004 \t \u0005 \u000e \u0011 \u0002 \u000e \u0011 \t \u0005 \u0011 \u0004 \u0007 \u0013\n !\n\u0004 \t \u001d \u0005 \t \n\u0006 \u0007 \f \u0004 \u0002 \u0007 \f \u0002 \n \u000e \u0002 \u0014 \u0013 \u000f \u0007 \u0007 \f \u0018\n\" \u0007 \n \u0007 \u0012 \u0013 \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \u0006 \u0007 \u0013 \u000e \u0004 \u0006 \u0002 \u0007 \t \u000e \u0012 \n \n \u000e \u001d \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \t \u000e \u0006 \u0004 \u0011 \u0018\n#\n\n \u0005 \u0013 \u0002 \u0012 \n \n \n \u0012 \u0013 \t \u000e\n!\n\u0007 \u0006 \u0007 \u000f \u0007 \u0012 \t \u0007 \f \u0015 \u000e \u0006\n!\n\u000e \t \n$\n\n \u0007\n\u001f\n\" \u0012\n%\n\u0002 \n \u0012 \u0011 \u0011 \u0007 \n \u0013 \u000e \u0011 \t \n \u0007\n\u0013 \u0012 \u0016 \u0007 \u0011 \u0007 \t \u001d \u000e \u0006 \u0014\n\u001b\n\u0005 \u0018 \u0007 \u0018\n$\n\n \u0007\n\u001f\n\" \u0012\n%\n\u0002 \n \u0004 \u0013 \t \u0007 \u0006\n\u001c &\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nDisableAllInterrupts()\nFrTrcv_CheckWakeupByTransceiver(uint8)\nMcu_SetMode()\nEcuM_SetWakeupEvent()\nDisableAllInterrupts()\nEcuM_CheckWakeupEvent()\nMcu_SetMode()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nEcuM_SleepActivity()\nFrIf_CheckWakeupByTransceiver()\nFrTrcv_CheckWakeupByTransceiver()\nFrIf_CheckWakeupByTransceiver(uint8,\nFr_ChannelType)\nGetResource()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nEnableAllInterrupts()\nReleaseResource()\nEnableAllInterrupts()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nFigure 9.12: FlexRay transceiver wake up by polling\n175 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "390": {
    "node_id": "c090b492-f5c5-4559-a4d9-d189fe10ea56",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "# Configuration specification\n\nIn general, this chapter defines configuration parameters and their clustering into con-\ntainers.\nChapters 10.1 and 10.2 specify the structure (containers) and the parameters of the\nmodule ECU Manager.\nChapter 10.3 specifies published information of the module ECU State Manager.\n\n## Common Containers and configuration parameters\n\nThe following chapters summarize all configuration parameters. The detailed meanings\nof the parameters describe Chapters 7 and Chapter 8.\nThe following containers contain various references to initialization structures of BSW\nmodules. NULL shall be a valid reference meaning ’no configuration data available’ but\nonly if the implementation of the initialized BSW module supports this.\n176 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "391": {
    "node_id": "32c49a1d-0786-47f7-a55c-4070713b2dc0",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuM\n\nEcuM: EcucModuleDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMGeneral: \nEcucParamConfContainerDef\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMFlexGeneral: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMFlexUserConfig: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMFlexEcucPartitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+subContainer\n+container\n+container\n+reference\n+subContainer\n+container\n+subContainer\nFigure 10.1: EcuM configuration overview\nModule SWS Item ECUC_EcuM_00225\nModule Name EcuM\nModule Description Configuration of the EcuM (ECU State Manager) module.\nPost-Build Variant\nSupport\ntrue\nSupported Config\nVariants\nVARIANT -POST -BUILD, VARIANT -PRE-COMPILE\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMConfiguration 1 This container contains the configuration (parameters)\nof the ECU State Manager.\nEcuMFlexGeneral 0..1 This container holds the general, pre-compile\nconfiguration parameters for the EcuMFlex.\nOnly applicable if EcuMFlex is implemented.\nEcuMGeneral 1 This container holds the general, pre-compile\nconfiguration parameters.\n177 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "392": {
    "node_id": "7667c231-d068-4631-bd9b-318a0b326d69",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuMGeneral\n\nEcuMDevErrorDetect: \nEcucBooleanParamDef\ndefaultValue = false\nEcuMVersionInfoApi: \nEcucBooleanParamDef\ndefaultValue = false\nEcuMGeneral: \nEcucParamConfContainerDef\nEcuMMainFunctionPeriod: \nEcucFloatParamDef\nmin = 0\nmax = INF\n+parameter\n+parameter\n+parameter\nFigure 10.2: EcuMGeneral configuration overview\nSWS Item [ECUC_EcuM_00116]\nContainer Name EcuMGeneral\nParent Container EcuM\nDescription This container holds the general, pre-compile configuration\nparameters.\nConfiguration Parameters\nName EcuMDevErrorDetect [ECUC_EcuM_00108]\nParent Container EcuMGeneral\nDescription Switches the development error detection and notification on or off.\n• true: detection and notification is enabled.\n• false: detection and notification is disabled.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value false\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMMainFunctionPeriod [ECUC_EcuM_00121]\nParent Container EcuMGeneral\nDescription This parameter defines the schedule period of EcuM_MainFunction.\nUnit: [s]\nMultiplicity 1\nType EcucFloatParamDef\nRange ]0 .. INF[\nDefault Value\n178 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "393": {
    "node_id": "72a84960-850e-4021-987f-df4188f83710",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Post-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: ECU\nName EcuMVersionInfoApi [ECUC_EcuM_00149]\nParent Container EcuMGeneral\nDescription Switches the version info API on or off\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value false\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n179 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "394": {
    "node_id": "3959f288-bbf2-4758-8bb7-b48d9b6e303c",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuMConfiguration\n\nEcuMConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nOsAppMode: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nEcuMDefaultAppMode: \nEcucReferenceDef\nEcuMConfigConsistencyHash: \nEcucIntegerParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMDriverInitListOne: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMSleepMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMDefaultShutdownTarget: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 1\nEcuMDriverInitListZero: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMOSResource: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nOsResource: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 0EcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMDriverRestartList: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\n+subContainer+subContainer\n+parameter\n+reference +destination\n+subContainer\n+destination\n+subContainer\n+subContainer\n+subContainer\n+subContainer\n+reference\n+subContainer\n+subContainer\n+subContainer\nFigure 10.3: EcuMConfiguration configuration overview\nSWS Item [ECUC_EcuM_00103]\nContainer Name EcuMConfiguration\nParent Container EcuM\nDescription This container contains the configuration (parameters) of the ECU\nState Manager.\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMCommon\nConfiguration\n\n# This container contains the common configuration\n\n(parameters) of the ECU State Manager.\n180 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "395": {
    "node_id": "ab2b3180-d990-4e25-af0b-3d50ec8c6512",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "EcuMFlexConfiguration 0..1 This container contains the configuration (parameters)\nof the EcuMFlex.\nOnly applicable if EcuMFlex is implemented.\n\n### EcuMCommonConfiguration\n\nSWS Item [ECUC_EcuM_00181]\nContainer Name EcuMCommonConfiguration\nParent Container EcuMConfiguration\nDescription This container contains the common configuration (parameters) of the\nECU State Manager.\nConfiguration Parameters\nName EcuMConfigConsistencyHash [ECUC_EcuM_00102]\nParent Container EcuMCommonConfiguration\nDescription In the pre-compile and link-time configuration phase a hash value is\ngenerated across all pre-compile and link-time parameters of all BSW\nmodules.\nIn the post-build phase a hash value is generated across all\npre-compile and link-time parameters, except for parameters located in\nEcucParamConfContainerDef instances or subContainers which have\nbeen introduced at post-build configuration time.\nThis hash value is compared against each other and allows checking\nthe consistency of the entire configuration.\nNote: In systems which do not make use of post-build configurations\nthis parameter can be omitted.\nMultiplicity 0..1\nType EcucIntegerParamDef\nRange 0 ..\n\n# Default Value\n\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\n181 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "396": {
    "node_id": "a9b7e2b2-57e4-4374-aced-a539a82928f1",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMDefaultAppMode [ECUC_EcuM_00104]\nParent Container EcuMCommonConfiguration\nDescription The default application mode loaded when the ECU comes out of reset.\nMultiplicity 1\nType Reference to OsAppMode\nPost-Build Variant\nValue\ntrue\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\nName EcuMOSResource [ECUC_EcuM_00183]\nParent Container EcuMCommonConfiguration\nDescription This parameter is a reference to a OS resource which is used to bring\nthe ECU into sleep mode.\nIn case of multi core each core shall have an own OsResource.\nMultiplicity 1..*\nType Reference to OsResource\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDefaultShutdown\nTarget\n\n# This container describes the default shutdown target to\n\nbe selected by EcuM. The actual shutdown target may\nbe overridden by the EcuM_SelectShutdownTarget\nservice.\nEcuMDriverInitListOne 0..1 Container for Init Block I.\nThis container holds a list of modules to be initialized.\nEach module in the list will be called for initialization in\nthe list order.\nAll modules in this list are initialized before the OS is\nstarted and so these modules require no OS support.\n182 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "397": {
    "node_id": "3641a0fd-3242-4d07-ad86-3ffc121ba36d",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "EcuMDriverInitListZero 0..1 Container for Init Block 0.\nThis container holds a list of modules to be initialized.\nEach module in the list will be called for initialization in\nthe list order.\nAll modules in this list are initialized before the post-build\nconfiguration has been loaded and the OS is initialized.\nTherefore, these modules may not use post-build\nconfiguration.\nEcuMDriverRestartList 0..1 List of modules to be initialized.\nEcuMSleepMode 1..256 These containers describe the configured sleep modes.\nThe names of these containers specify the symbolic\nnames of the different sleep modes.\nEcuMWakeupSource 1..32 These containers describe the configured wakeup\nsources.\n\n### EcuMDefaultShutdownTarget\n\nEcuMDefaultShutdownTarget: \nEcucEnumerationParamDef\nEcuMDefaultSleepModeRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nrequiresSymbolicNameValue = true\nEcuMSleepMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMDefaultShutdownTarget: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 1\nEcuMShutdownTargetSleep: \nEcucEnumerationLiteralDef\nEcuMShutdownTargetOff: \nEcucEnumerationLiteralDef\nEcuMShutdownTargetReset: \nEcucEnumerationLiteralDef\nEcuMDefaultResetModeRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nrequiresSymbolicNameValue = true\nEcuMResetMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\n+literal\n+literal\n+reference\n+reference\n+destination\n+destination\n+parameter\n+literal\nFigure 10.4: EcuMDefaultShutdownTarget configuration overview\nSWS Item [ECUC_EcuM_00105]\nContainer Name EcuMDefaultShutdownTarget\nParent Container EcuMCommonConfiguration\nDescription This container describes the default shutdown target to be selected by\nEcuM. The actual shutdown target may be overridden by the\nEcuM_SelectShutdownTarget service.\nConfiguration Parameters\n183 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "398": {
    "node_id": "fbcf78ba-2d8c-44dd-af66-bbafdc209fbc",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMDefaultShutdownTarget [ECUC_EcuM_00107]\nParent Container EcuMDefaultShutdownTarget\nDescription This parameter describes the state part of the default shutdown target\nselected when the ECU comes out of reset. If\nEcuMShutdownTargetSleep is selected, the parameter\nEcuMDefaultSleepModeRef selects the specific sleep mode.\nMultiplicity 1\nType EcucEnumerationParamDef\nRange EcuMShutdownTargetOff Corresponds to\nECUM_SHUTDOWN_TARGET_OFF\nin EcuM_ShutdownTargetType.\nEcuMShutdownTarget\nReset\nCorresponds to\nECUM_SHUTDOWN_TARGET_RESET\nin EcuM_ShutdownTargetType. This\nliteral is only be applicable for\nEcuMFlex.\nEcuMShutdownTarget\nSleep\nCorresponds to\nECUM_SHUTDOWN_TARGET_SLEEP\nin EcuM_ShutdownTargetType.\nPost-Build Variant\nValue\ntrue\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\nName EcuMDefaultResetModeRef [ECUC_EcuM_00205]\nParent Container EcuMDefaultShutdownTarget\nDescription If EcuMDefaultShutdownTarget is EcuMShutdownTargetReset, this\nparameter selects the default reset mode. Otherwise this parameter\nmay be ignored.\nMultiplicity 0..1\nType Symbolic name reference to EcuMResetMode\nPost-Build Variant\nMultiplicity\ntrue\nPost-Build Variant\nValue\ntrue\nMultiplicity\nConfiguration Class\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\n184 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "399": {
    "node_id": "7fc82cba-532f-4ab8-97ba-013298d927cd",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMDefaultSleepModeRef [ECUC_EcuM_00106]\nParent Container EcuMDefaultShutdownTarget\nDescription If EcuMDefaultShutdownTarget is EcuMShutdownTargetSleep, this\nparameter selects the default sleep mode. Otherwise this parameter\nmay be ignored.\nMultiplicity 0..1\nType Symbolic name reference to EcuMSleepMode\nPost-Build Variant\nMultiplicity\ntrue\nPost-Build Variant\nValue\ntrue\nMultiplicity\nConfiguration Class\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\nNo Included Containers\n\n### EcuMDriverInitListOne\n\nEcuMDriverInitListOne: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMDriverInitListZero: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\n+subContainer\n+subContainer\n+subContainer\n+subContainer\nFigure 10.5: EcuMInitLists configuration overview\nSWS Item [ECUC_EcuM_00111]\nContainer Name EcuMDriverInitListOne\nParent Container EcuMCommonConfiguration\nDescription Container for Init Block I.\nThis container holds a list of modules to be initialized. Each module in\nthe list will be called for initialization in the list order.\nAll modules in this list are initialized before the OS is started and so\nthese modules require no OS support.\nPost-Build Variant\nMultiplicity\nfalse\n185 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "400": {
    "node_id": "05bc2aed-0b7c-4d32-9fb9-c70005ce7a0e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Multiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMDriverInitListZero\n\nSWS Item [ECUC_EcuM_00114]\nContainer Name EcuMDriverInitListZero\nParent Container EcuMCommonConfiguration\nDescription Container for Init Block 0.\nThis container holds a list of modules to be initialized. Each module in\nthe list will be called for initialization in the list order.\nAll modules in this list are initialized before the post-build configuration\nhas been loaded and the OS is initialized. Therefore, these modules\nmay not use post-build configuration.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMDriverRestartList\n\nSWS Item [ECUC_EcuM_00115]\nContainer Name EcuMDriverRestartList\nParent Container EcuMCommonConfiguration\nDescription List of modules to be initialized.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\n186 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "401": {
    "node_id": "b3d8b105-d6a3-4c1d-9762-ee77a463b552",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Configuration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMDriverInitItem\n\nEcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMModuleService: \nEcucStringParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nARElem ent\nEcucModuleConfigurationValues\n+ ecucDefEdition: RevisionLabelString [0..1]\n+ implementationConfigVariant: EcucConfigurationVariantEnum [0..1]\n+ postBuildVariantUsed: Boolean [0..1]\nEcuMModuleRef: EcucForeignReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\ndestinationType = ECUC-MODULE-CONFIGURATION-VALUES\nEcuMModuleParameter: \nEcucEnumerationParamDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nPOSTBUILD_PTR: \nEcucEnumerationLiteralDef\nNULL_PTR: \nEcucEnumerationLiteralDef\nVOID: \nEcucEnumerationLiteralDef\nEcucCoreDefinition: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nEcuMEcucCoreDefinitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+reference\n+literal\n+literal\n+literal\n+parameter\n+reference\n+destination\n+parameter\nFigure 10.6: EcuMDriverInitItem configuration overview\nSWS Item [ECUC_EcuM_00110]\nContainer Name EcuMDriverInitItem\nParent Container EcuMDriverInitListBswM, EcuMDriverInitListOne, EcuMDriverInitList\nZero, EcuMDriverRestartList\nDescription These containers describe the entries in a driver init list.\nAttributes:\nrequiresIndex=true\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\n187 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "402": {
    "node_id": "af2580c4-881e-476e-997a-a755c65a5e2e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Configuration Parameters\nName EcuMModuleParameter [ECUC_EcuM_00224]\nParent Container EcuMDriverInitItem\nDescription Definition of the function prototype and the parameter passed to the\nfunction.\nMultiplicity 1\nType EcucEnumerationParamDef\nRange NULL_PTR If NULL_PTR is configured EcuM\nexpects as prototype: void\n<Mip>_<EcuMModuleService>(const\n<Mip>_ConfigType* <Mip>_Config).\nEcuM shall call this function with NULL\nPointer:\n<Mip>_<EcuMModuleService>(NULL).\nPOSTBUILD_PTR If POSTBUILD_PTR is configured\nEcuM expects as prototype: void\n<Mip>_<EcuMModuleService>(const\n<Mip>_ConfigType* <Mip>_Config).\nEcuM shall call this function with a\nvalid pointer:\n<Mip>_<EcuMModuleService>\n(&<Mip>_Config\n[Predefinedvariant.shortName]).\nVOID If VOID is configured EcuM expects as\nprototype: void\n<Mip>_<EcuMModuleService>(void).\nEcuM will call\n<Mip>_<EcuMModuleService>().\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMModuleService [ECUC_EcuM_00124]\nParent Container EcuMDriverInitItem\nDescription The service to be called to initialize that module, e.g. Init, PreInit, Start\netc. If nothing is defined \"Init\" is taken by default.\nMultiplicity 0..1\nType EcucStringParamDef\nDefault Value\nRegular Expression\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\n188 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "403": {
    "node_id": "dc520091-c55c-473f-a36d-bd364212558a",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Multiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMEcucCoreDefinitionRef [ECUC_EcuM_00229]\nParent Container EcuMDriverInitItem\nDescription Reference denotes the core the EcuM AUTOSAR services shall be\noffered on.\nMultiplicity 0..1\nType Reference to EcucCoreDefinition\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMModuleRef [ECUC_EcuM_00223]\nParent Container EcuMDriverInitItem\nDescription Foreign reference to the configuration of a module instance which shall\nbe initialized by EcuM\nMultiplicity 1\nType Foreign reference to ECUC-MODULE-CONFIGURATION-VALUES\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n189 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "404": {
    "node_id": "e34e001f-8cc1-49db-9ca1-7fba67d0674e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuMSleepMode\n\nEcuMSleepMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMSleepModeMcuModeRef: \nEcucReferenceDef\nrequiresSymbolicNameValue = true\nEcuMWakeupSourceMask: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nMcuModeSettingConf: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMSleepModeSuspend: \nEcucBooleanParamDef\nEcuMSleepModeId: \nEcucIntegerParamDef\nmax = 255\nmin = 0\nsymbolicNameValue = true\n+parameter\n+reference\n+destination\n+destination\n+reference\n+parameter\nFigure 10.7: EcuMSleepMode configuration overview\nSWS Item [ECUC_EcuM_00131]\nContainer Name EcuMSleepMode\nParent Container EcuMCommonConfiguration\nDescription These containers describe the configured sleep modes.\nThe names of these containers specify the symbolic names of the\ndifferent sleep modes.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMSleepModeId [ECUC_EcuM_00132]\nParent Container EcuMSleepMode\nDescription This ID identifies this sleep mode in services like\nEcuM_SelectShutdownTarget.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: ECU\n190 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "405": {
    "node_id": "53f5d9fb-a7ed-422e-9755-36a62ce11b97",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMSleepModeSuspend [ECUC_EcuM_00136]\nParent Container EcuMSleepMode\nDescription Flag, which is set true, if the CPU is suspended, halted, or powered off\nin the sleep mode. If the CPU keeps running in this sleep mode, then\nthis flag must be set to false.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMSleepModeMcuModeRef [ECUC_EcuM_00133]\nParent Container EcuMSleepMode\nDescription This parameter is a reference to the corresponding MCU mode for this\nsleep mode.\nMultiplicity 1\nType Symbolic name reference to McuModeSettingConf\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMWakeupSourceMask [ECUC_EcuM_00152]\nParent Container EcuMSleepMode\nDescription These parameters are references to the wakeup sources that shall be\nenabled for this sleep mode.\nMultiplicity 1..*\nType Symbolic name reference to EcuMWakeupSource\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\n191 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "406": {
    "node_id": "987766a8-3854-48c5-9315-a8cc60844103",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "No Included Containers\n\n### EcuMWakeupSource\n\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMValidationTimeout: \nEcucFloatParamDef\nmin = 0\nmax = INF\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMResetReasonRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcuMWakeupSourceId: \nEcucIntegerParamDef\nmin = 5\nmax = 31\nsymbolicNameValue = true\nComMChannel: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMComMChannelRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcuMWakeupSourcePolling: \nEcucBooleanParamDef\nMcuResetReasonConf: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nEcuMCheckWakeupTimeout: \nEcucFloatParamDef\nmin = 0.0\nmax = 10.0\nlowerMultiplicity = 0\nupperMultiplicity = 1\ndefaultValue = 0.0\nComMPnc: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 504\nEcuMComMPNCRef: EcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\n+parameter\n+reference\n+parameter\n+destination\n+destination+reference\n+parameter\n+parameter\n+destination+reference\nFigure 10.8: EcuMWakeupSource configuration overview\nSWS Item [ECUC_EcuM_00150]\nContainer Name EcuMWakeupSource\nParent Container EcuMCommonConfiguration\nDescription These containers describe the configured wakeup sources.\nPost-Build Variant\nMultiplicity\ntrue\nMultiplicity\nConfiguration Class\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nConfiguration Parameters\n192 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "407": {
    "node_id": "947b0bec-3f34-4346-8cae-54a419883017",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMCheckWakeupTimeout [ECUC_EcuM_00208]\nParent Container EcuMWakeupSource\nDescription This Parameter is the initial Value for the Time of the EcuM to delay\nshut down of the ECU if the check of the Wakeup Source is done\nasynchronously (CheckWakeupTimer).\nThe unit is in seconds.\nMultiplicity 0..1\nType EcucFloatParamDef\nRange [0 .. 10]\nDefault Value 0\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMValidationTimeout [ECUC_EcuM_00148]\nParent Container EcuMWakeupSource\nDescription The validation timeout (period for which the ECU State Manager will\nwait for the validation of a wakeup event) can be defined for each\nwakeup source independently. The timeout is specified in seconds.\nWhen the timeout is not instantiated, there is no validation routine and\nthe ECU Manager shall not validate the wakeup source.\nMultiplicity 0..1\nType EcucFloatParamDef\nRange [0 .. INF]\nDefault Value\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\n193 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "408": {
    "node_id": "e6aa4324-7958-417a-93f1-9656f5f76c61",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMWakeupSourceId [ECUC_EcuM_00151]\nParent Container EcuMWakeupSource\nDescription This parameter defines the identifier of this wakeup source. The first\nfive bits are reserved values from the EcuM_WakeupSourceType.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 5 .. 31\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: ECU\nName EcuMWakeupSourcePolling [ECUC_EcuM_00153]\nParent Container EcuMWakeupSource\nDescription This parameter describes if the wakeup source needs polling.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMComMChannelRef [ECUC_EcuM_00101]\nParent Container EcuMWakeupSource\nDescription This parameter could reference multiple Networks (channels) defined\nin the Communication Manager. No reference indicates that the\nwakeup source is not a communication channel.\nMultiplicity 0..*\nType Symbolic name reference to ComMChannel\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\n194 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "409": {
    "node_id": "dff625ea-6a04-468e-bc1c-831fb9836b0e",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMComMPNCRef [ECUC_EcuM_00228]\nParent Container EcuMWakeupSource\nDescription This is a reference to a one or more PNC’s defined in the\nCommunication Manager.\nNo reference indicates that the wakeup source is not assigned to a\npartial network.\nMultiplicity 0..*\nType Symbolic name reference to ComMPnc\nPost-Build Variant\nMultiplicity\ntrue\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMResetReasonRef [ECUC_EcuM_00128]\nParent Container EcuMWakeupSource\nDescription This parameter describes the mapping of reset reasons detected by\nthe MCU driver into wakeup sources.\nMultiplicity 0..*\nType Symbolic name reference to McuResetReasonConf\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n195 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "410": {
    "node_id": "8b9c42e5-c9c1-4ab8-a099-04235fe4e1e0",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "## EcuM-Flex Containers and configuration parameters\n\nEcuM: EcucModuleDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMGeneral: \nEcucParamConfContainerDef\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMFlexGeneral: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+subContainer\n+container\n+subContainer\n+container\n+container\nFigure 10.9: EcuMFlex configuration overview\n\n### EcuMFlexGeneral\n\nEcuMFlexGeneral: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMResetLoopDetection: \nEcucBooleanParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMAlarmClockPresent: \nEcucBooleanParamDef\nEcuMAlarmWakeupSource: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nrequiresSymbolicNameValue = true\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMSetProgrammableInterrupts: \nEcucBooleanParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMModeHandling: \nEcucBooleanParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+parameter\n+destination\n+parameter\n+parameter\n+parameter\n+reference\nFigure 10.10: EcuMFlexGeneral configuration overview\nSWS Item [ECUC_EcuM_00168]\nContainer Name EcuMFlexGeneral\nParent Container EcuM\nDescription This container holds the general, pre-compile configuration parameters\nfor the EcuMFlex.\nOnly applicable if EcuMFlex is implemented.\nPost-Build Variant\nMultiplicity\nfalse\n196 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "411": {
    "node_id": "4a3d1dbd-53d5-44a2-be56-0fa3a3b04e92",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Multiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMAlarmClockPresent [ECUC_EcuM_00199]\nParent Container EcuMFlexGeneral\nDescription This flag indicates whether the optional AlarmClock feature is present.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMModeHandling [ECUC_EcuM_00221]\nParent Container EcuMFlexGeneral\nDescription If false, Run Request Protocol is not performed.\nMultiplicity 0..1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMResetLoopDetection [ECUC_EcuM_00171]\nParent Container EcuMFlexGeneral\nDescription If false, no reset loop detection is performed. If this configuration\nparameter exists and is set to true, the callout \"EcuM_LoopDetection\"\nis called during startup of EcuM (during StartPreOS).\nMultiplicity 0..1\nType EcucBooleanParamDef\nDefault Value\n197 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "412": {
    "node_id": "b11d0332-f465-4e01-84a1-156662071f25",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Post-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMSetProgrammableInterrupts [ECUC_EcuM_00210]\nParent Container EcuMFlexGeneral\nDescription If this configuration parameter exists and is to true, the callout\n\"EcuM_AL_SetProgrammableInterrupts\" is called during startup of\nEcuM (during StartPreOS).\nMultiplicity 0..1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMAlarmWakeupSource [ECUC_EcuM_00200]\nParent Container EcuMFlexGeneral\nDescription This parameter describes the reference to the EcuMWakeupSource\nbeing used for the EcuM AlarmClock.\nMultiplicity 0..1\nType Symbolic name reference to EcuMWakeupSource\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\n198 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "413": {
    "node_id": "027d2947-45a6-4187-9f0a-72737806cd16",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Multiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n199 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "414": {
    "node_id": "d5160397-0a07-493a-b5b1-b4976b755a96",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuMFlexConfiguration\n\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMResetMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMResetModeId: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMShutdownCause: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMShutdownCauseId: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMAlarmClock: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nEcuMAlarmClockId: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMAlarmClockTimeOut: \nEcucFloatParamDef\nmin = 0\nmax = INFEcuMAlarmClockUser: \nEcucReferenceDef\nrequiresSymbolicNameValue = true\nEcuMFlexUserConfig: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMSetClockAllowedUserRef: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcuMSetClockAllowedUsers: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMNormalMcuModeRef: \nEcucReferenceDef\nrequiresSymbolicNameValue = true\nMcuModeSettingConf: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nEcuMGoDownAllowedUsers: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMGoDownAllowedUserRef: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcucPartition: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nEcuMPartitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\n+subContainer\n+parameter\n+destination\n+reference\n+parameter\n+reference\n+reference\n+destination\n+parameter\n+subContainer\n+subContainer\n+parameter\n+subContainer\n+destination\n+reference\n+subContainer\n+destination\n+reference\n+subContainer\n+destination\nFigure 10.11: EcuMFlexConfiguration configuration overview\nSWS Item [ECUC_EcuM_00167]\nContainer Name EcuMFlexConfiguration\nParent Container EcuMConfiguration\nDescription This container contains the configuration (parameters) of the\nEcuMFlex.\nOnly applicable if EcuMFlex is implemented.\n200 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "415": {
    "node_id": "1dcf203f-9a88-445f-9e9e-656d01e33eb9",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Post-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMNormalMcuModeRef [ECUC_EcuM_00204]\nParent Container EcuMFlexConfiguration\nDescription This parameter is a reference to the normal MCU mode to be restored\nafter a sleep.\nMultiplicity 1\nType Symbolic name reference to McuModeSettingConf\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMPartitionRef [ECUC_EcuM_00217]\nParent Container EcuMFlexConfiguration\nDescription Reference denotes the partition a EcuM shall run inside. Please note\nthat in case of a multicore ECU this reference is mandatory.\nMultiplicity 0..*\nType Reference to EcucPartition\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMAlarmClock 0..* These containers describe the configured alarm clocks.\nThe name of these conatiners allows giving a symbolic\nname to one alarm clock.\n201 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "416": {
    "node_id": "b3b0c673-a6fa-446f-a26e-aa83435cfeab",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "EcuMDriverInitListBswM 0..* This container holds a list of modules to be initialized by\nthe BswM.\nEcuMFlexUserConfig 1..256 These containers describe the identifiers that are\nneeded to refer to a software component or another\nappropriate entity in the system which uses the\nEcuMFlex Interfaces.\nEcuMGoDownAllowed\nUsers\n0..1 This container describes the collection of allowed users\nwhich are allowed to call the EcuM_GoDownHaltPoll API\n(only applies in the case that the previously set\nshutdown target is TARGET_RESET or TARGET_OFF).\nEcuMResetMode 1..256 These containers describe the configured reset modes.\nThe name of these containers allows one of the following\nsymbolic names to be given to the different reset modes:\n• ECUM_RESET_MCU\n• ECUM_RESET_WDG\n• ECUM_RESET_IO.\nEcuMSetClockAllowed\nUsers\n0..1 This container describes the collection of allowed users\nwhich are allowed to call the EcuM_SetClock API.\nEcuMShutdownCause 1..256 These containers describe the configured shut down or\nreset causes. The name of these containers allows to\ngive one of the following symbolic names to the different\nshut down causes:\n• ECUM_CAUSE_ECU_STATE - ECU state\nmachine entered a state for shutdown,\n• ECUM_CAUSE_WDGM - WdgM detected failure,\n• ECUM_CAUSE_DCM - Dcm requests shutdown\n(split into UDS services?),\n• and values from configuration.\n\n### EcuMAlarmClock\n\nSWS Item [ECUC_EcuM_00184]\nContainer Name EcuMAlarmClock\nParent Container EcuMFlexConfiguration\nDescription These containers describe the configured alarm clocks.\nThe name of these conatiners allows giving a symbolic name to one\nalarm clock.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\n202 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "417": {
    "node_id": "4aa9a489-d44c-4ab5-8ff3-88bb6da8d6c7",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMAlarmClockId [ECUC_EcuM_00186]\nParent Container EcuMAlarmClock\nDescription This ID identifies this alarmclock.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMAlarmClockTimeOut [ECUC_EcuM_00188]\nParent Container EcuMAlarmClock\nDescription This parameter allows to define a timeout for this alarm clock.\nMultiplicity 1\nType EcucFloatParamDef\nRange [0 .. INF]\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMAlarmClockUser [ECUC_EcuM_00195]\nParent Container EcuMAlarmClock\nDescription This parameter allows an alarm to be assigned to a user.\nMultiplicity 1\nType Symbolic name reference to EcuMFlexUserConfig\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n203 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "418": {
    "node_id": "a0e742a5-31a0-4e7b-bef7-962b8d1d3615",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "### EcuMDriverInitListBswM\n\nEcuMFlexUserConfig: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMFlexUser: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMFlexEcucPartitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcucPartition: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\n+destination\n+parameter\n+reference\nFigure 10.12: EcuMFlexUserConfig configuration overview\nSWS Item [ECUC_EcuM_00201]\nContainer Name EcuMFlexUserConfig\nParent Container EcuMFlexConfiguration\nDescription These containers describe the identifiers that are needed to refer to a\nsoftware component or another appropriate entity in the system which\nuses the EcuMFlex Interfaces.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMFlexUser [ECUC_EcuM_00146]\nParent Container EcuMFlexUserConfig\nDescription Parameter used to identify one user.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMFlexEcucPartitionRef [ECUC_EcuM_00203]\nParent Container EcuMFlexUserConfig\nDescription Denotes in which \"EcucPartition\" the user of the EcuM is executed.\nMultiplicity 0..1\nType Reference to EcucPartition\nPost-Build Variant\nMultiplicity\nfalse\n204 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "419": {
    "node_id": "37374bee-13e8-48e2-82b8-7c2bde608740",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Post-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMModuleService: \nEcucStringParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nARElement\nEcucModuleConfigurationValues\n+ ecucDefEdition: RevisionLabelString [0..1]\n+ implementationConfigVariant: EcucConfigurationVariantEnum [0..1]\n+ postBuildVariantUsed: Boolean [0..1]\nEcuMModuleRef: EcucForeignReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\ndestinationType = ECUC-MODULE-CONFIGURATION-VALUES\nEcuMModuleParameter: \nEcucEnumerationParamDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nPOSTBUILD_PTR: \nEcucEnumerationLiteralDef\nNULL_PTR: \nEcucEnumerationLiteralDef\nVOID: \nEcucEnumerationLiteralDef\nEcuMDriverInitListBswM: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\n+reference\n+literal\n+subContainer\n+literal\n+literal\n+subContainer\n+parameter\n+parameter\nFigure 10.13: EcuMFlexDriverInitListBswM configuration overview\nSWS Item [ECUC_EcuM_00226]\nContainer Name EcuMDriverInitListBswM\nParent Container EcuMFlexConfiguration\nDescription This container holds a list of modules to be initialized by the BswM.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\n205 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "420": {
    "node_id": "c3a9393d-ede8-4528-b919-d61e26a43e18",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Included Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMGoDownAllowedUsers\n\nSWS Item [ECUC_EcuM_00206]\nContainer Name EcuMGoDownAllowedUsers\nParent Container EcuMFlexConfiguration\nDescription This container describes the collection of allowed users which are\nallowed to call the EcuM_GoDownHaltPoll API (only applies in the case\nthat the previously set shutdown target is TARGET_RESET or\nTARGET_OFF).\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMGoDownAllowedUserRef [ECUC_EcuM_00207]\nParent Container EcuMGoDownAllowedUsers\nDescription This references an allowed user.\nMultiplicity 1..*\nType Symbolic name reference to EcuMFlexUserConfig\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n\n### EcuMResetMode\n\nSWS Item [ECUC_EcuM_00172]\n206 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "421": {
    "node_id": "4c4bab4e-c413-493b-b162-1adfff11d3c5",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Container Name EcuMResetMode\nParent Container EcuMFlexConfiguration\nDescription These containers describe the configured reset modes. The name of\nthese containers allows one of the following symbolic names to be\ngiven to the different reset modes:\n• ECUM_RESET_MCU\n• ECUM_RESET_WDG\n• ECUM_RESET_IO.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMResetModeId [ECUC_EcuM_00173]\nParent Container EcuMResetMode\nDescription This ID identifies this reset mode in services like\nEcuM_SelectShutdownTarget.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n\n### EcuMSetClockAllowedUsers\n\nSWS Item [ECUC_EcuM_00175]\nContainer Name EcuMShutdownCause\nParent Container EcuMFlexConfiguration\n207 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "422": {
    "node_id": "3f783585-06d2-433d-bcfd-664b877b10b6",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Description These containers describe the configured shut down or reset causes.\nThe name of these containers allows to give one of the following\nsymbolic names to the different shut down causes:\n• ECUM_CAUSE_ECU_STATE - ECU state machine entered a\nstate for shutdown,\n• ECUM_CAUSE_WDGM - WdgM detected failure,\n• ECUM_CAUSE_DCM - Dcm requests shutdown (split into UDS\nservices?),\n• and values from configuration.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMShutdownCauseId [ECUC_EcuM_00176]\nParent Container EcuMShutdownCause\nDescription This ID identifies this shut down cause.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\nSWS Item [ECUC_EcuM_00197]\nContainer Name EcuMSetClockAllowedUsers\nParent Container EcuMFlexConfiguration\nDescription This container describes the collection of allowed users which are\nallowed to call the EcuM_SetClock API.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\n208 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "423": {
    "node_id": "5d6727cb-bb59-4788-8fa4-abce010c962a",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "Name EcuMSetClockAllowedUserRef [ECUC_EcuM_00198]\nParent Container EcuMSetClockAllowedUsers\nDescription These parameters describe the references to the users which are\nallowed to call the EcuM_SetClock API.\nMultiplicity 1..*\nType Symbolic name reference to EcuMFlexUserConfig\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n\n## Published Information\n\nCurrently there exists no published information except the ones specified in SWS BSW\nGeneral.\n209 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager",
    "source": "..\\data\\md\\autosar_ecum.md"
  },
  "424": {
    "node_id": "faa949c7-e314-4906-b098-9b1b1c1ecd46",
    "title": "AUTOSAR CP R20-11",
    "level": 2,
    "type": "clause",
    "content": "A Not applicable requirements\n[SWS_EcuM_NA_00000] ⌈These requirements are not applicable to this specifica-\ntion.⌋(SRS_BSW_00159, SRS_BSW_00167, SRS_BSW_00406, SRS_BSW_00437,\nSRS_BSW_00168, SRS_BSW_00426, SRS_BSW_00427, SRS_BSW_00432, SRS_-\nBSW_00417, SRS_BSW_00422, SRS_BSW_00161, SRS_BSW_00162, SRS_-\nBSW_00005, SRS_BSW_00415, SRS_BSW_00325, SRS_BSW_00164, SRS_-\nBSW_00160, SRS_BSW_00453, SRS_BSW_00413, SRS_BSW_00347, SRS_-\nBSW_00307, SRS_BSW_00450, SRS_BSW_00410, SRS_BSW_00314, SRS_-\nBSW_00348, SRS_BSW_00353, SRS_BSW_00361, SRS_BSW_00439, SRS_-\nBSW_00449, SRS_BSW_00308, SRS_BSW_00309, SRS_BSW_00330, SRS_-\nBSW_00010, SRS_BSW_00341, SRS_BSW_00334)\n210 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager",
    "source": "..\\data\\md\\autosar_ecum.md"
  }
}