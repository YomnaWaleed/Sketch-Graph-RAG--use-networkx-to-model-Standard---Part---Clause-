{
  "0": {
    "id": "d8a0cb65-f182-4676-9657-f5aedd57e1fe",
    "title": "Document",
    "level": 1,
    "parent_id": null,
    "content": "# Introduction and Functional Overview 13\n\n\n\n## Backwards Compatibility to Previous ECU Manager Module Versions . 14\n\n\n\n# Definitions and Abbreviations 15\n\n\n\n## Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n\n\n## Abbreviations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n\n\n\n# Related documentation 17\n\n\n\n## Input documents & related standards and norms . . . . . . . . . . . . 17\n\n\n\n## Related specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n\n\n\n# Constraints and Assumptions 18\n\n\n\n## Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n\n\n## Hardware Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n\n\n## Applicability to car domains . . . . . . . . . . . . . . . . . . . . . . . . 18\n\n\n\n# Dependencies to other modules 19\n\n\n\n## SPAL Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n\n\n### MCU Driver . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n\n\n\n### Driver Dependencies and Initialization Order . . . . . . . . . 19\n\n\n\n## Peripherals with Wakeup Capability . . . . . . . . . . . . . . . . . . . . 19\n\n\n\n## Operating System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n\n\n## BSW Scheduler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n\n\n## BSW Mode Manager . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n\n\n\n## Software Components . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n\n\n## File Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n\n\n### Code file structure . . . . . . . . . . . . . . . . . . . . . . . . 21\n\n\n\n### Header file structure . . . . . . . . . . . . . . . . . . . . . . . 22\n\n\n\n# Requirements Tracing 23\n\n\n\n# Functional Specification 28\n\n\n\n## Phases of the ECU Manager Module . . . . . . . . . . . . . . . . . . . 28\n\n\n\n### STARTUP Phase . . . . . . . . . . . . . . . . . . . . . . . . . 31\n\n\n\n### UP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\n\n\n\n### SHUTDOWN Phase . . . . . . . . . . . . . . . . . . . . . . . 32\n\n\n\n### SLEEP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n\n\n### OFF Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n\n\n\n## Structural Description of the ECU Manager . . . . . . . . . . . . . . . 33\n\n\n\n### Standardized AUTOSAR Software Modules . . . . . . . . . . 34\n\n\n\n### Software Components . . . . . . . . . . . . . . . . . . . . . . 34\n\n\n\n## STARTUP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34\n\n\n\n### Activities before EcuM_Init . . . . . . . . . . . . . . . . . . . 35\n\n\n\n### Activities in StartPreOS Sequence . . . . . . . . . . . . . . . 35\n\n\n\n### Activities in the StartPostOS Sequence . . . . . . . . . . . . 38\n\n6 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Checking Configuration Consistency . . . . . . . . . . . . . . 39\n\n\n\n#### The Necessity for Checking Configuration Consis-\n\ntency in the ECU Manager . . . . . . . . . . . . . . . 39\n\n#### Example Hash Computation Algorithm . . . . . . . . 41\n\n\n\n### Driver Initialization . . . . . . . . . . . . . . . . . . . . . . . . 42\n\n\n\n### BSW Initialization . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n\n\n## SHUTDOWN Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n\n\n\n### Activities in the OffPreOS Sequence . . . . . . . . . . . . . . 44\n\n\n\n### Activities in the OffPostOS Sequence . . . . . . . . . . . . . 45\n\n\n\n## SLEEP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n\n\n\n### Activities in the GoSleep Sequence . . . . . . . . . . . . . . 49\n\n\n\n### Activities in the Halt Sequence . . . . . . . . . . . . . . . . . 49\n\n\n\n### Activities in the Poll Sequence . . . . . . . . . . . . . . . . . 52\n\n\n\n### Leaving Halt or Poll . . . . . . . . . . . . . . . . . . . . . . . 54\n\n\n\n### Activities in the WakeupRestart Sequence . . . . . . . . . . 54\n\n\n\n## UP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\n\n\n\n### Alarm Clock Handling . . . . . . . . . . . . . . . . . . . . . . 56\n\n\n\n### Wakeup Source State Handling . . . . . . . . . . . . . . . . 56\n\n\n\n### Internal Representation of Wakeup States . . . . . . . . . . 58\n\n\n\n### Activities in the WakeupValidation Sequence . . . . . . . . . 59\n\n\n\n#### Wakeup of Communication Channels . . . . . . . . . 61\n\n\n\n#### Interaction of Wakeup Sources and the ECU Manager 62\n\n\n\n#### Wakeup Validation Timeout . . . . . . . . . . . . . . 62\n\n\n\n#### Requirements for Drivers with Wakeup Sources . . . 63\n\n\n\n### Requirements for Wakeup Validation . . . . . . . . . . . . . . 63\n\n\n\n### Wakeup Sources and Reset Reason . . . . . . . . . . . . . . 63\n\n\n\n### Wakeup Sources with Integrated Power Control . . . . . . . 64\n\n\n\n## Shutdown Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n\n\n\n### Sleep . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n\n\n\n### Reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n\n\n## Alarm Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\n\n\n\n### Alarm Clocks and Users . . . . . . . . . . . . . . . . . . . . . 67\n\n\n\n### EcuM Clock Time . . . . . . . . . . . . . . . . . . . . . . . . 68\n\n\n\n#### EcuM Clock Time in the UP Phase . . . . . . . . . . 68\n\n\n\n#### EcuM Clock Time in the Sleep Phase . . . . . . . . 68\n\n\n\n## MultiCore . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\n\n\n\n### Master Core . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n\n\n### Slave Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n\n\n\n### Master Core - Slave Core Signalling . . . . . . . . . . . . . . 70\n\n\n\n#### BSW Level . . . . . . . . . . . . . . . . . . . . . . . 70\n\n\n\n#### Example for Shutdown Synchronization . . . . . . . 71\n\n\n\n### UP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\n\n\n### STARTUP Phase . . . . . . . . . . . . . . . . . . . . . . . . . 73\n\n\n\n#### Master Core STARTUP . . . . . . . . . . . . . . . . 74\n\n\n\n#### Slave Core STARTUP . . . . . . . . . . . . . . . . . 76\n\n\n\n### SHUTDOWN Phase . . . . . . . . . . . . . . . . . . . . . . . 78\n\n7 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### Master Core SHUTDOWN . . . . . . . . . . . . . . . 80\n\n\n\n#### Slave Core SHUTDOWN . . . . . . . . . . . . . . . . 82\n\n\n\n### SLEEP Phase . . . . . . . . . . . . . . . . . . . . . . . . . . 83\n\n\n\n#### Master Core SLEEP . . . . . . . . . . . . . . . . . . 84\n\n\n\n#### Slave Core SLEEP . . . . . . . . . . . . . . . . . . . 87\n\n\n\n### Runnables and Entry points . . . . . . . . . . . . . . . . . . . 91\n\n\n\n#### Internal behavior . . . . . . . . . . . . . . . . . . . . 91\n\n\n\n## EcuM Mode Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93\n\n\n\n## Advanced Topics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95\n\n\n\n### Relation to Bootloader . . . . . . . . . . . . . . . . . . . . . . 95\n\n\n\n### Relation to Complex Drivers . . . . . . . . . . . . . . . . . . 96\n\n\n\n### Handling Errors during Startup and Shutdown . . . . . . . . 96\n\n\n\n## ErrorHook . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n\n\n\n## Error classification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\n\n\n\n### Development Errors . . . . . . . . . . . . . . . . . . . . . . . 97\n\n\n\n### Runtime Errors . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\n### Transient Faults . . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\n### Production Errors . . . . . . . . . . . . . . . . . . . . . . . . 98\n\n\n\n### Extended Production Errors . . . . . . . . . . . . . . . . . . . 98\n\n\n\n# API specification 99\n\n\n\n## Imported Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n\n\n\n## Type definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100\n\n\n\n### EcuM_ConfigType . . . . . . . . . . . . . . . . . . . . . . . . 100\n\n\n\n### EcuM_RunStatusType . . . . . . . . . . . . . . . . . . . . . . 101\n\n\n\n### EcuM_WakeupSourceType . . . . . . . . . . . . . . . . . . . 101\n\n\n\n### EcuM_WakeupStatusType . . . . . . . . . . . . . . . . . . . 102\n\n\n\n### EcuM_ResetType . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n\n\n### EcuM_StateType . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n\n\n## Function Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n\n\n\n### General . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\n\n\n\n#### EcuM_GetVersionInfo . . . . . . . . . . . . . . . . . 104\n\n\n\n### Initialization and Shutdown Sequences . . . . . . . . . . . . 104\n\n\n\n#### EcuM_GoDownHaltPoll . . . . . . . . . . . . . . . . 104\n\n\n\n#### EcuM_Init . . . . . . . . . . . . . . . . . . . . . . . . 105\n\n\n\n#### EcuM_StartupTwo . . . . . . . . . . . . . . . . . . . 105\n\n\n\n#### EcuM_Shutdown . . . . . . . . . . . . . . . . . . . . 106\n\n\n\n### State Management . . . . . . . . . . . . . . . . . . . . . . . 107\n\n\n\n#### EcuM_ SetState . . . . . . . . . . . . . . . . . . . . 107\n\n\n\n#### EcuM_RequestRUN . . . . . . . . . . . . . . . . . . 107\n\n\n\n#### EcuM_ReleaseRUN . . . . . . . . . . . . . . . . . . 108\n\n\n\n#### EcuM_RequestPOST_RUN . . . . . . . . . . . . . . 109\n\n\n\n#### EcuM_ReleasePOST_RUN . . . . . . . . . . . . . . 109\n\n\n\n### Shutdown Management . . . . . . . . . . . . . . . . . . . . . 110\n\n\n\n#### EcuM_SelectShutdownTarget . . . . . . . . . . . . . 110\n\n\n\n#### EcuM_GetShutdownTarget . . . . . . . . . . . . . . 111\n\n8 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### EcuM_GetLastShutdownTarget . . . . . . . . . . . . 112\n\n\n\n#### EcuM_SelectShutdownCause . . . . . . . . . . . . . 113\n\n\n\n#### EcuM_GetShutdownCause . . . . . . . . . . . . . . 113\n\n\n\n### Wakeup Handling . . . . . . . . . . . . . . . . . . . . . . . . 114\n\n\n\n#### EcuM_GetPendingWakeupEvents . . . . . . . . . . 114\n\n\n\n#### EcuM_ClearWakeupEvent . . . . . . . . . . . . . . . 115\n\n\n\n#### EcuM_GetValidatedWakeupEvents . . . . . . . . . . 116\n\n\n\n#### EcuM_GetExpiredWakeupEvents . . . . . . . . . . . 116\n\n\n\n### Alarm Clock . . . . . . . . . . . . . . . . . . . . . . . . . . . 117\n\n\n\n#### EcuM_SetRelWakeupAlarm . . . . . . . . . . . . . . 117\n\n\n\n#### EcuM_SetAbsWakeupAlarm . . . . . . . . . . . . . . 118\n\n\n\n#### EcuM_AbortWakeupAlarm . . . . . . . . . . . . . . . 118\n\n\n\n#### EcuM_GetCurrentTime . . . . . . . . . . . . . . . . 119\n\n\n\n#### EcuM_GetWakeupTime . . . . . . . . . . . . . . . . 119\n\n\n\n#### EcuM_SetClock . . . . . . . . . . . . . . . . . . . . . 120\n\n\n\n### Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n\n\n\n#### EcuM_SelectBootTarget . . . . . . . . . . . . . . . . 121\n\n\n\n#### EcuM_GetBootTarget . . . . . . . . . . . . . . . . . 121\n\n\n\n## Callback Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122\n\n\n\n### Callbacks from Wakeup Sources . . . . . . . . . . . . . . . . 122\n\n\n\n#### EcuM_CheckWakeup . . . . . . . . . . . . . . . . . 122\n\n\n\n#### EcuM_SetWakeupEvent . . . . . . . . . . . . . . . . 122\n\n\n\n#### EcuM_ValidateWakeupEvent . . . . . . . . . . . . . 123\n\n\n\n## Callout Definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\n\n\n\n### Generic Callouts . . . . . . . . . . . . . . . . . . . . . . . . . 124\n\n\n\n#### EcuM_ErrorHook . . . . . . . . . . . . . . . . . . . . 124\n\n\n\n### Callouts from the STARTUP Phase . . . . . . . . . . . . . . 125\n\n\n\n#### EcuM_AL_SetProgrammableInterrupts . . . . . . . . 125\n\n\n\n#### EcuM_AL_DriverInitZero . . . . . . . . . . . . . . . . 126\n\n\n\n#### EcuM_DeterminePbConfiguration . . . . . . . . . . . 126\n\n\n\n#### EcuM_AL_DriverInitOne . . . . . . . . . . . . . . . . 127\n\n\n\n#### EcuM_LoopDetection . . . . . . . . . . . . . . . . . 128\n\n\n\n### Callouts from the SHUTDOWN Phase . . . . . . . . . . . . . 128\n\n\n\n#### EcuM_OnGoOffOne . . . . . . . . . . . . . . . . . . 128\n\n\n\n#### EcuM_OnGoOffTwo . . . . . . . . . . . . . . . . . . 129\n\n\n\n#### EcuM_AL_SwitchOff . . . . . . . . . . . . . . . . . . 129\n\n\n\n#### EcuM_AL_Reset . . . . . . . . . . . . . . . . . . . . 130\n\n\n\n### Callouts from the SLEEP Phase . . . . . . . . . . . . . . . . 131\n\n\n\n#### EcuM_EnableWakeupSources . . . . . . . . . . . . 131\n\n\n\n#### EcuM_GenerateRamHash . . . . . . . . . . . . . . . 131\n\n\n\n#### EcuM_SleepActivity . . . . . . . . . . . . . . . . . . 132\n\n\n\n#### EcuM_StartCheckWakeup . . . . . . . . . . . . . . . 133\n\n\n\n#### EcuM_CheckWakeup . . . . . . . . . . . . . . . . . 133\n\n\n\n#### EcuM_EndCheckWakeup . . . . . . . . . . . . . . . 134\n\n\n\n#### EcuM_CheckRamHash . . . . . . . . . . . . . . . . 135\n\n\n\n#### EcuM_DisableWakeupSources . . . . . . . . . . . . 135\n\n9 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### EcuM_AL_DriverRestart . . . . . . . . . . . . . . . . 136\n\n\n\n### Callouts from the UP Phase . . . . . . . . . . . . . . . . . . 137\n\n\n\n#### EcuM_StartWakeupSources . . . . . . . . . . . . . . 137\n\n\n\n#### EcuM_CheckValidation . . . . . . . . . . . . . . . . . 137\n\n\n\n#### EcuM_StopWakeupSources . . . . . . . . . . . . . . 138\n\n\n\n## Scheduled Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n\n\n\n### EcuM_MainFunction . . . . . . . . . . . . . . . . . . . . . . . 139\n\n\n\n## Expected Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\n\n\n\n### Optional Interfaces . . . . . . . . . . . . . . . . . . . . . . . . 140\n\n\n\n### Configurable interfaces . . . . . . . . . . . . . . . . . . . . . 141\n\n\n\n#### Callbacks from the STARTUP phase . . . . . . . . . 141\n\n\n\n## Specification of the Port Interfaces . . . . . . . . . . . . . . . . . . . . 142\n\n\n\n### Ports and Port Interface for EcuM_ShutdownTarget Interface 142\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 142\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 142\n\n\n\n### Port Interface for EcuM_BootTarget Interface . . . . . . . . . 145\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 145\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 145\n\n\n\n### Port Interface for EcuM_AlarmClock Interface . . . . . . . . 146\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 146\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 146\n\n\n\n### Port Interface for EcuM_Time Interface . . . . . . . . . . . . 147\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 147\n\n\n\n#### Data Types . . . . . . . . . . . . . . . . . . . . . . . 147\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 147\n\n\n\n### Port Interface for EcuM_StateRequest Interface . . . . . . . 148\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 149\n\n\n\n#### Data Types . . . . . . . . . . . . . . . . . . . . . . . 149\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 149\n\n\n\n### Port Interface for EcuM_CurrentMode Interface . . . . . . . . 150\n\n\n\n#### General Approach . . . . . . . . . . . . . . . . . . . 150\n\n\n\n#### Data Types . . . . . . . . . . . . . . . . . . . . . . . 151\n\n\n\n#### Service Interfaces . . . . . . . . . . . . . . . . . . . 151\n\n\n\n### Definition of the ECU Manager Service . . . . . . . . . . . . 151\n\n\n\n## API Parameter Checking . . . . . . . . . . . . . . . . . . . . . . . . . . 156\n\n\n\n# Sequence Charts 157\n\n\n\n## State Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n\n\n\n## Wakeup Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n\n\n\n### GPT Wakeup Sequences . . . . . . . . . . . . . . . . . . . . 157\n\n\n\n### ICU Wakeup Sequences . . . . . . . . . . . . . . . . . . . . 160\n\n\n\n### CAN Wakeup Sequences . . . . . . . . . . . . . . . . . . . . 162\n\n\n\n### LIN Wakeup Sequences . . . . . . . . . . . . . . . . . . . . . 169\n\n\n\n### FlexRay Wakeup Sequences . . . . . . . . . . . . . . . . . . 173\n\n\n\n# Configuration specification 176\n\n\n\n## Common Containers and configuration parameters . . . . . . . . . . . 176\n\n10 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\n\n\n\n### EcuMGeneral . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n\n\n\n### EcuMConfiguration . . . . . . . . . . . . . . . . . . . . . . . 180\n\n\n\n### EcuMCommonConfiguration . . . . . . . . . . . . . . . . . . 181\n\n\n\n### EcuMDefaultShutdownTarget . . . . . . . . . . . . . . . . . . 183\n\n\n\n### EcuMDriverInitListOne . . . . . . . . . . . . . . . . . . . . . 185\n\n\n\n### EcuMDriverInitListZero . . . . . . . . . . . . . . . . . . . . . 186\n\n\n\n### EcuMDriverRestartList . . . . . . . . . . . . . . . . . . . . . 186\n\n\n\n### EcuMDriverInitItem . . . . . . . . . . . . . . . . . . . . . . . 187\n\n\n\n### EcuMSleepMode . . . . . . . . . . . . . . . . . . . . . . . . . 190\n\n\n\n### EcuMWakeupSource . . . . . . . . . . . . . . . . . . . . . . 192\n\n\n\n## EcuM-Flex Containers and configuration parameters . . . . . . . . . . 196\n\n\n\n### EcuMFlexGeneral . . . . . . . . . . . . . . . . . . . . . . . . 196\n\n\n\n### EcuMFlexConfiguration . . . . . . . . . . . . . . . . . . . . . 200\n\n\n\n### EcuMAlarmClock . . . . . . . . . . . . . . . . . . . . . . . . 202\n\n\n\n### EcuMDriverInitListBswM . . . . . . . . . . . . . . . . . . . . 204\n\n\n\n### EcuMGoDownAllowedUsers . . . . . . . . . . . . . . . . . . 206\n\n\n\n### EcuMResetMode . . . . . . . . . . . . . . . . . . . . . . . . 206\n\n\n\n### EcuMSetClockAllowedUsers . . . . . . . . . . . . . . . . . . 207\n\n\n\n## Published Information . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\n\nA Not applicable requirements 210\n11 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nKnown Limitations\n•The ECU Manager module interfaces must be specified as reentrant in the Multi-\nCore context.\n12 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Introduction and Functional Overview\n\nThe ECU Manager module (as specified in this document) is a basic software module\n(see [1]) that manages common aspects of ECU states. Specifically, the ECU Manager\nmodule:\n•Initializes and de-initializes the OS, the SchM and the BswM as well as some\nbasic software driver modules.\n•configures the ECU for SLEEP and SHUTDOWN when requested.\n•manages all wakeup events on the ECU\nThe ECU Manager module provides the wakeup validation protocol to distinguish ’real’\nwakeup events from ’erratic’ ones.\nFurthermore:\n•Partial or fast startup where he ECU starts up with limited capabilities and later,\nas determined by the application, continues startup step by step.\n•Interleaved startup where the ECU starts minimally and then starts the RTE to\nexecute functionality in SW-Cs as soon as possible. It then continues to start\nfurther BSW and SW-Cs, thus interleaving BSW and application functionality..\n•Multiple operational states where the ECU has more than one RUN state. This,\namong other things, refines the notion of a spectrum of SLEEP states to RUN\nstates. There can now be a continuum of operational states spanning from the\nclassic RUN (fully operational) to the deepest SLEEP (processor halted).\n•Multi-Core ECUs: STARTUP , SHUTDOWN, SLEEP and WAKEUP are coordi-\nnated on all cores of the ECU.\nFlexible ECU management employs the generic mode management facilities provided\nby the following modules:\n•RTE and BSW Scheduler module [2] are now amalgamated into one module:\nThis module supports freely configurable BSW and application modes and their\nmode-switching facilities.\n•BSW Mode Manager module [3]: This module implements configurable rules and\naction lists to evaluate the conditions for switching ECU modes and to implement\nthe necessary actions to do so.\nThus with Flexible ECU Management, most ECU states are no longer implemented\nin the ECU Manager module itself. In general, the ECU Manager module takes over\ncontrol when the generic mode management facilities are unavailable in:\n•Early STARTUP phases,\n•Late SHUTDOWN phases,\n•SLEEP phases where the facilities are locked out by the scheduler.\n13 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nDuring the UP Phase of the ECU Manager module the BSW Mode Manager is re-\nsponsible for further actions. Whereas, the ECU Manager module arbitrates RUN and\nPOST_RUN Requests from SW-Cs and notifies BswM about the status of the modes.\n\n## Backwards Compatibility to Previous ECU Manager Module\n\nVersions\nFlexible ECU management is backward compatible to previous ECU Manager versions\nif it is configured accordingly.\nFor more information about a configuration in respect to compatibility see the \"Guide\nto Mode Management\" [4].\n14 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Definitions and Abbreviations\n\nThis chapter defines terms that are of special significance to the ECU Manager and\nthe acronyms of related modules.\n\n## Definitions\n\nTerm Description\nCallback Refer to the Glossary [5]\nCallout\n’Callouts’ are function stubs that the system designer can replace\nwith code, usually at configuration time, to add functionality to the\nECU Manager module. Callouts are separated into two classes.\nOne class provides mandatory ECU Manager module functional-\nity and serves as a hardware abstraction layer. The other class\nprovides optional functionality.\nIntegration Code Refer to the Glossary [5]\nMode\nA Mode is a certain set of states of the various state machines\n(not only of the ECU Manager) that are running in the vehicle\nand are relevant to a particular entity, an application or the whole\nvehicle\nPassive Wakeup A wakeup caused from an attached bus rather than an internal\nevent like a timer or sensor activity.\nPhase\nA logical or temporal assembly of ECU Manager’s actions and\nevents, e.g. STARTUP , UP , SHUTDOWN, SLEEP , ... Phases\ncan consist of Sub-Phases which are often called Sequences if\nthey above all exist to group sequences of executed actions into\nlogical units. Phases in this context are not the phases of the\nAUTOSAR Methodology.\nShutdown Target\nThe ECU must be shut down before it is put to sleep, before it is\npowered off or before it is reset. SLEEP , OFF , and RESET are\ntherefore valid shutdown targets. By selecting a shutdown target,\nan application can communicate its wishes for the ECU behavior\nafter the next shutdown to the ECU Manager module.\nState\nStates are internal to their respective BSW component and thus\nnot visible to the application. So they are only used by the BSW’s\ninternal state machine. The States inside the ECU Manager build\nthe phases and therefore handle the modes.\nWakeup Event\nA physical event which causes a wakeup. A CAN message or a\ntoggling IO line can be wakeup events. Similarly, the internal SW\nrepresentation, e.g. an interrupt, may also be called a wakeup\nevent.\nWakeup Reason The wakeup reason is the wakeup event that is the actual cause\nof the last wakeup.\nWakeup Source\nThe peripheral or ECU component which deals with wakeup\nevents is called a wakeup source.\n\n## Abbreviations\n\n15 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nAbbreviation Description\nBswM Basic Software Mode Manager\nDem Diagnostic Event Manager\nDet Default Error Tracer\nEcuM ECU Manager\nGpt General Purpose Timer\nIcu Input Capture Unit\nISR Interrupt Service Routine\nMcu Microcontroller Unit\nNVRAM Non-volatile random access memory\nOs Operating System\nRte Runtime Environment\nVFB Virtual Function Bus\n16 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Related documentation\n\n\n\n## Input documents & related standards and norms\n\n[1] List of Basic Software Modules\nAUTOSAR_TR_BSWModuleList\n[2] Specification of RTE Software\nAUTOSAR_SWS_RTE\n[3] Specification of Basic Software Mode Manager\nAUTOSAR_SWS_BSWModeManager\n[4] Guide to Mode Management\nAUTOSAR_EXP_ModeManagementGuide\n[5] Glossary\nAUTOSAR_TR_Glossary\n[6] General Specification of Basic Software Modules\nAUTOSAR_SWS_BSWGeneral\n[7] Virtual Functional Bus\nAUTOSAR_EXP_VFB\n[8] General Requirements on Basic Software Modules\nAUTOSAR_SRS_BSWGeneral\n[9] Requirements on Mode Management\nAUTOSAR_SRS_ModeManagement\n[10] Specification of MCU Driver\nAUTOSAR_SWS_MCUDriver\n[11] Specification of CAN Transceiver Driver\nAUTOSAR_SWS_CANTransceiverDriver\n\n## Related specification\n\nAUTOSAR provides a General Specification on Basic Software modules (see [6]),\nwhich is also valid for ECU State Manager. Thus, the specification [6] shall be con-\nsidered as additional and required specification for ECU State Manager.\n17 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Constraints and Assumptions\n\n\n\n## Limitations\n\nECUs cannot always be switched off (i.e. zero power consumption).\nRationale: The shutdown target OFF can only be reached using ECU special hardware\n(e.g. a power hold circuit). If this hardware is not available, this specification proposes\nto issue a reset instead. Other default behaviors are permissible, however.\n\n## Hardware Requirements\n\nIn this section, the term \"EcuM RAM\" refers to a block of RAM reserved for use by the\nECU Manager module.\nThe EcuM RAM shall keep contents of vital data while the ECU clock is switched off.\nRationale: This requirement is needed to implement sleep states as required in section\n\n## SLEEP Phase.\n\nThe EcuM RAM shall provide a no-init area that keeps contents over a reset cycle.\nThe no-init area of the EcuM RAM (see EcuM2869) shall only be initialized on a power\non event (clamp 30).\nThe system designer is responsible for establishing an initialization strategy for the no\ninit area of the ECU RAM.\n\n## Applicability to car domains\n\nThe ECU Manager module is applicable to all car domains.\n18 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Dependencies to other modules\n\nThe following sections outline the important relationships to other modules. They also\ncontain some requirements that these modules must fulfill to collaborate correctly with\nthe ECU Manager module.\nIf data pointers are passed to a BSW module, the address needs to point to a location\nin the shared part of the memory space.\n\n## SPAL Modules\n\n\n\n### MCU Driver\n\nThe MCU Driver is the first basic software module initialized by the ECU Manager\nmodule. When MCU_Init returns (see [SWS_EcuM_02858]), the MCU module and\nthe MCU Driver module are not necessarily fully initialized, however. Additional MCU\nmodule specific steps may be needed to complete the initialization. The ECU Manager\nmodule provides two callout where this additional code can be placed. Refer to section\n\n### Activities in StartPreOS Sequence for details.\n\n\n\n### Driver Dependencies and Initialization Order\n\nBSW drivers may depend on each other. A typical example is the watchdog driver,\nwhich needs the SPI driver to access an external watchdog. This means on the one\nhand, that drivers may be stacked (not relevant to the ECU Manager module) and on\nthe other hand that the called module must be initialized before the calling module is\ninitialized.\nThe system designer is responsible for defining the initialization order at configuration\ntime in EcuMDriverInitListZero, EcuMDriverInitListOne, EcuMDriver-\nRestartList and inEcuMDriverInitListBswM.\n\n## Peripherals with Wakeup Capability\n\nWakeup sources must be handled and encapsulated by drivers.\nThese drivers must follow the protocols and requirements presented in this document\nto ensure a seamless integration into the AUTOSAR BSW. Basically, the protocol is as\nfollows:\nThe driver must invoke EcuM_SetWakeupEvent (see [SWS_EcuM_02826]) to notify\nthe ECU Manager module that a pending wakeup event has been detected. The driver\nmust not only invoke EcuM_SetWakeupEvent while the ECU is waiting for a wakeup\n19 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nevent during a sleep phase but also during the driver initialization phase and during\nnormal operation when EcuM_MainFunction is running.\nThe driver must provide an explicit function to put the wakeup source to sleep. This\nfunction shall put the wakeup source into an energy saving and inert operation mode\nand rearm the wakeup notification mechanism.\nIf the wakeup source is capable of generating spurious events1 then either\n•the driver or\n•the software stack consuming the driver or\n•another appropriate BSW module\nmust either provide a validation callout for the wakeup event or call the ECU Manager\nmodule’s validation function. If validation is not necessary, then this requirement is not\napplicable for the corresponding wakeup source.\n\n## Operating System\n\nThe ECU Manager module starts the AUTOSAR OS and also shuts it down. The ECU\nManager module defines the protocol how control is handled before the OS is started\nand how control is handled after the OS has been shut down.\n\n## BSW Scheduler\n\nThe ECU Manager module initializes the BSW Scheduler and the ECU Manager mod-\nule also contains EcuM_MainFunction (see [SWS_EcuM_02837]) which is scheduled\nto periodically evaluate wakeup requests and update the Alarm Clock.\n\n## BSW Mode Manager\n\nECU states are generally implemented as AUTOSAR modes and the BSW Mode Man-\nager is responsible for monitoring changes in the ECU and affecting the corresponding\nchanges to the ECU state machine as appropriate. Refer to the Specification of the\nVirtual Function Bus [7] for a discussion of AUTOSAR mode management and to the\nGuide to Mode Management [4] for ECU state machine implementation details and\nfor guidelines about how to configure the BSW Mode Manager to implement the ECU\nstate machine\nThe BSW Mode Manager can only manage the ECU state machine after mode man-\nagement is operational - that is, after the SchM has been initialized and until the SchM\n1Spurious wakeup events may result from EMV spikes, bouncing effects on wakeup lines etc.\n20 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nis de-initialised or halted. The ECU Manager module takes control of the ECU when\nthe BSW Mode manager is not operational.\nThe ECU Manager module therefore takes control immediately after the ECU has\nbooted and relegates control to the BSW Mode Manager after initializing the SchM\nand the BswM.\nThe BswM passes control of the ECU back to the ECU Manager module to lock the\noperating system and handle wakeup events.\nThe BswM also passes control back to the ECU Manager immediately before the OS\nis stopped on shutdown.\nWhen wakeup sources are being validated, the ECU Manager module indicates\nwakeup source state changes to the BswM through mode switch requests.\n\n## Software Components\n\nThe ECU Manager module handles the following ECU-wide properties:\n•Shutdown targets.\nThis specification assumes that SW-Cs set these properties (through AUTOSAR ports),\ntypically by some ECU specific part of the SW-C. The ECU Manager does not prevent\na SW-C from overrighting settings made by SW-Cs. The policy must be defined at a\nhigher level.\nThe following measures might help to resolve this issue.\n•The SW-C Template may contain a field to indicate whether the SW-C sets the\nshutdown target.\n•The generation tool may only allow configurations that have one SW-C accessing\nthe shutdown target.\n\n## File Structure\n\n\n\n### Code file structure\n\nThis specification does not define the code file structure completely.\n[SWS_EcuM_02990] ⌈The ECU Manager module implementation shall provide a sin-\ngle EcuM_Callout_Stubs.c file which contains the stubs of the callouts realized in\nthis implementation.⌋()\nSee also section 8.5 Callout Definitions for a list of the callouts that could possibly be\nimplemented.\n21 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nWhether EcuM_Callout_Stubs.c can be edited manually or is composed only of\nother generated files depends on the implementation.\n\n### Header file structure\n\nAlso refer to chapter 8.7 Expected Interfaces for dependencies to other modules.\n22 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Requirements Tracing\n\nThe following tables reference the requirements specified in [8] and [9] and links to the\nfulfillment of these. Please note that if column \"Satisfied by\" is empty for a specific\nrequirement this means that this requirement is not fulfilled by this document.\nRequirement Description Satisfied by\n[SRS_BSW_00005] Modules of theµC Abstraction Layer\n(MCAL) may not have hard coded\nhorizontal interfaces\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00010] The memory consumption of all Basic\nSW Modules shall be documented for\na defined configuration for all\nsupported platforms.\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00101] The Basic Software Module shall be\nable to initialize variables and\nhardware in a separate initialization\nfunction\n[SWS_EcuM_02811]\n[SRS_BSW_00159] All modules of the AUTOSAR Basic\nSoftware shall support a tool based\nconfiguration\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00160] Configuration files of AUTOSAR\nBasic SW module shall be readable\nfor human beings\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00161] The AUTOSAR Basic Software shall\nprovide a microcontroller abstraction\nlayer which provides a standardized\ninterface to higher software layers\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00162] The AUTOSAR Basic Software shall\nprovide a hardware abstraction layer\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00164] The Implementation of interrupt\nservice routines shall be done by the\nOperating System, complex drivers or\nmodules\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00167] All AUTOSAR Basic Software\nModules shall provide configuration\nrules and constraints to enable\nplausibility checks\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00168] SW components shall be tested by a\nfunction defined in a common API in\nthe Basis-SW\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00172] The scheduling strategy that is built\ninside the Basic Software Modules\nshall be compatible with the strategy\nused in the system\n[SWS_EcuM_02836]\n[SRS_BSW_00307] Global variables naming convention [SWS_EcuM_NA_00000]\n[SRS_BSW_00308] AUTOSAR Basic Software Modules\nshall not define global data in their\nheader files, but in the C file\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00309] All AUTOSAR Basic Software\nModules shall indicate all global data\nwith read-only purposes by explicitly\nassigning the const keyword\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00314] All internal driver modules shall\nseparate the interrupt frame definition\nfrom the service routine\n[SWS_EcuM_NA_00000]\n▽\n23 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nRequirement Description Satisfied by\n[SRS_BSW_00323] All AUTOSAR Basic Software\nModules shall check passed API\nparameters for validity\n[SWS_EcuM_03009]\n[SRS_BSW_00325] The runtime of interrupt service\nroutines and functions that are\nrunning in interrupt context shall be\nkept short\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00327] Error values naming convention [SWS_EcuM_04032]\n[SRS_BSW_00330] It shall be allowed to use macros\ninstead of functions where source\ncode is used and runtime is critical\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00331] All Basic Software Modules shall\nstrictly separate error and status\ninformation\n[SWS_EcuM_91005]\n[SRS_BSW_00333] For each callback function it shall be\nspecified if it is called from interrupt\ncontext or not\n[SWS_EcuM_02171] [SWS_EcuM_02345]\n[SRS_BSW_00334] All Basic Software Modules shall\nprovide an XML file that contains the\nmeta data\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00337] Classification of development errors [SWS_EcuM_04032]\n[SRS_BSW_00339] Reporting of production relevant error\nstatus\n[SWS_EcuM_02987]\n[SRS_BSW_00341] Module documentation shall contains\nall needed informations\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00347] A Naming seperation of different\ninstances of BSW drivers shall be in\nplace\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00348] All AUTOSAR standard types and\nconstants shall be placed and\norganized in a standard type header\nfile\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00350] All AUTOSAR Basic Software\nModules shall allow the enabling/\ndisabling of detection and reporting of\ndevelopment errors.\n[SWS_EcuM_04032]\n[SRS_BSW_00353] All integer type definitions of target\nand compiler specific scope shall be\nplaced and organized in a single type\nheader\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00358] The return type of init() functions\nimplemented by AUTOSAR Basic\nSoftware Modules shall be void\n[SWS_EcuM_02811]\n[SRS_BSW_00359] All AUTOSAR Basic Software\nModules callback functions shall\navoid return types other than void if\npossible\n[SWS_EcuM_02826] [SWS_EcuM_02829]\n[SRS_BSW_00360] AUTOSAR Basic Software Modules\ncallback functions are allowed to\nhave parameters\n[SWS_EcuM_02826] [SWS_EcuM_02829]\n[SRS_BSW_00361] All mappings of not standardized\nkeywords of compiler specific scope\nshall be placed and organized in a\ncompiler specific type and keyword\nheader\n[SWS_EcuM_NA_00000]\n▽\n24 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nRequirement Description Satisfied by\n[SRS_BSW_00373] The main processing function of each\nAUTOSAR Basic Software Module\nshall be named according the defined\nconvention\n[SWS_EcuM_02837]\n[SRS_BSW_00385] List possible error notifications [SWS_EcuM_04032]\n[SRS_BSW_00406] A static status variable denoting if a\nBSW module is initialized shall be\ninitialized with value 0 before any\nAPIs of the BSW module is called\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00407] Each BSW module shall provide a\nfunction to read out the version\ninformation of a dedicated module\nimplementation\n[SWS_EcuM_02813]\n[SRS_BSW_00410] Compiler switches shall have defined\nvalues\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00411] All AUTOSAR Basic Software\nModules shall apply a naming rule for\nenabling/disabling the existence of\nthe API\n[SWS_EcuM_02813]\n[SRS_BSW_00413] An index-based accessing of the\ninstances of BSW modules shall be\ndone\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00414] Init functions shall have a pointer to a\nconfiguration structure as single\nparameter\n[SWS_EcuM_02811]\n[SRS_BSW_00415] Interfaces which are provided\nexclusively for one module shall be\nseparated into a dedicated header file\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00416] The sequence of modules to be\ninitialized shall be configurable\n[SWS_EcuM_02559]\n[SRS_BSW_00417] Software which is not part of the\nSW-C shall report error events only\nafter the DEM is fully operational.\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00422] Pre-de-bouncing of error status\ninformation is done within the DEM\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00425] The BSW module description\ntemplate shall provide means to\nmodel the defined trigger conditions\nof schedulable objects\n[SWS_EcuM_02837]\n[SRS_BSW_00426] BSW Modules shall ensure data\nconsistency of data which is shared\nbetween BSW modules\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00427] ISR functions shall be defined and\ndocumented in the BSW module\ndescription template\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00432] Modules should have separate main\nprocessing functions for read/receive\nand write/transmit data path\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00437] Memory mapping shall provide the\npossibility to define RAM segments\nwhich are not to be initialized during\nstartup\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00439] Enable BSW modules to handle\ninterrupts\n[SWS_EcuM_NA_00000]\n▽\n25 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nRequirement Description Satisfied by\n[SRS_BSW_00440] The callback function invocation by\nthe BSW module shall follow the\nsignature provided by RTE to invoke\nservers via Rte_Call API\n[SWS_EcuM_02826] [SWS_EcuM_02829]\n[SRS_BSW_00449] BSW Service APIs used by Autosar\nApplication Software shall return a\nStd_ReturnType\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00450] A Main function of a un-initialized\nmodule shall return immediately\n[SWS_EcuM_NA_00000]\n[SRS_BSW_00453] BSW Modules shall be harmonized [SWS_EcuM_NA_00000]\n[SRS_ModeMgm_-\n09072]\nECU shutdown shall be forced [SWS_EcuM_03022]\n[SRS_ModeMgm_-\n09098]\nStoring the wake-up reasons shall be\navailable\n[SWS_EcuM_02826]\n[SRS_ModeMgm_-\n09100]\nSelection of wake-up sources shall\nbe configurable\n[SWS_EcuM_02389]\n[SRS_ModeMgm_-\n09104]\nECU State Manager shall take over\ncontrol after OS shutdown\n[SWS_EcuM_02952] [SWS_EcuM_02953]\n[SRS_ModeMgm_-\n09113]\nInitialization of Basic Software\nmodules shall be done\n[SWS_EcuM_02932]\n[SRS_ModeMgm_-\n09114]\nStarting/invoking the shutdown\nprocess shall be provided\n[SWS_EcuM_00624] [SWS_EcuM_02185]\n[SWS_EcuM_02585] [SWS_EcuM_02812]\n[SWS_EcuM_02822]\n[SRS_ModeMgm_-\n09116]\nRequesting and releasing the RUN\nstate shall be provided\n[SWS_EcuM_04115] [SWS_EcuM_04116]\n[SWS_EcuM_04117] [SWS_EcuM_04118]\n[SWS_EcuM_04119] [SWS_EcuM_04120]\n[SWS_EcuM_04121] [SWS_EcuM_04123]\n[SWS_EcuM_04125] [SWS_EcuM_04126]\n[SWS_EcuM_04127] [SWS_EcuM_04128]\n[SWS_EcuM_04129] [SWS_EcuM_04130]\n[SWS_EcuM_04132]\n[SRS_ModeMgm_-\n09126]\nAn API for querying the wake-up\nreason shall be provided\n[SWS_EcuM_02827] [SWS_EcuM_02828]\n[SWS_EcuM_02830] [SWS_EcuM_02831]\n[SRS_ModeMgm_-\n09127]\nThe ECU State Manager shall\nde-initialize Basic Software modules\nwhere appropriate during the\nshutdown process\n[SWS_EcuM_03021]\n[SRS_ModeMgm_-\n09128]\nSeveral shutdown targets shall be\nsupported\n[SWS_EcuM_02822] [SWS_EcuM_02824]\n[SWS_EcuM_02825]\n[SRS_ModeMgm_-\n09136]\nThe ECU State Manager shall be the\nreceiver of all wake-up events\n[SWS_EcuM_04091]\n[SRS_ModeMgm_-\n09186]\nAlarm Clock shall be active while the\nECU is powered\n[SWS_EcuM_04054] [SWS_EcuM_04055]\n[SWS_EcuM_04056] [SWS_EcuM_04057]\n[SWS_EcuM_04058] [SWS_EcuM_04059]\n[SWS_EcuM_04060]\n[SRS_ModeMgm_-\n09187]\nIn Case of wakeup, all the alarm\nclock shall be canceled\n[SWS_EcuM_04009]\n[SRS_ModeMgm_-\n09188]\nIn Case of startup, all the alarm clock\nshall be canceled\n[SWS_EcuM_04010]\n[SRS_ModeMgm_-\n09190]\nThe alarm clock service shall allow\nsetting an alarm relative to the\ncurrent time using a time resolution of\nseconds\n[SWS_EcuM_04054]\n▽\n26 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nRequirement Description Satisfied by\n[SRS_ModeMgm_-\n09194]\nThe alarm clock service shall allow\nsetting the clock\n[SWS_EcuM_04064]\n[SRS_ModeMgm_-\n09199]\nThe alarm clock service shall allow\nsetting an alarm absolute by using an\nabsolute time with a resolution of\nseconds\n[SWS_EcuM_04057]\n[SRS_ModeMgm_-\n09234]\nThe EcuM shall handle the\ninitialization of Basic Software\nmodules\n[SWS_EcuM_02559] [SWS_EcuM_02730]\n[SWS_EcuM_02947]\n[SRS_ModeMgm_-\n09235]\nThe ECU State Manager shall offer\ntwo targets for shutting down the ECU\n[SWS_EcuM_00624] [SWS_EcuM_02156]\n[SWS_EcuM_02822] [SWS_EcuM_02824]\n[SWS_EcuM_02825]\n[SRS_ModeMgm_-\n09239]\nTo shutdown, ShutdownAllCores shall\nbe called on the master core after\nsynchronizing all cores\n[SWS_EcuM_04024]\nTable 6.1: RequirementsTracing\n27 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Functional Specification\n\nChapter 1 introduced the new, more flexible approach to ECU state management.\nHowever, this flexibility comes at the price of responsibility. There are no standard ECU\nmodes, or states. The integrator of an ECU must decide which states are needed and\nalso configure them.\nWhen ECU Mode Handling is used, the standard states RUN and POST_RUN are\narbitrated by the RUN Request Protocol and propagated to the BswM. The system\ndesigner has to make sure that pre-conditions of respective states are met when setting\nan EcuM Mode by BswM actions.\nNote that neither the BSW nor SW-Cs will be able to rely on certain ECU modes or\nstates, although previous versions of the BSW have largely not relied on them..\nThis document only specifies the functionality that remains in the ECU Manager mod-\nule. For a complete picture of ECU State Management, refer to the specifications of\nthe other relevant modules, i.e., RTE and BSW Scheduler module [2] and BSW Mode\nManager module [3].\nRefer to the Guide to Mode Management [4] for some example use cases for ECU\nstates and the interaction between the involved BSW modules.\nThe ECU Manager module manages the state of wakeup sources in the same way as\nit has in the past. The APIs to set/clear/validate wakeup events remain the same - with\nthe notable difference that these APIs are Callbacks.\nIt was always intended that wakeup source handling take place not only during wakeup\nbut continuously, in parallel to all other EcuM activities. This functionality is now fully\ndecoupled from the rest of ECU management via mode requests.\n\n## Phases of the ECU Manager Module\n\nPrevious versions of the ECU Manager Module specification have differentiated be-\ntween ECU states and ECU modes.\nECU modes were longer-lasting periods of operational ECU activities that were visible\nto applications and provided orientation to them, i.e. starting up, shutting down, going\nto sleep and waking up.\nThe ECU Manager states were generally continuous sequences of ECU Manager Mod-\nule operations terminated by waiting until external conditions were fulfilled. Startup1,\nfor example, contained all BSW initialization before the OS was started and terminated\nwhen the OS returned control to the ECU Manager module.\nFor the current Flexible ECU Manager there existStates, Modes and Phases which\nare defined in Definitions and Acronyms.\n28 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nHere the ECU state machine is implemented as general modes under the control of\nthe BSW Mode Manager module. This creates a terminology problem as the old ECU\nStates now becomeModes that are visible through the RTE_Mode port interface and\nthe old ECUModes become Phases.\nBecause Modes as defined by the VFB and used in the RTE are only available in the\nUP phase (where the ECU Manager is passive) the change of terminology fromModes\nto Phases got necessary.\nFigure 7.1 shows an overview over the phases of the Flexible ECU Manager module.\nThe STARTUP phase lasts until the mode management facilities are running. Basically\nthe STARTUP phase consists of the minimal activities needed to start mode manage-\nment: initializing low-level drivers, starting the OS and initializing the BSW Scheduler\nand the BSW Mode Manager modules. Similarly the SHUTDOWN phase is the reverse\nof the STARTUP phase is where mode management is de-initialized.\nThe UP phase consists of all states that are not highlighted. During that phase, the\nECU goes fromState to State and fromMode to Mode, as dictated by the Integrator-\ndefined state machine.\nThe UP phase contains default Modes in case ECU Mode Handling is used. The tran-\nsition between these Modes is done by cooperation between the ECU State Manager\nmodule and the BSW Mode Manager module.\nNote that the UP phase contains some former sleep states. The mode management\nfacilities do not operate from the point where the OS Scheduler has been locked to pre-\nvent other tasks from running in sleep to the point where the MCU mode that puts the\nECU to sleep has been exited. The ECU Manager module provides wakeup handling\nsupport at this time.\n29 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nSHUTDOWN\nSTARTUP\nStartPreOs\nStartPostOs\nUP\nOffPreOs\nOffPostOs\nOFF\nSLEEP\nGoSleep\nPoll Halt\nWakeUpRestart\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \n \u000b \u0004 \f \u000e \u000f \u0010 \u0010\n\u0011\n\u0004 \u0004\n\u0012\n\u0002\n\u0011\n\u0010 \u0004\n\u0013\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \n \u000b \u0004 \f \u000e \u000f \u0010 \u0010\n\u0011\n\u0004\n\u0013\n\u000f \f \u0002\n\u0011\n\u0010 \u0004\n\u0013\n\u0014 \u0015 \u0016\n\u0004 \n \u0007 \u0010 \u0004 \u0004 \u0006\n\u0016 \u0017\n\u0004\n\u0001 \u0002 \u0003 \u0004 \t \u0006 \u0018 \u0002 \u0010 \u000f\n\u0013\n\u0002\n\u0016\n\u000f \b\n\u0012\n\u000f \f\n\f\n\u0016\n\u0002 \n\u0016\n\u0004\n\u0013\n\u000f\n\u0015 \u0012\n\u0004 \u0004\n\u0013\n\u0004\n\u0013\nOS started\nBswM, Os and SchM initialized\nReset if Shutdown\nTarget is RESET\nSchM and BswM de-\ninitialized; OS will be\nshutdown\nFigure 7.1: Phases of the ECU Manager\n30 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### STARTUP Phase\n\nThe purpose of the STARTUP phase is to initialize the basic software modules to the\npoint where Generic Mode Management facilities are operational. For more details\nabout the initialization see chapter 7.3.\n\n### UP Phase\n\nEssentially, the UP phase starts when the BSW Scheduler has started andBswM_-\nInit has been called. At that point, memory management is not initialized, there are\nno communication stacks, no SW-C support (RTE) and the SW-Cs have not started.\nProcessing starts in a certain mode (the next one configured after Startup) with cor-\nresponding runnables, i.e. the BSW MainFunctions, and continues as an arbitrary\ncombination of mode changes which cause the BswM to execute actions as well as\ntriggering and disabling corresponding runnables.\nFrom the ECU Manager Module perspective, the ECU is \"up\", however. The BSW\nMode Manager Module then starts mode arbitration and all further BSW initialization,\nstarting the RTE and (implicitly) starting SW-Cs becomes code executed in the BswM’s\naction lists or driven by mode-dependent scheduling, effectively under the control of\nthe integrator.\nInitializing the NvM and calling NvM_Readall therefore also becomes integration code.\nThis means that the integrator is responsible for triggering the initialization of Com,\nDEM and FIM at the end of NvM_ReadAll. The NvM will notify the BswM when NvM_\nReadAll has finished.\nNote that the RTE can be started after NvM and COM have been initialized. Note also\nthat the communication stack need not be fully initialized before COM can be initialized.\nThese changes initialize BSW modules as well as starting SW-Cs in arbitrary order\nuntil the ECU reaches full capacity and the changes continue to determine the ECU\ncapabilities thereafter as well.\nUltimately mode switches stop SW-Cs and de-initialize the BSW so that the Up phase\nends when the ECU reaches a state where it can be powered off.\nSo, as far as the ECU Manager module is concerned, the BSW and SW-Cs run until\nthey are ready for the ECU to be shut down or put to sleep.\nRefer to the Guide to Mode Management [4] for guidance on how to design mode-\ndriven ECU management and for configuring the BSW Mode Manager accordingly.\n31 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### SHUTDOWN Phase\n\n[SWS_EcuM_03022] ⌈The SHUTDOWN phase handles the controlled shutdown of\nbasic software modules and finally results in the selected shutdown target OFF or\nRESET.⌋(SRS_ModeMgm_09072)\n\n### SLEEP Phase\n\nThe ECU saves energy in the SLEEP phase. Typically, no code is executed but power\nis still supplied, and if configured accordingly, the ECU is wakeable in this state1. The\nECU Manager module provides a configurable set of (hardware) sleep modes which\ntypically are a trade off between power consumption and time to restart the ECU.\nThe ECU Manager module wakes the ECU up in response to intended or unintended\nwakeup events. Since unintended wakeup events should be ignored, the ECU Man-\nager module provides a protocol to validate wakeup events. The protocol specifies\na cooperative process between the driver which handles the wakeup source and the\nECU Manager (see section 7.6.4 ).\n\n### OFF Phase\n\nThe ECU enters the OFF state when it is powered down. The ECU may be wakeable\nin this state but only for wakeup sources with integrated power control. In any case the\nECU must be startable (e.g. by reset events).\n1Some ECU designs actually do require code execution to implement a SLEEP state (and the wakeup\ncapability). For these ECUs, the clock speed is typically dramatically reduced. These could be imple-\nmented with a small loop inside the SLEEP state.\n32 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n## Structural Description of the ECU Manager\n\n«module»\nEcuM\nBswM_Deinit\nBswM_EcuM_CurrentWakeup\nBswM_Init\nComM_EcuM_WakeUpIndication\nMcu_GetResetReason\nMcu_Init\nMcu_PerformReset\nMcu_SetMode\nSchM_Init\nSchM_Deinit\nWdgM_PerformReset\nGetResource\nReleaseResource\nShutdownOS\nStartOS\nAdc_Init\nCan_Init\nCanTrcv_Init\nDet_Init\nDet_ReportError\nEth_Init\nEthTrcv_Init\nFls_Init\nFr_Init\nFrTrcv_Init\nGetCoreID\nGpt_Init\nIcu_Init\nIoHwAb_Init\nLinTrcv_Init\nLin_Init\nPort_Init\nPwm_Init\nShutdownAllCores\nStartCore\nWdg_Init\nSpi_Init\nDisableAllInterrupts\nEnableAllInterrupts\nGetEvent\nSetEvent\nDem_Init\nDem_PreInit\nDem_Shutdown\nOcu_Init\nEcuM_SelectShutdownTarget\nEcuM_GetLastShutdownTarget\nEcuM_GetShutdownTarget\nCanSM_EcuMWakeUpValidation\nEcuM_flex_Types\nEcuM_SetState\nEthSwt_Init\nEcuM_Types_both\nEcuM_StartCheckWakeup\nEcuM_EndCheckWakeup\nComM_EcuM_PNCWakeUpIndication\nEcuM_AL_DriverInitBswM_<x>\nEcuM_GoDownHaltPoll EcuM_Types\n«mandatory» «optional»\n«mandatory»\n«mandatory»\n«optional»\n«mandatory»\n«realize»\n«mandatory»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«optional»\n«optional»\n«realize»\n«optional»\n«configurable»\n«realize»\n«mandatory»\n«mandatory»\n«optional»\n«mandatory»\n«realize»\n«optional»\n«optional»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«optional»\n«mandatory»\n«mandatory»\n«mandatory»\n«mandatory»\n«mandatory»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«optional»\n«mandatory»\n«optional»\n«configurable»\n«mandatory»\n«realize»\n«optional»\n«optional»\n«realize»\n«realize»\n«realize»\n«optional»\n«realize»\n«mandatory»\nFigure 7.2: ECU Manager Module Relationships\nFigure 7.2 illustrates the ECU Manager module’s relationship to the interfaces of other\nBSW modules. In most cases, the ECU Manager module is simply responsible for\n33 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\ninitialization2. There are however some modules that have a functional relationship\nwith the ECU Manager module, which is explained in the following paragraphs.\n\n### Standardized AUTOSAR Software Modules\n\nSome Basic Software driver modules are initialized, shut down and re-initialized upon\nwakeup by the ECU Manager module.\nThe OS is initialized and shut down by the ECU Manager.\nAfter the OS initialization, additional initialization steps are undertaken by the ECU\nManager module before passing control to the BswM. The BswM hands execution\ncontrol back to the ECU Manager module immediately before OS shutdown. Details\nare provided in the chapters 7.3 STARTUP and 7.4 SHUTDOWN .\n\n### Software Components\n\nSW-Components contain the AUTOSAR ECU’s application code.\nA SW-C interacts with the ECU Manager module using AUTOSAR ports.\n\n## STARTUP Phase\n\nSee Chapter 7.1.1 for an overview description of the STARTUP phase.\n2To be precise, \"initialization\" could also mean de-initialization.\n34 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nOs\nC Init Code «module»\nEcuM\nBSW Task (OS task\nor cyclic call)\nBoot Menu\nResetReset\nref\nStartPostOS Sequence\nref\nStartPreOS Sequence\nActivateTask()\nJump()\nEcuM_StartupTwo()\nEcuM_Init()\nStartOS()\nStartupHook()\nReset\nVector()\nSet up\nstack()\nFigure 7.3: STARTUP Phase\nFigure 7.3 shows the startup behavior of the ECU. When invoked throughEcuM_Init,\nthe ECU Manager module takes control of the ECU startup procedure. With the call\nto StartOS, the ECU Manager module temporarily relinquishes control. To regain\ncontrol, the Integrator has to implement an OS task that is automatically started and\ncalls EcuM_StartupTwo as its first action.\n\n### Activities before EcuM_Init\n\nThe ECU Manager module assumes that before EcuM_Init (see\n[SWS_EcuM_02811] ) is called a minimal initialization of the MCU has taken\nplace, so that a stack is set up and code can be executed, also that C initialization of\nvariables has been performed.\n\n### Activities in StartPreOS Sequence\n\n[SWS_EcuM_02411] ⌈Table StartPreOS Sequence shows the activities in StartPre\nOS Sequence and the order in which they shall be executed inEcuM_Init (see\n[SWS_EcuM_02811] ).⌋()\n35 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nStartPreOS Sequence\nInitialization Activity Comment Opt.\nCallout EcuM_AL_SetProgrammableIn-\nterrupts\nOn ECUs with programmable interrupt prior-\nities, these priorities must be set before the\nOS is started.\nyes\nCallout EcuM_AL_DriverInitZero\nInit block 0\nThis callout may only initialize BSW modules\nthat do not use post-build configuration pa-\nrameters. The callout may not only contain\ndriver initialization but also any kind of pre-\nOS, low level initialization code. See 7.3.5\nDriver Initialization\nyes\nCallout EcuM_DeterminePbConfigura-\ntion\nThis callout is expected to return a pointer to a\nfully initialized EcuM_ConfigType structure\ncontaining the post-build configuration data\nfor the ECU Manager module and all other\nBSW modules.\nno\nCheck consistency of configuration data\nIf check fails theEcuM_ErrorHook is called.\nSee 7.3.4 Checking Configuration Consis-\ntency for details on the consistency check.\nno\nCallout EcuM_AL_DriverInitOne\nInit block I\nThe callout may not only contain driver initial-\nization but any kind of pre-OS, low level ini-\ntialization code. See 7.3.5 Driver Initialization\nyes\nGet reset reason\nThe reset reason is derived from a call\nto Mcu_GetResetReason and the map-\nping defined via the EcuMWakeupSource\nconfiguration containers. See 8.4.1.2\nEcuM_SetWakeupEvent and 8.3.5.3\nEcuM_GetValidatedWakeupEvents (see\n[SWS_EcuM_02830] )\nno\nSelect default shutdown target See [SWS_EcuM_02181] no\nCallout EcuM_LoopDetection If Loop Detection is enabled, this callout is\ncalled on every startup. yes\nStart OS Start the AUTOSAR OS, see\n[SWS_EcuM_02603]\nno\nTable 7.1: StartPreOS Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration.\nSee section 10.1 Common Containers and configuration parameters for details.\n[SWS_EcuM_02623] ⌈The ECU Manager module shall remember the wakeup source\nresulting from the reset reason translation (see tableStartPreOS Sequence).⌋()\nRationale for [SWS_EcuM_02623]: The wakeup sources must be validated by the\nEcuM_MainFunction (see section 7.6.4 Activities in the WakeupValidation Se-\nquence).\n[SWS_EcuM_02684] ⌈When activated through the EcuM_Init (see\n[SWS_EcuM_02811] ) function, the ECU Manager module shall perform the ac-\ntions in the StartPreOS Sequence (see tableStartPreOS Sequence).⌋()\n36 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nOs\n«module»\nMcu\n«module»\nEcuM\nIntegration Code\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u0001\nopt Configuration data inconsistent\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u000b\n\f \n \u0003 \u000e \t \u000f \u0007 \u0007 \u0002 \u0010 \u0011 \u0010 \u0012 \u0012 \u0010 \u0004 \u0013 \u0012 \u0002 \u000e \u0014\nEcuM_LoopDetection()\nEcuM_AL_DriverInitOne()\nCheck consistency of configuration\ndata()\nEcuM_AL_DriverInitZero()\nEcuM_DeterminePbConfiguration(const\nEcuM_ConfigType*)\nStartOS(ECUM_DEFAULT_APP_MODE)\nMcu_GetResetReason()\nEcuM_ErrorHook(ECUM_E_CONFIGURATION_DATA_INCONSISTEN T)\nMcu_GetResetReason(Mcu_ResetType)\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nMap reset reason to wakeup\nsource()\nFigure 7.4: StartPreOS Sequence\n37 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nThe StartPreOS Sequence is intended to prepare the ECU to initialize the OS and\nshould be kept as short as possible. Drivers should be initialised in the UP phase\nwhen possible and the callouts should also be kept short. Interrupts should not be\nused during this sequence. If interrupts have to be used, only category I interrupts are\nallowed in the StartPreOS Sequence 13 .\nInitialization of drivers and hardware abstraction modules is not strictly defined by the\nECU Manager. Two calloutsEcuM_AL_DriverInitZero (see [SWS_EcuM_02905]\n) andEcuM_AL_DriverInitOne (see [SWS_EcuM_02907] ) are provided to define\nthe init blocks 0 and I. These blocks contain the initialization activities associated with\nthe StartPreOS sequence.\nMCU_Init does not provide complete MCU initialization. Additionally, hardware depen-\ndent steps have to be executed and must be defined at system design time. These\nsteps are supposed to be taken within theEcuM_AL_DriverInitZero (see EcuM_-\nAL_DriverInitZero, [SWS_EcuM_02905] ) or EcuM_AL_DriverInitOne call-\nouts (see EcuM_AL_DriverInitOne, [SWS_EcuM_02907] ). Details can be found\nin the Specification of MCU Driver [10].\n[SWS_EcuM_02181] ⌈The ECU Manager module shall callEcuM_GetValidated-\nWakeupEvents with the configured default shutdown target (EcuMDefaultShut-\ndownTarget).⌋()\nSee section 7.7 Shutdown Targets.\n[SWS_EcuM_02603] ⌈The StartPreOS Sequence shall initialize all basic software\nmodules that are needed to start the OS.⌋()\n\n### Activities in the StartPostOS Sequence\n\nStartPostOS Sequence\nInitialization Activity Comment Opt.\nStart BSW Scheduler no\nInit BSW Mode Manager no\nInit BSW Scheduler Initialize the semaphores for critical sections used\nby BSW modules no\nStart Scheduler Timing Start periodical events for BSW/SWCs no\nTable 7.2: StartPostOS Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration.\nSee section 10.1 Common Containers and configuration parameters for details.\n[SWS_EcuM_02932] ⌈When activated through the EcuM_StartupTwo (see\n[SWS_EcuM_02838] ) function, the ECU Manager module shall perform the actions\nin StartPostOS Sequence (see table 7.2).⌋(SRS_ModeMgm_09113)\n3Category II interrupts require a running OS while category I interrupts do not. AUTOSAR OS re-\nquires each interrupt vector to be exclusively put into one category.\n38 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nSchM\n«module»\nEcuM\n«module»\nBswM\nSchM_Start():\nStd_ReturnType\nSchM_StartTiming(const SchM_ConfigType*)\nSchM_Init(const SchM_ConfigType*)\nBswM_Init(const BswM_ConfigType *)\nFigure 7.5: StartPostOS Sequence\n\n### Checking Configuration Consistency\n\n\n\n#### The Necessity for Checking Configuration Consistency in the ECU Man-\n\nager\nIn an AUTOSAR ECU several configuration parameters are set and put into the ECU\nat different times. Pre-compile parameters are set, inserted into the generated source\ncode and compiled into object code. When the source code has been compiled, link-\ntime parameters are set, compiled, and linked with the previously configured object\ncode into an image that is put into the ECU. Finally, post-build parameters are set,\ncompiled, linked, and put into the ECU at a different time. All these parameters must\nmatch to obtain a stable ECU.\n39 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nFigure 7.6: BSW Configuration Steps\nThe configuration tool can check the consistency of configuration time parameters it-\nself. The compiler may detect parameter errors at compilation time and the linker may\nfind additional errors at link time. Unfortunately, finding configuration errors in post-\nbuild parameters is very difficult. This can only be achieved by checking that\n•the pre-compile and link-time parameter settings used when compiling the code\nare exactly the same as\n•the pre-compile and link-time parameter settings used when configuring and com-\npiling the post-build parameters.\nThis can only be done at run-time.\nExplanation for [SWS_EcuM_02796]: The ECU Manager module checks the consis-\ntency once before initializing the first BSW module to avoid multiple checks scattered\nover the different BSW modules.\nThis also implies that:\n[SWS_EcuM_02796] ⌈The ECU Manager module shall not only check the consistency\nof its own parameters but of all post-build configurable BSW modules before initializing\nthe first BSW module.⌋()\nThe ECU Manager Configuration Tool must compute a hash value over all pre-compile\nand link-time configuration parameters of all BSW modules and store the value in the\nlink-time ECUM_CONFIGCONSISTENCY_HASH (see EcuMConfigConsistencyHash)\nconfiguration parameter. The hash value is necessary for two reasons. First, the pre-\ncompile and link-time parameters are not accessible at run-time. Second, the check\n40 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nmust be very efficient at run-time. Comparing hundreds of parameters would cause an\nunacceptable delay in the ECU startup process.\nThe ECU Manager module Configuration Tool must in turn put the computedECUM_\nCONFIGCONSISTENCY_HASH value into the field in theEcuM_ConfigType structure\nwhich contains the root of all post-build configuration parameters.\n[SWS_EcuM_02798] ⌈The ECU Manager module shall check inEcuM_Init (see\n[SWS_EcuM_02811] ) that the field in the structure is equal to the value ofECUM_\nCONFIGCONSISTENCY_HASH .⌋()\nBy computing hash values at configuration time and comparing them at run-time the\nEcuM code can be very efficient and is furthermore independent of a particular hash\ncomputation algorithm. This allows the use of complex hash computation algorithms,\ne.g. cryptographically strong hash functions.\nNote that the same hash algorithm can be used to produce the value for the post-build\nconfiguration identifier in theEcuM_ConfigType structure. Then the hash algorithm\nis applied to the post-build parameters instead of the pre-compile and link-time param-\neters.\n[SWS_EcuM_02799] ⌈The hash computation algorithm used to compute a hash value\nover all pre-compile and link-time configuration parameters of all BSW modules shall\nalways produce the same hash value for the same set of configuration data regardless\nof the order of configuration parameters in the XML files.⌋()\n\n#### Example Hash Computation Algorithm\n\nNote: This chapter is not normative. It describes one possible way to compute hash\nvalues.\nA simple CRC over the values of configuration parameters will not serve as a good\nhash algorithm. It only detects global changes, e.g. one parameter has changed from\n1 to 2. But if another parameter changed from 2 to 1, the CRC might stay the same.\nAdditionally, not only the values of the configuration parameters but also their names\nmust be taken into account in the hash algorithm. One possibility is to build a text\nfile that contains the names of the configuration parameters and containers, separate\nthem from the values using a delimiter, e.g. a colon, and putting each parameter as a\nline into a text file.\nIf there are multiple containers of the same type, each container name can be ap-\npended with a number, e.g. \"_0\", \"_1\" and so on.\nTo make the hash value independent of the order in which the parameters are written\ninto the text file, the lines in the file must now be sorted lexicographically.\n41 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nFinally, a cryptographically strong hash function, e.g. MD5, can be run on the text file\nto produce the hash value. These hash functions produce completely different hash\nvalues for slightly changed input files.\n\n### Driver Initialization\n\nA driver’s location in the initialization process depends strongly on its implementation\nand the target hardware design.\nDrivers can be initialized by the ECU Manager module in Init Block 0 or Init Block 1 of\nthe STARTUP phase or re-initialized in theEcuM_AL_DriverRestart callout of the\nWakeupRestart Sequence. Drivers can also be initialized or re-initialized by the BswM\nduring the UP phase.\nThis chapter applies to those AUTOSAR Basic Software drivers, other than SchM and\nBswM, whose initialization and re-initialization is handled by the ECU Manager module\nand not the BswM.\n[SWS_EcuM_02559] ⌈The configuration of the ECU Manager module shall spec-\nify the order of initialization calls inside init block 0 and init block 1. (seeEcuM-\nDriverInitListZero and EcuMDriverInitListOne ).⌋(SRS_BSW_00416,\nSRS_ModeMgm_09234)\n[SWS_EcuM_02730] ⌈The ECU Manager module shall call each driver’s init function\nwith the parameters derived from the driver’sEcuMModuleService configuration con-\ntainer.⌋(SRS_ModeMgm_09234)\n[SWS_EcuM_02947] ⌈For re-initialization during WakeupRestart, the integrator shall\nintegrate a restart block into the integration code forEcuM_AL_DriverRestart (see\n[SWS_EcuM_02923] ) using the EcuMDriverRestartList.⌋(SRS_ModeMgm_-\n09234)\n[SWS_EcuM_02562] ⌈EcuMDriverRestartList may contain drivers that serve as\nwakeup sources. EcuM_AL_DriverRestart shall re-arm the trigger mechanism of\nthese drivers’ ’wakeup detected’ callback.⌋()\nSee Section 7.5.5 Activities in the WakeupRestart Sequence.\n[SWS_EcuM_02561] ⌈The ECU Manager module shall initialize the drivers in Ecu\nMDriverRestartList in the same order as in the combined list of init block 0 and init\nblock 1.⌋()\nHint for [SWS_EcuM_02561]:EcuMDriverRestartList will typically only contain a\nsubset of the combined list of init block 0 and init block 1 drivers.\nTable 7.3 shows one possible (and recommended) sequence of activities for the Init\nBlocks 0 and I. Depending on hardware and software configuration, BSW modules\nmay be added or left out and other sequences may also be possible.\n42 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nRecommended Init Block\nInitialization Activity Comment\nInit Block 04\nDefault Error Tracer\nThis should always be the first module to be initial-\nized, so that other modules can report development\nerrors.\nDiagnostic Event Manager Pre-Initialization\nAny drivers needed to access\npost-build configuration data\nThese drivers shall not depend on the post-build\nconfiguration or on OS features.\nInit Block I5\nMCU Driver\nPort Driver\nGeneral Purpose Timer\nWatchdog Driver Internal watchdogs only, external ones may need\nSPI\nWatchdog Manager\nADC Driver\nICU Driver\nPWM Driver\nOCU Driver\nTable 7.3: Driver Initialization Details, Sample Configuration\n\n### BSW Initialization\n\nThe remaining BSW modules are initialized by the BSW Mode Manager, using a config-\nured function of the ECU Manager (EcuMDriverInitCalloutName ECUC_EcuM_00227)\ncreated from the configured list of init functions (EcuMDriverInitListBswM ).\n[SWS_EcuM_04142] ⌈The configuration of the ECU Manager module shall specify the\norder of initialization calls inside the BSW initialization (seeEcuMDriverInitListB-\nswM ).⌋()\n\n## SHUTDOWN Phase\n\nRefer to Section 7.1.3 SHUTDOWN Phase for an overview of the SHUTDOWN phase.\nEcuM_GoDownHaltPoll with shutdown target RESET or OFF initiates the SHUT -\nDOWN Phase.\n[SWS_EcuM_02756] ⌈When a wakeup event occurs during the shutdown phase, the\nECU Manager module shall complete the shutdown and restart immediately there-\nafter.⌋()\n4Drivers in Init Block 0 are listed in the EcuMDriverInitListZero configuration container.\n5Drivers in Init Block I are listed in the EcuMDriverInitListOne configuration container.\n43 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nOs\n«module»\nEcuM\nIntegration Code«module»\nBswM\nref\nOffPreOS Sequence\nref\nOffPostOS Sequence\nEcuM_Shutdown()\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nShutdownHook()\nEcuM_GoDownHaltPoll\n(Std_ReturnType, EcuM_UserType)\nShutdownOS()\nFigure 7.7: SHUTDOWN Phase\n\n### Activities in the OffPreOS Sequence\n\n[SWS_EcuM_03021] ⌈See 7.4⌋(SRS_ModeMgm_09127)\nOffPreOS Sequence\nShutdown Activity Comment Opt.\nDe-init BSW Mode Manager no\nDe-init BSW Scheduler no\nCheck for pending wakeup events Purpose is to detect wakeup events\nthat occurred during shutdown no\nSet RESET as shutdown target, if\nwakeup events are pending (default\nreset mode of EcuMDefaultReset-\nModeRef will be used)\nThis action shall only be carried out\nwhen pending wakeup events were de-\ntected to allow an immediate startup\nno\nShutdownOS Last operation in this OS task no\nTable 7.4: OffPreOs Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration. It\nshall be the system designers choice if a module is compiled in or not for an ECU de-\nsign. See chapter 10.1 Common Containers and configuration parameters for details.\n[SWS_EcuM_02952] ⌈As its last activity, the ECU Manager module shall call the Shut-\ndownOS function.⌋(SRS_ModeMgm_09104)\nThe OS calls the shutdown hook at the end of its shutdown.\n44 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_02953] ⌈The shutdown hook shall call EcuM_Shutdown (see\n[SWS_EcuM_02812] ) to terminate the shutdown process. EcuM_Shutdown(see\n[SWS_EcuM_02812] ) shall not return but switch off the ECU or issue a reset.⌋(SRS_-\nModeMgm_09104)\n«module»\nEcuM\n«module»\nOs\n«module»\nSchM\n«module»\nBswM\nIntegration Code\nopt Pending wakeup events?\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nShutdownOS()\nEcuM_OnGoOffOne()\nBswM_Deinit()\nSchM_Deinit()\nFigure 7.8: OffPreOS Sequence\n\n### Activities in the OffPostOS Sequence\n\nThe OffPostOS sequence implements the final steps to reach the shutdown target after\nthe OS has been shut down.EcuM_Shutdown (see [SWS_EcuM_02812] ) initiates the\nsequence.\n45 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nThe shutdown target can be either ECUM_SHUTDOWN_TARGET_RESET or ECUM_\nSHUTDOWN_TARGET_OFF , whereby the specific reset modality is determined by the\nreset mode. See section 7.7 Shutdown Targets for details.\nOffPostOS Sequence\nShutdown Activity Comment Opt.\nCallout EcuM_OnGoOffTwo\nCallout EcuM_AL_Reset or Callout\nEcuM_AL_SwitchOff\nDepends on the selected shutdown tar-\nget (RESET or OFF)\nno\nTable 7.5: OffPostOs Sequence\nNote to columnOpt. : Optional activities can be switched on or off by configuration. It\nshall be the system designers choice if a module is compiled in or not for an ECU de-\nsign. See chapter 10.1 Common Containers and configuration parameters for details.\nIntegration Code«module»\nEcuM\nalt Shutdown Target\n[Reset]\n[Off]\nEcuM_AL_SwitchOff()\nEcuM_OnGoOffTwo()\nEcuM_AL_Reset(EcuM_ResetType)\nFigure 7.9: OffPostOS Sequence\n[SWS_EcuM_04074] ⌈When the shutdown target is RESET, the ECU Manager module\nshall call theEcuM_AL_Reset callout.⌋()\n46 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nSee section 8.5.3.4EcuM_AL_Reset ([SWS_EcuM_04065] ) for details.\n[SWS_EcuM_04075] ⌈When the shutdown target is OFF , the ECU Manager module\nshall call theEcuM_AL_SwitchOff callout.⌋()\nSee section 8.5.3.3EcuM_AL_SwitchOff ([SWS_EcuM_02920] ) for details.\n\n## SLEEP Phase\n\nRefer to Section 7.1.4 SLEEP Phase for an overview of the SLEEP phase.EcuM_-\nGoDownHaltPoll with shutdown target SLEEP initiate the SLEEP phase.\nEcuM_GoDownHaltPoll with shutdown target SLEEP initiate two control streams,\ndepending on the sleep mode selected (EcuMSleepModeSuspend parameter), that\ndiffer structurally in the mechanisms used to realize sleep. They share the sequences\nfor preparing for and recovering from sleep, however.\n47 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n«module»\nBswM\nref\nGoSleep Sequence\nalt \n[EcuM_GoDownHaltPoll called]\n[EcuM_GoDownHaltPoll called]\nref\nHalt Sequence\nref\nPolling Sequence\nref\nWakeupRestart Sequence\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nEcuM_GoDownHaltPoll\n(Std_ReturnType, EcuM_UserType)\nFigure 7.10: SLEEP Phase\nAnother module, presumably the BswM, although it could be an SW-C as well, must\nensure that an appropriate ECUM_STATE_SLEEP shutdown target has been selected\nbefore callingEcuM_GoDownHaltPoll.\n48 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Activities in the GoSleep Sequence\n\nIn the GoSleep sequence the ECU Manager module configures hardware for the up-\ncoming sleep phase and sets the ECU up for the next wakeup event.\n[SWS_EcuM_02389] ⌈To set the wakeup sources up for the next sleep mode, the\nECU Manager module shall execute theEcuM_EnableWakeupSources callout (see\n[SWS_EcuM_02546] ) for each wakeup source that is configured inEcuMWakeup-\nSourceMask for the target sleep mode.⌋(SRS_ModeMgm_09100)\n[SWS_EcuM_02951] ⌈In contrast to the SHUTDOWN phase, the ECU Manager mod-\nule shall not shut down the OS when entering the SLEEP phase. The sleep mode, i.e.\ncombination of the EcuM SLEEP phase and the Mcu Mode, shall be transparent to the\nOS.⌋()\n«module»\nEcuM\n«module»\nOs\nIntegration Code «module»\n:BswM\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_NONE )\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nFigure 7.11: GoSleep Sequence\n[SWS_EcuM_03010] ⌈When operating on a multicore ECU ECUM shall reserve a ded-\nicated resource (RES_AUTOSAR_ECUM) for each core, which is allocated during Go\nSleep.⌋()\n\n### Activities in the Halt Sequence\n\n[SWS_EcuM_02960] ⌈The ECU Manager module shall execute the Halt Sequence in\nsleep modes that halt the microcontroller. In these sleep modes the ECU Manager\nmodule does not execute any code.⌋()\n[SWS_EcuM_02863] ⌈The ECU Manager module shall invoke theEcuM_Generat-\neRamHash (see [SWS_EcuM_02919] ) callout before halting the microcontroller the\n49 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nEcuM_CheckRamHash (see [SWS_EcuM_02921] ) callout after the processor returns\nfrom halt.\nIn case of applied multi core and existence of \"slave\" EcuM(s) this check should be\nexecuted on the \"master\" EcuM only. The \"master\" EcuM generates the hash out of all\ndata that lie within its reach. Private data of \"slave\" EcuMs are out of scope.⌋()\nRationale for [SWS_EcuM_02863] : Ram memory may become corrupted when an\nECU is held in sleep mode for a long time. The RAM memory’s integrity should there-\nfore be checked to prevent unforeseen behavior. The system designer may choose an\nadequate checksum algorithm to perform the check.\n50 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \b \t \n \u000b \n \f \f \n \n \u000e \f \t \u0004 \u000f\nIntegration Code\n\u0010 \u0011 \u0012 \u0013 \n \n \u000e \f \t \u0004 \n \u0014 \u0015 \u0007 \b \n \u0016 \u0010 \u0017 \n \u0006 \u000e \n \u0003 \u0014 \t\n\u0006 \u0014 \t \n \u0003 \t \u000e \n \u0004\n\u0018\n\u0003 \n \u0002 \n \u0002 \n \u0003 \t \n \n \f \f \u000e\n\u0019\n\n \u0007\n\u001a\n\u0014 \u000b \n\u001b\n«module»\n:BswM\n«Peripheral»\nWakeup Source\n«module»\nMcu\n«module»\nEcuM\n«module»\nWakeup Source\n«module»\nOs\nHALT\nopt RAM check failed\nalt Validation Needed\n[Yes]\n[No]\nalt AlarmClock Service Present\n[EcuM_AlarmClock only pending event AND Alarm not expired]\nopt Wakeup handling\n[Wakeup detected]\n[No Wakeup detected]\nBswM_EcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_VALIDATED)\nMcu_SetMode(Mcu_ModeType)\nMcu_SetMode()\nEcuM_StartCheckWakeup()\nBswM_EcuM_CurrentWakeup(sources.\nECUM_WKSTATUS_PENDING)\n<Module>_CheckWakeup()\nActivate\nPLL()\nEcuM_CheckRamHash(uint8)\nMcu_SetMode(Mcu_ModeType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nEcuM_GenerateRamHash()\nEcuM_ErrorHook(uint16)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_GenerateRamHash()\nReturn from\ninterrupt()\nInterrupt()\nDisableAllInterrupts()\nFigure 7.12: Halt Sequence\n51 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_02961] ⌈The ECU Manager module shall invoke theEcuM_Generat-\neRamHash (see [SWS_EcuM_02919] ) where the system designer can place a RAM\nintegrity check.⌋()\n\n### Activities in the Poll Sequence\n\n[SWS_EcuM_02962] ⌈The ECU Manager module shall execute the Poll Sequence in\nsleep modes that reduce the power consumption of the microcontroller but still execute\ncode.⌋()\n[SWS_EcuM_03020] ⌈In the Poll sequence the EcuM shall call the calloutsEcuM_-\nSleepActivity and EcuM_CheckWakeup() in a blocking loop until a pending/vali-\ndated wakeup event is reported.⌋()\n52 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n«module»\n:BswM\nIntegration Code «module»\nMcu\n«module»\nWakeup Source\n«module»\nOs\nloop WHILE no pending/validated wakeup events\nloop FOR all wakeup sources that need polling\nopt Wakeup handling\n[Wakeup detected]\n[No wakeup detected]\nalt Validation Needed\n[Yes]\n[No]\n\u0001 \u0002 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0007 \b \n \u0005 \u0006 \u000b \u0003 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0004 \u0005 \f \u0005 \u0005 \n \u000e \u000f \u0010 \u0003 \b \u0011 \u0012 \u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0017 \u0011 \u0013 \u0018 \u0003 \u0015 \u0011 \u0019 \u0013 \u0011 \u001a \u0011 \u0006 \u0004 \u0001 \u001b \u001c\n\u001d\n\u0015\n\u001e \u001f  \n\u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0005 \u0006 \b\n!\n\n \u0011 \u0006 \u0002 \u0003 \u0006\n\"\n\u0011 \u0018 \u0011 \u0006 \u0004 \u0001 \u001b \u001c \u0001 \b \u0007 \u0013 \u0014 \u0006 \u0005 \u0004 \u0011\n#\n\n \u0003 \u0013 \u0011 \u0002\n$\nEcuM_StartCheckWakeup()\nMcu_SetMode(Mcu_ModeType)\nEcuM_SleepActivity()\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\n<Module>_CheckWakeup()\nEnableAllInterrupts()\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources.\nECUM_WKSTATUS_VALIDATED)\nBswM_EcuM_CurrentWakeup(sources.\nECUM_WKSTATUS_PENDING)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_EndCheckWakeup()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nFigure 7.13: Poll Sequence\n53 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Leaving Halt or Poll\n\n[SWS_EcuM_02963] ⌈If a wakeup event (e.g. toggling a wakeup line, communication\non a CAN bus etc.) occurs while the ECU is in Halt or Poll, then the ECU Manager\nmodule shall regain control and exit the SLEEP phase by executing the WakeupRestart\nsequence.\nAn ISR may be invoked to handle the wakeup event, but this depends on the hardware\nand the driver implementation.⌋()\nSee section 7.5.5 Activities in the WakeupRestart Sequence.\n[SWS_EcuM_04001] ⌈If irregular events (a hardware reset or a power cycle) occur\nwhile the ECU is in Halt or Poll, the ECU Manager module shall restart the ECU in the\nSTARTUP phase.⌋()\n\n### Activities in the WakeupRestart Sequence\n\nWakeupRestart6\nWakeup Activity Comment Opt.\nRestore MCU normal mode\nSelected MCU mode is configured in\nthe configuration parameter EcuMNor-\nmalMcuModeRef\nGet the pending wakeup sources\nCallout EcuM_DisableWakeup-\nSources\nDisable currently pending wakeup\nsource but leave the others armed so\nthat later wakeups are possible.\nCallout EcuM_AL_DriverRestart Initialize drivers that need restarting\nUnlock Scheduler From this point on, all other tasks may\nrun again.\nTable 7.6: Wakeup Restart activities\nThe ECU Manager module invokes the EcuM_AL_DriverRestart (see\n[SWS_EcuM_02923] ) callout which is intended for re-initializing drivers. Among\nothers, drivers with wakeup sources typically require re-initialization. For more details\non driver initialization refer to section 7.3.5 Driver Initialization.\nDuring re-initialization, a driver must check if one of its assigned wakeup sources was\nthe reason for the previous wakeup. If this test is true, the driver must invoke its ’wakeup\ndetected’ callback (see the Specification of CAN Transceiver Driver [11] for example),\nwhich in turn must call theEcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) func-\ntion.\nThe driver implementation should only invoke the wakeup callback once. Thereafter it\nshould not invoke the wakeup callback again until it has been re-armed by an explicit\nfunction call. The driver must thus be re-armed to fire the callback again.\n54 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_02539] ⌈If the ECU Manager module has a list of wakeup source can-\ndidates when the WakeupRestart Sequence has finished, the ECU Manager module\nshall validate these wakeup source candidates inEcuM_MainFunction.⌋()\nSee section 7.6.4 Activities in the WakeupValidation Sequence.\n[SWS_EcuM_04066] ⌈\n«module»\nMcu\n«module»\nOs\n«module»\nEcuM\nIntegration Code\nEcuM_AL_DriverRestart()\nDisableAllInterrupts()\nMcu_SetMode(Mcu_ModeType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nFigure 7.14: WakeupRestart Sequence\n⌋\n()\n55 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n## UP Phase\n\nIn the UP Phase, theEcuM_MainFunction is executed regularly and it has three\nmajor functions:\n•To check if wakeup sources have woken up and to initiate wakeup validation, if\nnecessary (see 7.6.4 Activities in the WakeupValidation Sequence)\n•To update the Alarm Clock timer\n•Arbitrate RUN and POST_RUN requests and releases.\n\n### Alarm Clock Handling\n\nSee section 7.8.2 EcuM Clock Time in the UP Phase for implementation details.\n[SWS_EcuM_04002] ⌈When the Alarm Clock service is present (seeEcuMAlarm-\nClockPresent ) theEcuM_MainFunction shall update the Alarm Clock Timer⌋()\n\n### Wakeup Source State Handling\n\nWakeup source are not only handled during wakeup but continuously, in parallel to\nall other EcuM activities. This functionality runs in theEcuM_MainFunction fully\ndecoupled from the rest of ECU management via mode requests.\n[SWS_EcuM_04091] ⌈The wakeup sources can be in the following states:\nState Description\nNONE No wakeup event was detected\nor has been cleared.\nPENDING A wakeup event was detected\nbut not yet validated.\nVALIDATED A wakeup event was detected\nand succesfully validated.\nEXPIRED\nA wakeup event was detected\nbut validation failed.\nTable 7.7: Wakeup sources\n⌋(SRS_ModeMgm_09136)\nFigure 7.15 illustrates the relationship between the wakeup source states and the con-\nditions functions that evoke state changes. The two super-states Disabled and Valida-\ntion are only shown here for clarification and better understandability.\n56 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nECUM_WKSTATUS_NONE\nentry / BswM_EcuM_CurrentWakeup(sources, NONE)\nPower On / Initial\nECUM_WKSTATUS_PENDING\nentry / BswM_EcuM_CurrentWakeup(sources, PENDING)\nentry / EcuM_StartWakeupSources()\ndo / exec. wakeup validation seq.\nECUM_WKSTATUS_VALIDATED\nentry / BswM_EcuM_CurrentWakeup(sources, VALIDATED)\nentry / ComM_EcuM_WakeUpIndication()\nECUM_WKSTATUS_EXPIRED\nentry / BswM_EcuM_CurrentWakeup(sources, EXPIRED)\nentry / EcuM_StopWakeupSources()\nTimer Expired\nEcuM_ClearWakeupEvent(sources)\nEcuM_ValidateWakeupEvent()\nEcuM_SetWakeupEvent(sources)\n[With Validation]\nEcuM_SetWakeupEvent(sources)\n[No Validation]\nFigure 7.15: Wakeup Source States\n[SWS_EcuM_04003] ⌈When an ECU Manager action causes the state of a wakeup\nsource to change, the ECU Manager module shall issue a mode request to the BswM\nto change the wakeup source’s mode to the new the wakeup source state.⌋()\nFor the communication of these wakeup source states the typeEcuM_WakeupSta-\ntusType (see SWS_ECUM_04041) is used.\nWhen the ECU Manager module is in the UP phase, wakeup events do not usually\ntrigger state changes. They trigger the end of the Halt and Poll Sub-Phases, however.\nThe ECU Manager module then executes the WakeupRestart Sequence automatically\nand returns thereafter to the UP phase.\nIt is up to the integrator to configure rules in the BswM so that the ECU reacts correctly\nto the wakeup events, as the reaction depends fully on the current ECU (not ECU\nManagement) state.\nIf the wakeup source is valid, the BswM returns the ECU to its RUN state. If all wakeup\nevents have gone back to NONE or EXPIRED, the BswM prepares the BSW for SLEEP\nor OFF again and invokesEcuM_GoDownHaltPoll.\n57 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nSummarizing: every pending event is validated independently (if configured) and the\nEcuM publishes the result as a mode request to the BswM, which in turn can trigger\nstate changes in the EcuM.\n\n### Internal Representation of Wakeup States\n\nThe EcuM manager module offers the following interfaces to ascertain the state of\nthose wakeup sources:\n•EcuM_GetPendingWakeupEvents\n•EcuM_GetValidatedWakeupEvents\n•EcuM_GetExpiredWakeupEvents\nand manipulates the state of the wakeup sources through the following interfaces\n•EcuM_ClearWakeupEvent\n•EcuM_SetWakeupEvent\n•EcuM_ValidateWakeupEvent\n•EcuM_CheckWakeup\n•EcuM_DisableWakeupSources\n•EcuM_EnableWakeupSources\n•EcuM_StartWakeupSources\n•EcuM_StopWakeupSources\nThe ECU Manager module can manage up to 32 wakeup sources. The state of\nthe wakeup sources is typically represented at the EcuM interfaces named above\nby means of an EcuM_WakeupSourceType bitmask where the individual wakeup\nsources correspond to a fixed bit position. There are 5 predefined bit positions and\nthe rest can be assigned by configuration. See section 8.2.3EcuM_WakeupSource-\nType for details.\nOn the one hand, the ECU Manager module manages the modes of each wakeup\nsource. On the other hand, the ECU Manager module presupposes that there are \"in-\nternal variables\" (i.e.EcuM_WakeupSourceType instances) that track which wakeup\nsources are in a particular state (especially NONE (i.e. cleared), PENDING, VALI-\nDATED and EXPIRED). The ECU Manager module uses these \"internal variables\" in\nthe respective interface definitions to define the semantics of the interface.\nWhether these \"internal variables\" are indeed implemented is therefore of secondary\nimportance. They are simply used to explain the semantics of the interfaces.\n58 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Activities in the WakeupValidation Sequence\n\nSince wakeup events can be generated unintentionally (e.g. EVM spike on CAN line),\nit is necessary to validate wakeups before the ECU resumes full operation.\nThe validation mechanism is the same for all wakeup sources. When a wakeup event\noccurs, the ECU is woken up from its SLEEP state and execution resumes within the\nMCU_SetMode service of the MCU driver7 . When the WakeupRestart Sequence has\nfinished, the ECU Manager module will have a list of pending wakeup events to be\nvalidated (see [SWS_EcuM_02539] ). The ECU Manager module then releases the\nBSW Scheduler and all BSW MainFunctions; most notably in this case, the EcuM Main\nFunction can resume processing.\nImplementation hint: Since SchM will be running at the end of the StartPostOS and\nWakeupRestart sequences, there is the possibility that theEcuM_MainFunction will\ninitiate validation for a source whose stack has not yet been initialized. The integrator\nshould configure appropriate modes which indicate that the stack is not available and\ndisable theEcuM_MainFunction accordingly (see [2] ).\n7Actually, the first code to be executed may be an ISR, e.g. a wakeup ISR. However, this is specific\nto hardware and/or driver implementation.\n59 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n«module»\nComM\n«module»\nWakeup Source\nIntegration Code «module»\nBswM\n«module»\nCanSM\nopt No wakeup event was validated\nopt Wakeup validated\nloop WHILE no wakeup event has been validated AND timeout not expired\nBswM_EcuM_CurrentWakeup(Source,\nECUM_WKSTATUS_EXPIRED)\nEcuM_CheckValidation(EcuM_WakeupSourceType)\nCanSM_StartWakeupSource(Std_ReturnType,\nNetworkHandleType)\nComM_EcuM_PNCWakeUpIndication(PNCHandleType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nCanSM_StopWakeupSource(Std_ReturnType,\nNetworkHandleType)\nStart validation\ntimeout()\nEcuM_StopWakeupSources(EcuM_WakeupSourceType)\nBswM_EcuM_CurrentWakeup(Source, ECUM_WKSTATUS_VALID ATED)\nEcuM_ValidateWakeupEvent(EcuM_WakeupSourceType)\n<Module>_CheckValidation()\nEcuM_StartWakeupSources(EcuM_WakeupSourceType)\nComM_EcuM_WakeUpIndication(NetworkHandleType)\nFigure 7.16: The WakeupValidation Sequence\n[SWS_EcuM_02566] ⌈The ECU Manager module shall only invoke wakeup validation\non those wakeup sources where it is required by configuration. If the validation protocol\n60 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nis not configured (seeEcuMValidationTimeout ), then a call toEcuM_SetWakeu-\npEvent shall also imply a call toEcuM_ValidateWakeupEvent .⌋()\n[SWS_EcuM_02565] ⌈The ECU Manager module shall start a validation timeout for\neach pending wakeup event that should be validated. The timeout shall be event-\nspecific (seeEcuMValidationTimeout ).⌋()\nImplementation hint for [SWS_EcuM_02565]: It is sufficient for an implementation to\nprovide only one timer, which is prolonged to the largest timeout when new wakeup\nevents are reported.\n[SWS_EcuM_04081] ⌈When the validation timeout expires for a pending wakeup\nevent, theEcuM_MainFunction sets (OR-operation) set the bit in the internal expired\nwakeup events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_04082] ⌈When the validation timeout expires for a pending wakeup\nevent, the EcuM_MainFunction shall invoke BswM_EcuM_Current_Wakeup with\nan EcuM_WakeupSourceType bitmask parameter with the bit corresponding to the\nwakeup event set and state value parameter set to ECUM_WKSTATUS_EXPIRED.⌋()\nThe BswM will be configured to monitor the wakeup validation through mode switch\nrequests coming from the EcuM as the wakeup sources are validated or the timers ex-\npire. If the last validation timeout (see [SWS_EcuM_02565] ) expires without validation\nthen the BswM shall consider wakeup validation to have failed. If at least one of the\npending events is validated then the entire validation shall have passed.\nPending events are validated with a call of EcuM_ValidateWakeupEvent (see\n[SWS_EcuM_02829] ). This call must be placed in the driver or the consuming stack\non top of the driver (e.g. the handler). The best place to put this depends on hardware\nand software design. See also section 7.6.4.4 Requirements for Drivers with Wakeup\nSources .\n\n#### Wakeup of Communication Channels\n\nIf a wakeup occurs on a communication channel, the corresponding bus transceiver\ndriver must notify the ECU Manager module by invokingEcuM_SetWakeupEvent (see\n[SWS_EcuM_02826] ) function. Requirements for this notification are described in\nsection 5.2 Peripherals with Wakeup Capability.\n[SWS_EcuM_02479] ⌈The ECU Manager module shall execute the Wakeup Valida-\ntion Protocol upon theEcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) function\ncall according toInteraction of Wakeup Sources and the ECU Managerlater in this\nchapter.⌋()\nSee also 7.6.4.2 Interaction of Wakeup Sources and the ECU Manager.\n61 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### Interaction of Wakeup Sources and the ECU Manager\n\nThe ECU Manager module shall treat all wakeup sources in the same way. The proce-\ndure shall be as follows:\nWhen a wakeup event occurs, the corresponding driver shall notify the ECU Manager\nmodule of the wakeup. The most likely modalities for this notification are:\n•After exiting the Halt or Poll sequences. In this scenario, the ECU Manager\nmodule invokes EcuM_AL_DriverRestart (see [SWS_EcuM_02923] ) to re-\ninitialize of the relevant drivers, which in turn get a chance to scan their hardware\ne.g. for pending wakeup interrupts.\n•If the wakeup source is actually in sleep mode, the driver must scan au-\ntonomously for wakeup events; either by polling or by waiting for an interrupt.\n[SWS_EcuM_02975] ⌈If a wakeup event requires validation then the ECU Manager\nmodule shall invoke the validation protocol⌋()\n[SWS_EcuM_02976] ⌈If a wakeup event does not require validation, the ECU Man-\nager module shall issue a mode switch request to set the event’s mode to ECUM_\nWKSTATUS_VALIDATED.⌋()\n[SWS_EcuM_02496] ⌈If the wakeup event is validated (either immediately or by the\nwakeup validation protocol), the ECU Manager module shall make the information that\nit is a source of the current ECU wakeup through theEcuM_GetValidatedWakeu-\npEvents (see [SWS_EcuM_02830] ) function.⌋()\n\n#### Wakeup Validation Timeout\n\n[SWS_EcuM_04004] ⌈The ECU Manager Module shall either provide a single wakeup\nvalidation timeout timer or one timer per wakeup source.⌋()\nThe following requirements apply:\n[SWS_EcuM_02709] ⌈The ECU Manager module shall start the wakeup validation\ntimeout timer whenEcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) is called.⌋()\n[SWS_EcuM_02710] ⌈EcuM_ValidateWakeupEvent shall stop the wakeup valida-\ntion timeout timer (see [SWS_EcuM_02829] ).⌋()\n[SWS_EcuM_02712] ⌈If EcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) is\ncalled subsequently for the same wakeup source, the ECU Manager module shall not\nrestart the wakeup validation timeout.⌋()\nIf only one timer is used, the following approach is proposed:\nIf EcuM_SetWakeupEvent (see [SWS_EcuM_02826] ) is called for a wakeup source\nthat did not yet fire during the same wakeup cycle then the ECU Manager module\nshould prolong the validation timeout of that wakeup source.\n62 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nWakeup timeouts are defined by configuration (seeEcuMValidationTimeout).\n\n#### Requirements for Drivers with Wakeup Sources\n\nThe driver must invoke EcuM_SetWakeupEvent (see [SWS_EcuM_02826] )\nonce when the wakeup event is detected and supply a EcuM_WakeupSource-\nType parameter identifying the source of the wakeup (see [SWS_EcuM_02165],\n[SWS_EcuM_02166] ) as specified in the configuration (seeEcuMWakeupSourceId\n).\n[SWS_EcuM_02572] ⌈The ECU Manager module shall detect wakeups that occurr\nprior to driver initialization, both from Halt/Poll or from OFF .⌋()\nThe driver must provide an API to configure the wakeup source for the SLEEP state, to\nenable or disable the wakeup source, and to put the related peripherals to sleep. This\nrequirement only applies if hardware provides these capabilities.\nThe driver should enable the callback invocation in its initialization function.\n\n### Requirements for Wakeup Validation\n\nIf the wakeup source requires validation, this may be done by any but only by one\nappropriate module of the basic software. This may be a driver, an interface, a handler,\nor a manager.\nValidation is done by calling the EcuM_ValidateWakeupEvent (see\n[SWS_EcuM_02829] ) function.\n[SWS_EcuM_02601] ⌈If the EcuM cannot determine the reset reason returned by the\nMcu driver, then the EcuM set a wakeup event for default wakeup source ECUM_\nWKSOURCE_RESET instead.⌋()\n\n### Wakeup Sources and Reset Reason\n\nThe ECU Manager module API only provides one type (EcuM_WakeupSourceType ,\nsee 8.2.3EcuM_WakeupSourceType ), which can describe all reasons why the ECU\nstarts or wakes up.\n[SWS_EcuM_02625] ⌈The ECU Manager module shall never invoke validation for the\nfollowing wakeup sources:\n•ECUM_WKSOURCE_POWER\n•ECUM_WKSOURCE_RESET\n•ECUM_WKSOURCE_INTERNAL_RESET\n63 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n•ECUM_WKSOURCE_INTERNAL_WDG\n•ECUM_WKSOURCE_EXTERNAL_WDG.\n⌋()\n\n### Wakeup Sources with Integrated Power Control\n\nSLEEP can be realized by a system chip which controls the MCU’s power supply.\nTypical examples are CAN transceivers with integrated power supplies which switch\npower off at application request and switch power on upon CAN activity.\nThe consequence is that SLEEP looks like OFF to the ECU Manager module on this\ntype of hardware. This distinction is rather philosophical and not of practical impor-\ntance.\nThe practical impact is that a passive wakeup on CAN looks like a power on reset to the\nECU. Hence, the ECU will continue with the STARTUP sequence after a wakeup event.\nWakeup validation is required nonetheless and the system designer must consider the\nfollowing topics:\n•The CAN transceiver is initialized during one of the driver initialization blocks\n(under BswM control by default). This is configured or generated code, i.e. code\nwhich is under control of the system designer.\n•The CAN transceiver driver API provides functions to find out if it was the CAN\ntransceiver which started the ECU due to a passive wakeup. It is the system de-\nsigner’s responsibility to check the CAN transceiver for wakeup reasons and pass\nthis information on to the ECU Manager module by using theEcuM_SetWake-\nupEvent (see [SWS_EcuM_02826] ) and EcuM_ClearWakeupEvents (see\n[SWS_EcuM_02828] ) functions.\nThese principles can be applied to all wakeup sources with integrated power control.\nThe CAN transceiver only serves as an example.\n\n## Shutdown Targets\n\n\"Shutdown Targets\" is a descriptive term for all states ECU where no code is executed.\nThey are called shutdown targets because they are the destination states where the\nstate machine will drive to when the UP phase is left. The following states are shutdown\ntargets:\n•Off8\n•Sleep\n8The OFF state requires the capability of the ECU to switch off itself. This is not granted for all\nhardware designs.\n64 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n•Reset\nNote that the time at which a shutdown target is or can be determined is not neces-\nsarily the start of the shutdown. Since the BswM now controls most ECU resources,\nit will determine the time at which the shutdown target should be set and will set it,\neither directly or indirectly. The BswM must therefore ensure that, for example, the\nshutdown target must be changed from its default to ECUM_STATE_SLEEP before\ncalling EcuM_GoDownHaltPoll.\nIn previous versions of the ECU Manager module, sleep targets were treated specially,\nas the sleep modes realized in the ECU depended on the capabilities of the ECU.\nThese sleep modes depend on hardware and differ typically in clock settings or other\nlow power features provided by the hardware. These different features are accessible\nthrough the MCU driver as so-called MCU modes (see [10] ). There are also vari-\nous modalities for performing a reset which are controlled, or triggered, by different\nmodules:\n•Mcu_PerformReset\n•WdgM_PerformReset\n•Toggle I/O Pin via DIO / SPI\nThe ECU Manager module offers a facility to manage these reset modalities by to\ntracking the time and cause of previous resets. The various reset modalities will be\ntreated as reset modes, using the same mode facitlities as sleep.\nRefer to section 8.3.4 Shutdown Management for the shutdown management facility’s\ninterface definitions.\n\n### Sleep\n\n[SWS_EcuM_02188] ⌈No wakeup event shall be missed in the SLEEP phase. The\nHalt or Poll Sequences shall not be entered if a wakeup event has occurred in the Go\nSleep sequence.⌋()\n[SWS_EcuM_02957] ⌈The ECU Manager module may define a configurable set of\nsleep modes (seeEcuMSleepMode ) where each mode itself is a shutdown target.⌋()\n[SWS_EcuM_02958] ⌈The ECU Manager module shall allow mapping the MCU sleep\nmodes to ECU sleep modes and hence allow them to be addressed as shutdown tar-\ngets.⌋()\n[SWS_EcuM_04092] ⌈The ShutdownTarget Sleep shall put the all cores into sleep.⌋()\n65 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Reset\n\n[SWS_EcuM_04005] ⌈The ECU Manager module shall define a configurable set of\nreset modes (seeEcuMResetMode and EcuM_ResetType ), where each mode itself\nis a shutdown target. The set will minimally contain targets for\n•Mcu_PerformReset\n•WdgM_PerformReset\n•Toggle I/O Pin via DIO / SPI\n⌋()\n[SWS_EcuM_04006] ⌈The ECU Manager module shall allow defining aliases for reset\ntargets (See EcuM180_Conf).⌋()\n[SWS_EcuM_04007] ⌈The ECU Manager module shall define a configurable set of\nreset causes (see EcuMShutdownCause and EcuM_ShutdownCauseType ). The\nset shall minimally contain targets for\n•ECU state machine entered a shutdown state\n•WdgM detected a failure\n•DCM requests shutdownI\nand the time of the reset.⌋()\n[SWS_EcuM_04008] ⌈The ECU Manager Module shall offer facilities to BSW modules\nand SW-Cs to\n•Record a shutdown cause\n•Get a set of recent shutdown causes\n⌋()\nSee also section 8.3.4 Shutdown Management.\n\n## Alarm Clock\n\nThe ECU Manager module provides an optional persistent clock service which remains\n\"active\" even during sleep. It thus guarantees that an ECU will be woken up at a\ncertain time in the future (assuming that the hardware does not fail) and provides clock\nservices for long-term activities (i.e. measured in hours to days, even years).\nGenerally, this service will be realized with timers in the ECU that can induce wakeups.\nIn some cases, external devices can also use a regular interrupt line to periodically\nwake the ECU up, however. Whatever the mechanism used, the service uses one\nwakeup source privately.\n66 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nThe ECU Manager module maintains a master alarm clock whose value determines\nthe time at which the ECU will be woken up. Moreover the ECU manager manages an\ninternal clock, the EcuM clock, which is used to compare with the master alarm.\nNote that the alarm wakeup mechanisms are only relevant to the SLEEP phase. SW-\nCs and BSW modules can set and retrieve alarm values during the UP phase (and only\nduring the UP phase), which will be respected during the SLEEP phase, however.\nCompared to other timing/wakeup mechanisms that could be implemented using gen-\neral ECU Manager module facilities, the Alarm Clock service will not initiate the\nWakeupRestart Sequence until the timer expires. When the ECU Module detects that\nits timer has caused a wakeup event, it increments its timer and returns immediately to\nsleep unless the clock time has exceeded the alarm time.\n[SWS_EcuM_04069] ⌈When the Alarm Clock service is present (seeEcuMAlarm-\nClockPresent ) the EcuM Manager module shall maintain an EcuM clock whose\ntime shall be the time in seconds since battery connect.⌋()\n[SWS_EcuM_04086] ⌈The EcuM clock shall track time in the UP and SLEEP phases.⌋\n()\n[SWS_EcuM_04087] ⌈Hardware permitting, the EcuM clock time shall not be reset by\nan ECU reset.⌋()\n[SWS_EcuM_04088] ⌈There shall be one and only one wakeup source assigned to\nthe EcuM Clock (seeEcuMAlarmWakeupSource ).⌋()\n\n### Alarm Clocks and Users\n\nSW-Cs and BSW modules can each maintain an alarm clock (user alarm clock).\nEach user alarm clock (seeEcuMAlarmClock ) is associated with anEcuMAlarm-\nClockUser which identifies the respective SW-C or BSW module.\n[SWS_EcuM_04070] ⌈Each EcuM User shall have at most one user alarm clock.⌋()\n[SWS_EcuM_04071] ⌈An EcuM User shall not be able to set the value of another\nuser’s alarm clock.⌋()\n[SWS_EcuM_04072] ⌈The ECU Manager module shall set always the master alarm\nclock value to the value of the earliest user alarm clock value.⌋()\nThis means as well that when an EcuM User issues an abort on its alarm clock and that\nuser alarm clock determines the current master alarm clock value, the ECU Manager\nmodule shall set the master alarm clock value to the next earliest user alarm clock\nvalue.\n[SWS_EcuM_04073] ⌈Only authorized EcuM Users can set the EcuM clock time (see\nEcuMSetClockAllowedUsers ).⌋()\n67 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nRationale for [SWS_EcuM_04073]: Generally EcuM Users shall not be able to set the\nEcuM clock time. The EcuM clock time can be set to an arbitrary time to allow testing\nalarms that take days to expire.\n\n### EcuM Clock Time\n\n[SWS_EcuM_04089] ⌈If the underlying hardware mechanism is tick based, the ECUM\nshall \"correct\" the time accordingly⌋()\n\n#### EcuM Clock Time in the UP Phase\n\nThe EcuM_MainFunction increments the EcuM clock during the UP Phase. It uses\nstandard OS mechanisms (alarms / counters) to derive its time. Note the difference\nin granularity between the counters and EcuM time, which is measured in seconds\n([SWS_EcuM_04069] ).\n\n#### EcuM Clock Time in the Sleep Phase\n\nThere are two alternatives to increment the EcuM clock during sleep depending on\nwhich sleep mode was selected (EcuMSleepModeSuspend parameter)\nWithin the Halt Sequence (see 7.5.2 Activities in the Halt Sequence) the GPT Driver\nmust be put in to a GPT_MODE_SLEEP to only configure those timer channels re-\nquired for the time base. It also requires the GPT to enable the timer based wakeup\nchannel using the Gpt_EnableWakeup API. Preferably the Gpt_StartTimer API will be\nset to 1 sec but if this value is not reachable the EcuM will need to be woken up more\noften to accumulate several timer wakeups until 1 sec has been accumulated to incre-\nment the clock value.\nWithin the Poll Sequence (see 7.5.3 Activities in the Poll Sequence) the EcuM clock can\nbe periodically updated during theEcuM_SleepActivity function using theEcuM_-\nSetClock function, assuming a notion of time is still available. The clock must only be\nincremented when 1 sec of time has been accumulated.\nIn both situations after the clock has been incremented during Sleep the ECU Manager\nmodule must evaluate if the master alarm has expired. If so the BswM will initiate a full\nstartup or set the ECU in Sleep again.\n[SWS_EcuM_04009] ⌈When leaving the Sleep state the ECU Manager Module will\nabort any active user alarm clock and the master alarm clock. This means that both\nclock induced and wakeups due to other events will result in clearing all alarms.⌋(SRS_-\nModeMgm_09187)\n68 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_04010] ⌈User alarms and the master alarm shall be cancelled during\nthe StartPreOS Sequence, in the WakeupRestart Sequence and the OffPreOS Se-\nquence.⌋(SRS_ModeMgm_09188)\n\n## MultiCore\n\nThe distribution of BSW modules onto different partitions was introduced.\nA partition can be seen as an independent section that is mapped on one core. So\nevery core (both in single and in multi core architectures) contains at least one but also\ncan contain arbitrary numbers of partitions. But no partition can span over more than\none core.\nThe BSW modules can be distributed over different partitions and therefore over differ-\nent cores. Some BSW modules as the BswM have to be included into every partition.\nOther modules like the OS or the EcuM have be included into one partition per core.\nAn example is shown in Figure 7.17.\nFigure 7.17: Partitions inside an ECU\nIn a multi core architecture the EcuM has to be distributed in a way, that one instance\nper core exists.\nThere is one designated master core in which the boot loader starts the master Ecu\nM viaEcuM_Init. The master EcuM starts some drivers, determines the Post Build\nconfiguration and starts all remaining cores with all their satellite EcuMs.\nEach EcuM now starts the core local OS and all core local BswMs (in every partition\nresides exactly one BswM).\n69 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nIf the same image of EcuM is executed on every core of the ECU, the ECU Manager’s\nbehavior has to differ on the different cores. This can be accomplished by the ECU\nManager by testing first whether it is on a master or a slave core and act appropriately.\nThe ECU Manager module supports the same phases on a MultiCore ECU as are\navailable on conventional ECUs (i.e. STARTUP , UP , SHUTDOWN and SLEEP).\nIf safety mechanisms are used, The ECU State Manager has to run with full trust level.\nThis section uses previous ECU Manager terms for various ECU states, notably Run/\nPostRun. With flexible ECU management, the system integrator determines the ECU’s\nstates’ names and semantics. Methods to ensure a de-initialization phase must be\nupheld, however. The names used here are therefore not normative.\n\n### Master Core\n\nThere is one explicit master core. Which core the master core is, is determined by\nthe boot loader. The EcuM of the master core gets started as first BSW module and\nperforms initialization actions.\nThen is starts all other cores with all other EcuMs.\nWhen these are started, it initializes together with each satellite EcuM the core local\nOS and BswM.\n\n### Slave Core\n\nOn every slave core, one satellite EcuM has to run. If a core contains more than one\npartition, only on EcuM per core has to exist.\n\n### Master Core - Slave Core Signalling\n\nThis section discusses the general mechanisms with which BSW can communicate\nover cores. It presupposed general knowledge of the SchM, which is described and\nspecified in the RTE.\n\n#### BSW Level\n\nThe Operating System provides a basic mechanism for synchronizing the starts of the\noperating systems on the master and slave cores. The Scheduler Manager provides\nbasic mechanisms for communication of BSW modules across partition boundaries.\nOne BSW Mode Manager per core is responsible for starting and stopping the RTE.\n70 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nRefer to the Guide to Mode Management [23] for a more complete description of the\nsolution approaches and for a discussion of the considerations in choosing between\nthem.\n\n#### Example for Shutdown Synchronization\n\nBefore calling ShutdownAllCores, the \"master\" ECU Manager Module must start\nthe shutdown of all \"slave\" ECU Manager Modules and has to wait until all modules\nhave de-initialized the BSW modules for which they are responsible and successfully\nshutdown.\nTherefore the master ECU Manager Module sets a shutdown flag which can be read by\nall slave modules. The EcuM activates afterwards tasks for every configured slave core.\nThe slave modules read the flag inside the main routine and shutdown if requested.\nThe task name is \"EcuM_SlaveCore<X>_Task\", where X is a number. The task need\nto be configured by the integrator. The number of tasks which need to be activated can\nbe calculated by counting the instances of EcuMPartitionRef minus one, because one\nEcuMFlexPartionRef is used for the master.\nExample: Three instances of EcuMPartitionRef are configured. Then during call of\nEcuM_GoDownHaltPoll() \"EcuM_SlaveCore1_Task\" and \"EcuM_SlaveCore2_Task\"\nwould be started. The slave modules read the flag inside the main routine and shut-\ndown if requested.\nThe Operating System extends the OSEK SetEvent function across cores. A task on\none core can wait for an event set on another core. Figure 18 illustrates how this ap-\nplies to the problem of synchronizing the cores before callingShutdownAllCores\n(whereby the de-initialization details have been omitted). The Set/WaitEvent functions\naccept a bitmask which can be used to indicate shutdown-readiness on the individ-\nual slave cores. Each SetEvent call from a \"slave\" ECU Manager module will stop\nthe \"master\" ECU Manager module’s wait. The \"master\" ECU Manager module must\ntherefore track the state of the individual slave cores and set the wait until all cores\nhave registered their readiness.\nThe WaitEvent() function can be replaced by a GetEvent() loop if the caller already has\ntaken a resource or spinlock.\n71 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\u0001 \u0002 \u0003 \u0005 \u0006 \u0007 \b \t \n \u000b \n \f \n \n \u000e \f \u000b \n \u000f \t\n\u000f \t\n\u0010\n\f\n\u0011\n\u000b \u0006\n\u0012 \u0013\n\u000f\n\u0012\n\u0006\nSlave Core nMaster Core\n«module»\nMaster: EcuM\n«module»\nSlave n: EcuM\n«module»\n:McOs\n«module»\n:BswM\n«module»\nMaster: McOs\n«module»\nSlave n: SchM\nalt loop until all cores done\n[resource or spinlock already taken]\n\u0002 \u0014 \u0015 \u000b \u0016 \u000f \u0017 \t \u0018 \n \f \u0019 \n\u0011 \u0012\n\u0006 \f \u0016\n\u001a \u001b\n\u000b \u0014 \u0006\n\u0011\n\n \f\n\u001c\n\u0006\n\u001d\n\u000f\n\u0012\n\u0006\n\u001e \t\n\u0011\n\u0006 \u000b \u000b \u0014 \u0006\n\u0011\n\u0014 \u0015 \u000b \u0016 \u000f \u0017 \t \u0018 \n \f \u0019\n\u0001 \u0002 \u0003 \u0005 \u0006 \u0007 \b \t \n \u000b \n \f \n \n \u000e \f \u000b \n \u000f \t \u000f \t\n\u0002 \n \f\n\u001c\n\u0006\n\u0013\n\u000f\n\u0012\n\u0006\n\u0002 \u0006 \u000b \f\n\u0011\n\u0014 \u0015 \u000b \u0016 \u000f \u0017 \t \u0018 \n \f \u0019\n\u0017 \u0014 \n\u001d\n\u0014\n\u001d\n\f \t\n\u001a\n\u0006\n\u0012\n\u0006 \f \u0016\n\u001a \u001b\n\f \n \n \u001f\n\u001d\n\u0015\n\u0010 \u0011\n\u000f \u0018 \f \n \n\n\u0011\n\n \f\n\u001c\n\u0006\n\u001d\n\u000f\n\u0012\n\u0006\n\u0011\nGetEvent(Mask)\nShutdownAllCores(StatusType)\nSetEvent(TaskId, Mask)\nEcuM_GoDownHaltPoll\n(Std_ReturnType, EcuM_UserType)\nEcuM_MainFunction()\nWaitEvent(Mask)\nFigure 7.18: Master / Slave Core Shutdown Synchronization (this is an example)\nNote: Figure 7.18 is an example of the logical control flow on the master core. The API\nEcuM_GoDownHaltPoll needs to be offered on every core managed by the EcuM.\nThe behavior of this function on slave cores is implementation specific.\nIntegration note: If synchronization between master and slave cores is achieved by\nmeans SetEvent/WaitEvent, then EcuM_GoDownHaltPoll will be called by the\n72 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nBswM in the context of its main function task (deferred processing of mode arbitration).\nThis additionally requires that the main function task is an extended task.\n\n### UP Phase\n\nFrom the hardware perspective, it is possible that wakeup interrupts could occur on all\ncores. Then the whole ECU gets woken up and the EcuM running on that processes\nthe wakeup event.\n[SWS_EcuM_04011] ⌈The EcuM_MainFunction shall run in all EcuM instances.⌋()\n[SWS_EcuM_04012] ⌈Each instance of the ECU Manager module shall process the\nwakeup events of its core.⌋()\nAs in the single-core case, the BswM (as configured by the integrator) has the respon-\nsibility for controlling ECU resources, establishing that the local core can be powered\ndown or halted as well as de-initializing the appropriate applications and BSW before\nhanding control over to the EcuM of its core.\n\n### STARTUP Phase\n\nThe ECU Manager module functions nearly identically on all cores. That is, as for the\nsingle-core case, the ECU Manager module performs the steps specified for Startup;\nmost importantly starting the OS, initializing the SchM and starting the core local\nBswMs.\nThe master EcuM activates all slave cores after calling InitBlock 1 and doing the reset\n/ wakeup housekeeping. After being activated, the slave cores execute their startup\nroutines, which callEcuM_Init on their core.\n[SWS_EcuM_04146] ⌈If EcuMEcucCoreDefinitionRef is missing then the initial-\nization call shall only be performed on the master core.⌋()\nNote: If you need to initialize a module on multiple cores you have to add the module\nfor each core to the specific initialization list. Please be aware that in such cases the\ninit() function might be called in parallel from different cores and init() functions are\nnormally defined to be non-reentrant.\nAfter each EcuM has called StartOs on its core, the OS synchronizes the cores before\nexecuting the core-individual startup hooks and synchronizes the cores again before\nexecuting the first tasks on each core.\nStartPostOS is executed on each core and the SchM is initialized on each core. All\ncore local BswMs are initialized by each EcuM.\nOne BswM on every partition has to start the RTE for that core.\n73 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_04093] ⌈The ECU Manager module shall start the SchM and the OS on\nevery core.⌋()\n[SWS_EcuM_04014] ⌈The ECU Manager module shall callBswM_Init for all core\nlocal BswMs on the master and all slave cores.⌋()\n\n#### Master Core STARTUP\n\n[SWS_EcuM_04015] ⌈\n74 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nOs\n«module»\nMcu\n«module»\nEcuM\nIntegration Code «module»\nMcOs\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u0001\nopt Configuration data inconsistent\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u000b\n\f \n\n\u0003\n\u000e\n\t\n\u000f\n\u0007 \u0007 \u0002\n\u0010 \u0011 \u0010 \u0012 \u0012 \u0010\n\u0004\n\u0013 \u0012\n\u0002\n\u000e \u0014\nloop FOR all configured cores\nStartOS(ECUM_DEFAULT_APP_MODE)\nEcuM_ErrorHook(ECUM_E_CONFIGURATION_DATA_INCONSISTE NT)\nStartCore(CoreIdType,\nStatusType**)\nEcuM_AL_DriverInitZero()\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nMcu_GetResetReason(Mcu_ResetType)\nCheck consistency of configuration\ndata()\nMap reset reason to wakeup\nsource()\nGetCoreID(CoreIdType)\nEcuM_DeterminePbConfiguration(const\nEcuM_ConfigType*)\nEcuM_LoopDetection()\nMcu_GetResetReason()\nEcuM_AL_DriverInitOne()\nFigure 7.19: Master Core StartPreOS Sequence\n⌋\n()\n[SWS_EcuM_04016] ⌈\n75 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nSchM\n«module»\nEcuM\n«module»\nBswM\n«module»\nMcOs\nloop over every BswM running in this core\nBswM_Init(const BswM_ConfigType *)\nSchM_Start():\nStd_ReturnType\nGetCoreID(CoreIdType)\nSchM_StartTiming(const SchM_ConfigType*)\nSchM_Init(const SchM_ConfigType*)\nFigure 7.20: Master Core StartPostOS Sequence\n⌋\n()\n\n#### Slave Core STARTUP\n\n[SWS_EcuM_04145] ⌈The EcuM EcuM_AL_DriverInitZero and EcuM_AL_-\nDriverInitOne functions shall be called by theEcuM_Init function on each core.\nThe implementation of these callout functions shall ensure that only those MCAL mod-\nules are initialized that run on the currently active core.⌋()\n[SWS_EcuM_04017] ⌈\n76 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nOs\n«module»\nEcuM\n«module»\nMcOs\nIntegration Code\nopt Configuration data inconsistent\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u000b\n\f \n\n\u0003\n\u000e\n\t\n\u000f\n\u0007 \u0007 \u0002\n\u0010 \u0011 \u0010 \u0012 \u0012 \u0010\n\u0004\n\u0013 \u0012\n\u0002\n\u000e \u0014\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \t \n \u0015\nStartOS(ECUM_DEFAULT_APP_MODE)\nEcuM_DeterminePbConfiguration(EcuM_ConfigType*)\nEcuM_AL_DriverInitOne(const EcuM_ConfigType*)\nEcuM_AL_DriverInitZero()\nGetCoreID(CoreIdType)\nEcuM_ErrorHook(ECUM_E_CONFIGURATION_DATA_INCONSISTE NT)\nFigure 7.21: Slave Core StartPreOS Sequence\n⌋\n()\n[SWS_EcuM_04018] ⌈\n77 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nSchM\n«module»\nEcuM\n«module»\nBswM\n«module»\nMcOs\nloop over every BswM running in this core\nGetCoreID(CoreIdType)\nSchM_Start():\nStd_ReturnType\nBswM_Init(const BswM_ConfigType *)\nSchM_Init(const SchM_ConfigType*)\nSchM_StartTiming()\nFigure 7.22: Slave Core StartPostOS Sequence\n⌋\n()\n\n### SHUTDOWN Phase\n\nIndividual core shutdown (i.e. while the rest of the ECU continues to run) is currently\nnot supported. All cores are shut down simultaneously.\nWhen the ECU shall be shut down, the master ECU Manager module callsShutdow-\nnAllCores rather than somehow callingShutdownOS on the individual cores. The\nShutdownAllCores stops the OS on all cores and stops all cores as well.\nSince the master core could issue theShutdownAllCores before all slave cores are\nfinished processing, the cores must be synchronized before entering SHUTDOWN.\nThe BswM (which is distributed over all partitions) ascertains that the ECU should\nbe shut down and synchronizes with each BwsM in the ECU. All BswMs induce de-\ninitialization of all the partition’s BSWs, SWCs and CDDs and send appropriate signals\nto the other BswMs to indicate their readiness to shut down.\n78 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nFor a shutdown of the ECU, the BswM (which lies in the same partition of the master\nEcuM) ultimately calls GoOff on the master core which distributes that request to all\nslave cores. The \"master\" EcuM de-initializes the BswM, and the SchM. The EcuMs\non the slave cores de-initialize their SchM and BswM and then send a signal to indicate\nthat the core is ready for ShutdownOS (again, see section section 7.9.3 Master Core -\nSlave Core Signalling for details).\nThe master EcuM waits for the signal from each slave core EcuM and then initiates\nshutdown as usual on the master core (the master EcuM callsShutdownAllCores,\nand the ECU is put to bed with the global shutdown hook)\n79 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### Master Core SHUTDOWN\n\n«module»\nEcuM\n«module»\nSchM\n«module»\nBswM\n«module»\nMcOs\nIntegration Code\nopt Pending wakeup events?\nloop over every BswM running in this core\nloop FOR all configured cores\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0005 \u0007 \u0004 \u0003 \u0007 \b \u0005 \t \n \u000b \u0002 \f \n \u000e \u000f\nEcuM_OnGoOffOne()\nShutdownAllCores(StatusType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nBswM_Deinit()\nWaitEvent(Mask)\nSchM_Deinit()\nGetCoreID(CoreIdType)\nEcuM_SelectShutdownTarget(Std_ReturnType,\nEcuM_ShutdownTargetType, EcuM_ShutdownModeType)\nFigure 7.23: Master Core OffPreOS Sequence\n80 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_04020] ⌈\nIntegration Code«module»\nEcuM\n«module»\nMcOs\nalt Shutdown Target\n[Reset]\n[Off]\nGetCoreID(CoreIdType)\nEcuM_AL_SwitchOff()\nEcuM_AL_Reset(EcuM_ResetType)\nEcuM_OnGoOffTwo()\nFigure 7.24: Master Core OffPostOS Sequence\n⌋\n()\n81 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### Slave Core SHUTDOWN\n\n«module»\nEcuM\n«module»\nMcOs\n«module»\n:SchM\nIntegration Code «module»\nBswM\nloop over every BswM running in this core\nSetEvent(TaskId, Mask)\nGetCoreID(CoreIdType)\nSchM_Deinit()\nBswM_Deinit()\nEcuM_OnGoOffOne()\nFigure 7.25: Slave Core OffPreOS Sequence\n[SWS_EcuM_04022] ⌈\n82 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n«module»\nMcOs\nIntegration Code\nEcuM_OnGoOffTwo()\nGetCoreID(CoreIdType)\nFigure 7.26: Slave Core OffPostOS Sequence\n⌋\n()\n\n### SLEEP Phase\n\nWhen the shutdown target Sleep is requested, all cores are put to sleep simultaneously.\nThe MCU must issue a halt for each core. As task timing and priority are local to a\ncore in the OS, neither the scheduler nor the RTE must be synchronized after a halt.\nBecause the master core could issue the MCU halt before all slave cores are finished\nprocessing, the cores must be synchronized before entering GoHalt.\nThe BswMs ascertain that sleep should be initiated and distribute an appropriate ECU\nmode to each core. The BSWs, SWCs and CDDs on the slave cores must be informed\nby their partition local BswM, de-initialize appropriately and send appropriate mode\nrequests to the BswM to indicate their readiness.\nIf the ECU is put to sleep, the \"halt\"s must be synchronized so that all slave cores are\nhalted before the master core computes the checksum. The ECU Manager module on\nthe master core uses the same \"signal\" mechanism as for synchronizing cores on Go\nOff.\nSimilarly, the ECU Manager module on the master core must validate the checksum\nbefore releasing the slave cores from the \"halt\" state\n83 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### Master Core SLEEP\n\n[SWS_EcuM_04023] ⌈\n«module»\nEcuM\n«module»\nOs\nIntegration Code «module»\n:BswM\nGetCoreID(CoreIdType)\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_NONE )\nFigure 7.27: Master Core GoSleep Sequence\n⌋\n()\n[SWS_EcuM_04024] ⌈\n84 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\u0001 \u0002 \u0003 \u0004 \u0006 \u0007 \b \b \t \n \u000b \n \f \f \n \n \u000e \f \t \u0004 \u000f\nIntegration Code «module»\n:BswM\n«Peripheral»\nWakeup Source\n«module»\nMcu\n«module»\nEcuM\n«module»\nWakeup Source\n«module»\nOs\nHALT\nopt RAM check failed\nalt Validation Needed\n[Yes]\n[No]\nalt AlarmClock Service Present\n[EcuM_AlarmClock only pending event AND Alarm not expired]\n\u0010 \u0011 \u0012 \u0013\n\n \n \u000e \f \t \u0004 \n\n\u0014 \u0015\n\u0007 \b \n\n\u0016 \u0010 \u0017\n\n \u0006 \u000e \n \u0003\n\u0014\n\t\n\u0006\n\u0014\n\t \n \u0003 \t \u000e \n \u0004 \u0018 \u0003 \n \u0002 \n \u0002 \n \u0003 \t \n \n \f \f \u000e \u0019 \n \u0007 \u001a\n\u0014\n\u000b \n \u001b\nEcuM_GenerateRamHash()\nEcuM_CheckRamHash(uint8)\nReturn from\ninterrupt()\nWait for all SlaveCores to be ready to\nsleep()\nEcuM_ErrorHook(uint16)\nMcu_SetMode()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nSignal all SlaveCores\nto continue()\nDisableAllInterrupts()\n<Module>_CheckWakeup()\nBswM_EcuM_CurrentWakeup(Sources,\nECUM_WKSTATUS_VALIDATED)\nMcu_SetMode(Mcu_ModeType)\nInterrupt()\nEcuM_GenerateRamHash()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_PENDING)\nActivate\nPLL()\nFigure 7.28: Master Core Halt Sequence\n85 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n⌋(SRS_ModeMgm_09239)\n[SWS_EcuM_04025] ⌈\n«module»\nEcuM\n«module»\n:BswM\nIntegration Code «module»\nMcu\n«module»\nWakeup Source\n«module»\nOs\nloop WHILE no pending/validated events\nloop FOR all wakeup sources that need polling\nopt Wakeup detected\nalt \n[Yes]\n[No]\n\u0001 \u0002 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0007 \b \n \u0005 \u0006 \u000b \u0003 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0004 \u0005 \f \u0005 \u0005 \n \u000e \u000f \u0010 \u0003 \b \u0011 \u0012 \u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0017 \u0011 \u0013 \u0018 \u0003 \u0015 \u0011 \u0019 \u0013 \u0011 \u001a \u0011 \u0006 \u0004 \u0001 \u001b \u001c\n\u001d\n\u0015\n\u001e \u001f  \n\u0001 \b \u0007 \u0013 \u0014 \n \b \u0005 \u0015 \u0016 \u0005 \u0006 \b\n!\n\n \u0011 \u0006 \u0002 \u0003 \u0006\n\"\n\u0011 \u0018 \u0011 \u0006 \u0004 \u0001 \u001b \u001c \u0001 \b \u0007 \u0013 \u0014 \u0006 \u0005 \u0004 \u0011\n#\n\n \u0003 \u0013 \u0011 \u0002\n$\nEnableAllInterrupts()\nSignal SlaveCores to\ncontinue()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEcuM_SleepActivity()\n<Module>_CheckWakeup()\nMcu_SetMode\n(Mcu_ModeType)\nBswMEcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_VALIDATED)\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources,\nECUM_WKSTATUS_PENDING)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nFigure 7.29: Master Core Poll Sequence\n⌋\n()\n[SWS_EcuM_04026] ⌈\n86 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nMcu\n«module»\nOs\n«module»\nEcuM\nIntegration Code\nMcu_SetMode(Mcu_ModeType)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nEcuM_AL_DriverRestart()\nFigure 7.30: Master Core WakeupRestart Sequence\n⌋\n()\n\n#### Slave Core SLEEP\n\n[SWS_EcuM_04027] ⌈\n87 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n«module»\nOs\n«module»\n:BswM\nIntegration Code\nGetCoreID(CoreIdType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_NONE )\nFigure 7.31: Slave Core GoSleep Sequence\n⌋\n()\n[SWS_EcuM_04028] ⌈\n88 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nIntegration Code «module»\nWakeup Source\n«module»\nEcuM\n«module»\nMcu\n«Peripheral»\nWakeup Source\n«module»\nOs\n«module»\n:BswM\nHALT\nalt Validation Needed\n[Yes]\n[No]\nMcu_SetMode()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nInterrupt()\nSignal MasterCore that Slave is ready to sleep()\nReturn from\ninterrupt()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nBswM_EcuM_CurrentState(ECUM_WKSTATUS_PENDING)\nWait for MasterCore to continue()\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(Sources, ECUM_WKSTATUS_VALI DATED)\n<Module>_CheckWakeup()\nEnableAllInterrupts()\nMcu_SetMode(Mcu_ModeType)\nFigure 7.32: Slave Core Halt Sequence\n⌋\n()\n[SWS_EcuM_04029] ⌈\n89 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n«module»\nWakeup Source\n«module»\nMcu\nIntegration Code «module»\nOs\n«module»\nBswM\nloop WHILE no pending/validated events\nloop FOR all wakeup sources that need polling\nopt Wakeup detected\nalt \n[Yes]\n[No]\n\u0001 \u0002 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u0007 \b \n \u0005 \u0006 \u0002 \u0003 \u0004 \u0003 \u0005 \u0006 \u000b \u0004 \u0005 \f \u0005 \u0005 \n \u000e\n\u000f \u0010\n\u0003 \b\n\u0011 \u0012\n\u0001 \b \u0007\n\u0013 \u0014\n\n \b \u0005\n\u0015 \u0016 \u0017 \u0011 \u0013 \u0018\n\u0003\n\u0015 \u0011 \u0019 \u0013 \u0011\n\u000b\n\u0011\n\u0006 \u0004\n\u0001 \u001a \u001b \u001c\n\u0015\n\u001d \u001e \u001f \u0001 \b \u0007\n\u0013 \u0014\n\n \b \u0005\n\u0015 \u0016\n\u0005 \u0006 \b  \n\n\u0011\n\u0006 \u0002 \u0003 \u0006 !\n\u0011 \u0018\u0011\n\u0006 \u0004\n\u0001 \u001a \u001b \u0001 \b \u0007\n\u0013 \u0014\n\u0006 \u0005 \u0004\n\u0011 \"\n\n \u0003\n\u0013 \u0011\n\u0002\n#\nMcu_SetMode(Mcu_ModeType)\nWait for signal from MasterCore to continue()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\n<Module>_CheckWakeup()\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_PEND ING)\nEcuM_GetPendingWakeupEvents(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nDisableAllInterrupts()\nBswM_EcuM_CurrentWakeup(sources, ECUM_WKSTATUS_VALI DATED)\nEcuM_SleepActivity()\nFigure 7.33: Slave Core Poll Sequence\n⌋\n()\n[SWS_EcuM_04030] ⌈\n90 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nMcu\n«module»\nOs\n«module»\nEcuM\nIntegration Code\nMcu_SetMode(Mcu_ModeType)\nDisableAllInterrupts()\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nFigure 7.34: Slave Core WakeupRestart Sequence\n⌋\n()\n\n### Runnables and Entry points\n\n\n\n#### Internal behavior\n\n[SWS_EcuM_03018] ⌈The definition of the internal behavior of the the ECU Manager\nmodule shall be as follows. This detailed description is only needed for the configura-\ntion of the local RTE.\nInternalBehavior EcuStateManager {\n// Runnable entities of the EcuStateManager\nRunnableEntity SelectShutdownTarget\nsymbol \"EcuM_SelectShutdownTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetShutdownTarget\n91 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nsymbol \"EcuM_GetShutdownTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetLastShutdownTarget\nsymbol \"EcuM_GetLastShutdownTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SelectShutdownCause\nsymbol \"EcuM_SelectShutdownCause\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetShutdownCause\nsymbol \"EcuM_GetShutdownCause\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SelectBootTarget\nsymbol \"EcuM_SelectBootTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetBootTarget\nsymbol \"EcuM_GetBootTarget\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SetRelWakeupAlarm\nsymbol \"EcuM_SetRelWakeupAlarm\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SetAbsWakeupAlarm\nsymbol \"EcuM_SetAbsWakeupAlarm\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity AbortWakeupAlarm\nsymbol \"EcuM_AbortWakeupAlarm\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetCurrentTime\nsymbol \"EcuM_GetCurrentTime\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity GetWakeupTime\nsymbol \"EcuM_GetWakeupTime\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity SetClock\nsymbol \"EcuM_SetClock\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity RequestRUN\nsymbol \"EcuM_RequestRUN\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity ReleaseRUN\nsymbol \"EcuM_ReleaseRUN\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity RequestPOSTRUN\nsymbol \"EcuM_RequestPOST_RUN\"\ncanbeInvokedConcurrently = TRUE\nRunnableEntity ReleasePOSTRUN\nsymbol \"EcuM_ReleasePOST_RUN\"\ncanbeInvokedConcurrently = TRUE\n// Port present for each user. There are NU users\nSR000.RequestRUN -> RequestRUN\nSR000.ReleaseRUN -> ReleaseRUN\nSR000.RequestPOSTRUN -> RequestPOSTRUN\nSR000.ReleasePOSTRUN -> RequestPOSTRUN\nPortArgument {port=SR000, value.type=EcuM_UserType,\nvalue.value=EcuMUser[0].User }\n92 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n(...)\nSRnnn.RequestRUN -> RequestRUN\nSRnnn.ReleaseRUN -> ReleaseRUN\nSRnnn.RequestPOSTRUN -> RequestPOSTRUN\nSRnnn.ReleasePOSTRUN -> RequestPOSTRUN\nPortArgument {port=SRnnn, value.type=EcuM_UserType,\nvalue.value=EcuMUser[nnn].User }\nshutDownTarget.SelectShutdownTarget -> SelectShutdownTarget\nshutDownTarget.GetShutdownTarget -> GetShutdownTarget\nshutDownTarget.GetLastShutdownTarget -> GetLastShutdownTarget\nshutDownTarget.SelectShutdownCause -> SelectShutdownCause\nshutDownTarget.GetShutdownCause -> GetShutdownCause\nbootTarget.SelectBootTarget -> SelectBootTarget\nbootTarget.GetBootTarget -> GetBootTarget\nalarmClock.SetRelWakeupAlarm-> SetRelWakeupAlarm\nalarmClock.SetAbsWakeupAlarm -> SetAbsWakeupAlarm\nalarmClock.AbortWakeupAlarm -> AbortWakeupAlarm\nalarmClock.GetCurrentTime -> GetCurrentTime\nalarmClock.GetWakeupTime -> GetWakeupTime\nalarmClock.SetClock -> SetClock\n};\n⌋()\n\n## EcuM Mode Handling\n\nThe ECU State Manager provides interfaces for SW-Cs to request and release the\nmodes RUN and POST_RUN optionally.\nEcuMFlex arbitrates the requests and releases made by SW-Cs and propagates the\nresult to BswM. The cooperation between EcuM and BswM is necessary as only the\nBswM can decide when a transition to a different mode can be made. Due to the\nfact that the EcuM does not have an own state machine, the EcuM relies on the state\ntransitions made by BswM. Therefore the EcuM does not request a state. Furthermore\nit notifies the BswM about the current arbitration of all requests. And the BswM is\nnotified when the RTE has executed all Runnables belonging to a certain mode.\nArchitecturalComponentsofECUModeHandling\n93 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nFigure 7.35: Architectural Components of ECU Mode Handling\nFigure 7.35 illustrates the architectural components of ECU Mode Handling.\n[SWS_EcuM_04115] ⌈ECU Mode Handling shall be applied whenEcuMModeHan-\ndling is configured to true.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04116] ⌈When the BswM sets a state of the EcuM byEcuM_SetState,\nthe EcuM shall indicate the corresponding mode to the RTE.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04117] ⌈When the last RUN request has been released, ECU\nState Manager module shall indicate this to BswM using the API BswM_EcuM_-\nRequestedState(ECUM_STATE_APP_RUN, ECUM_RUNSTATUS_RELEASED).⌋\n(SRS_ModeMgm_09116)\nIf a SW-C needs post run activity during POST_RUN (e.g. shutdown preparation),\nthen it must request POST_RUN before releasing the RUN request. Otherwise it is not\nguaranteed that this SW-C will get a chance to run its POST_RUN code.\n[SWS_EcuM_04118] ⌈When the ECU State Manager is not in the state which is re-\nquested by a SWC, it shall inform BswM about requested states using theBswM_-\nEcuM_RequestedState API.⌋(SRS_ModeMgm_09116)\nPOST_RUN state provides a post run phase for SW-C’s and allows them to save im-\nportant data or switch off peripherals.\n[SWS_EcuM_04144] ⌈When the first RUN or POST_RUN request has been received,\nECU State Manager module shall indicate this to BswM usingBswM_EcuM_Request-\nedState(ECUM_STATE_APP_RUN, ECUM_RUNSTATUS_REQUESTED).⌋()\n[SWS_EcuM_04119] ⌈When the last POST_RUN request has been released, ECU\nState Manager module shall indicate this to BswM using the APIBswM_EcuM_Re-\nquestedState(ECUM_STATE_APP_POST_RUN, ECUM_RUNSTATUS_RELEASED).⌋\n(SRS_ModeMgm_09116)\n94 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nHint: To prevent, that the mode machine instance of ECU Mode lags behind and the\nstates EcuM and the RTE get out of phase, the EcuM can use acknowledgement feed-\nback for the mode switch notification.\nNote that EcuM only requests Modes from and to RUN and POST_RUN, the SLEEP\nMode has to be set by BswM, as the EcuM has no information about when this Mode\ncan be entered.\nState Description\nSTARTUP Initial value. Set by Rte when\nRte_Start() has been called.\nRUN\nAs soon as all necesseray BSW\nmodules are inistialized, BswM\nswitches to this Mode.\nPOST_RUN\nEcuM requests POST_RUN,\nwhen no RUN requests are\navailable.\nSLEEP\nEcuM requests SLEEP Mode\nwhen no RUN and POST_RUN\nrequests are available and Shut-\ndown Target is set to SLEEP .\nSHUTDOWN\nEcuM requests SHUTDOWN\nMode when no RUN and POST_\nRUN requests are available and\nShutdown Target is set to SHUT -\nDOWN.\nTable 7.8: EcuM Modes\n[SWS_EcuM_04143] ⌈EcuM shall notify BswM about the current State by calling the in-\nterface BswM_EcuM_CurrentState(EcuM_StateType State). A new state shall\nbe set by EcuM when RTE has given its feedback via the acknowledgement port.⌋()\n\n## Advanced Topics\n\n\n\n### Relation to Bootloader\n\nThe Bootloader is not part of AUTOSAR. Still, the application needs an interface to\nactivate the bootloader. For this purpose, two functions are provided:EcuM_Select-\nBootTarget and EcuM_GetBootTarget .\n95 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nReset\nBoot Menu\nBoot Target\nBootloader\nApplication\nSS \nBootloader\nFigure 7.36: Selection of Boot Targets\nBootloader, system supplier bootloader and application are separate program images,\nwhich in many cases even can be flashed separately. The only way to get from one\nimage to another is through reset. The boot menu will branch into the one or other\nimage depending on the selected boot target.\n\n### Relation to Complex Drivers\n\nIf a complex driver handles a wakeup source, it must follow the protocol for handling\nwakeup events specified in this document.\n\n### Handling Errors during Startup and Shutdown\n\n[SWS_EcuM_02980] ⌈The ECU Manager module shall ignore all types of errors that\noccur during initialization, e.g. values returned by init functions⌋()\nInitialization is a configuration issue (see EcuMDriverInitListZero , EcuM-\nDriverInitListOne and EcuMDriverRestartList ) and therefore cannot be\nstandardized.\nBSW modules are responsible themselves for reporting errors occurring during their ini-\ntialization directly to the DEM module or the DET module, as specified in their SWSs.\nThe ECU Manager module does not report the errors. The BSW module is also re-\nsponsible for taking any special measures to react to errors occurring during their ini-\ntialization.\n\n## ErrorHook\n\n[SWS_EcuM_04033] ⌈In the unrecoverable error situations defined in the first column\nof Table in [SWS_EcuM_04032], the ECU Manager module shall call theEcuM_Er-\nrorHook callout with the parameter value set to the corresponding related error code.⌋\n()\n96 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nClarification to [SWS_EcuM_04033]: EcuM shall assume that theEcuM_ErrorHook\nwill not return (integrator’s code).\nClarification to [SWS_EcuM_04033]: In case a Dem error is needed, it is integrator’s\nresponsibility to define a strategy to handle it (e.g.: As EcuM does not directly call Dem,\nset the Dem error after a reset recovery).\n[SWS_EcuM_04139] ⌈If an OS function call fails and no other fault reaction is defined,\nthe EcuM shall not change the requested state. In such cases an error reporting via\nEcuM_ErrorHook shall be performed.⌋()\nNote: The exact error code used when callingEcuM_ErrorHook depends on the OS\nfunction and their return value and is not standardized.\n\n## Error classification\n\nSection \"Error Handling\" of the document [6] describes the error handling of the Basic\nSoftware in detail. Above all, it constitutes a classification scheme consisting of five\nerror types which may occur in BSW modules.\nBased on this foundation, the following section specifies particular errors arranged in\nthe respective subsections below.\nAUTOSAR BSW modules normally report their errors to Det (development errors) or\nDem (production errors).\nThe EcuM handles errors differently and does not report its errors to Dem/Det.\nIf a reporting of errors to Dem/Det is needed the user can perform these actions in the\nEcuM_ErrorHook .\nThe following subchapters contains all error codes which might be reported from the\nEcuM (besides those individual error codes defined by the integrator).\n\n### Development Errors\n\n[SWS_EcuM_04032] ⌈\nType of error Related error code Error value\nMultiple requests by the same user were detectedECUM_E_MULTIPLE_RUN_REQUESTS Assigned by\nImplementation\nA function was called which was disabled by\nconfiguration\nECUM_E_SERVICE_DISABLED Assigned by\nImplementation\nA service was called prior to initialization ECUM_E_UNINIT Assigned by\nImplementation\n▽\n97 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nType of error Related error code Error value\nAn unknown wakeup source was passed as a\nparameter to an API\nECUM_E_UNKNOWN_WAKEUP_SOURCE Assigned by\nImplementation\nThe initialization failed ECUM_E_INIT_FAILED Assigned by\nImplementation\nA state, passed as an argument to a service, was\nout of range (specific parameter test)\nECUM_E_STATE_PAR_OUT_OF_RANGE Assigned by\nImplementation\nA parameter was invalid (unspecific) ECUM_E_INVALID_PAR Assigned by\nImplementation\nA invalid pointer was passed as an argument ECUM_E_PARAM_POINTER Assigned by\nImplementation\nA previous matching request for the provided user\nwas not found\nECUM_E_MISMATCHED_RUN_RELEASE Assinged by\nImplementation\n⌋(SRS_BSW_00327, SRS_BSW_00337, SRS_BSW_00350, SRS_BSW_00385)\n\n### Runtime Errors\n\n[SWS_EcuM_91003] ⌈\nType of error Related error code Error value\nPostbuild configuration data is inconsistent ECUM_E_CONFIGURATION_DATA_\nINCONSISTENT\nAssigned by\nImplementation\nThe RAM check during wakeup failed ECUM_E_RAM_CHECK_FAILED Assigned by\nImplementation\n⌋()\n\n### Transient Faults\n\nThere are no transient faults.\n\n### Production Errors\n\nThere are no production errors.\n\n### Extended Production Errors\n\nThere are no extended production errors.\n98 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# API specification\n\n\n\n## Imported Types\n\nThis section lists all types imported by the ECU Manager module from the correspond-\ning AUTOSAR modules.\n[SWS_EcuM_02810] ⌈\nModule Header File Imported Type\nAdc Adc.h Adc_ConfigType\nBswM BswM.h BswM_ConfigType\nCan Can.h Can_ConfigType\nCanTrcv CanTrcv.h CanTrcv_ConfigType\nComStack_Types.h NetworkHandleTypeComStack_Types\nComStack_Types.h PNCHandleType\nDem Dem.h Dem_ConfigType\nDet Det.h Det_ConfigType\nEth Eth.h Eth_ConfigType\nEthSwt EthSwt.h EthSwt_ConfigType\nEthTrcv EthTrcv.h EthTrcv_ConfigType\nFls Fls.h Fls_ConfigType\nFr Fr.h Fr_ConfigType\nFrTrcv FrTrcv.h FrTrcv_ConfigType\nGpt Gpt.h Gpt_ConfigType\nIcu Icu.h Icu_ConfigType\nIoHwAb IoHwAb.h IoHwAb<Init_Id>_ConfigType\nLin Lin.h Lin_ConfigType\nLinTrcv LinTrcv.h LinTrcv_ConfigType\nOs.h AppModeTypeMcOs\nOs.h CoreIdType\nMcu.h Mcu_ConfigType\nMcu.h Mcu_ModeType\nMcu\nMcu.h Mcu_ResetType\nOcu Ocu.h Ocu_ConfigType\nOs Os.h StatusType\nPort Port.h Port_ConfigType\nPwm Pwm.h Pwm_ConfigType\nSchM SchM.h SchM_ConfigType\nSpi Spi.h Spi_ConfigType\nStd_Types.h Std_ReturnTypeStd\nStd_Types.h Std_VersionInfoType\nWdg Wdg.h Wdg_ConfigType\n⌋()\n99 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_03019] ⌈ECUM_E_EARLIER_ACTIVE and ECUM_E_PAST shall be of\ntype Std_ReturnType and represent the following values\n•ECUM_E_EARLIER_ACTIVE = 3\n•ECUM_E_PAST = 4\n⌋()\n\n## Type definitions\n\n\n\n### EcuM_ConfigType\n\n[SWS_EcuM_04038] ⌈\nName EcuM_ConfigType\nKind Structure\n-\nType –\nElements\nComment The content of this structure depends on the post-build configuration of\nEcuM.\nDescription A pointer to such a structure shall be provided to the ECU State Manager initialization routine for\nconfiguration.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02801] ⌈The structure defined by type EcuM_ConfigType shall hold the\npost-build configuration parameters for the ECU Manager module as well as pointers to\nall ConfigType structures of modules that are initialized by the ECU Manager module.⌋\n()\nThe ECU Manager module Configuration Tool must generate the structure defined by\nthe EcuM_ConfigType type specifically for a given set of basic software modules that\ncomprise the ECU configuration. The set of basic software modules is derived from\nthe corresponding EcuM parameters\n[SWS_EcuM_02794] ⌈The structure defined in the EcuM_ConfigType type shall con-\ntain an additional post-build configuration variant identifier (uint8/uint16/uint32 depend-\ning on algorithm to compute the identifier).⌋()\nSee also Chapter 7.3.4 Checking Configuration Consistency.\n[SWS_EcuM_02795] ⌈The structure defined by the EcuM_ConfigType type shall con-\ntain an additional hash code that is tested against the configuration parameterEcuM-\nConfigConsistencyHash for checking consistency of the configuration data.⌋()\nSee also section 7.3.4 Checking Configuration Consistency.\n100 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nFor each given ECU configuration, the ECU Manager module Configuration Tool must\ngenerate an instance of this structure that is filled with the post-build configuration pa-\nrameters of the ECU Manager module as well as pointers to instances of configuration\nstructures for the modules mentioned above. The pointers are derived from the corre-\nsponding EcuM parameters.\n\n### EcuM_RunStatusType\n\n[SWS_EcuM_04120] ⌈\nName EcuM_RunStatusType\nKind Type\nDerived from uint8\nECUM_RUNSTATUS_UNKNOWN 0 Unknown status. Init Value.\nECUM_RUNSTATUS_\nREQUESTED\n\n# Status requested from EcuM\n\nRange\nECUM_RUNSTATUS_\nRELEASED\n\n# Status released from EcuM.\n\nDescription Result of the Run Request Protocol sent to BswM\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04121] ⌈The ECU Manager module shall inform BswM about the state of\nthe Run Request Protocol as listed in the EcuM_RunStatusType.⌋(SRS_ModeMgm_-\n09116)\n\n### EcuM_WakeupSourceType\n\n[SWS_EcuM_04040] ⌈\nName EcuM_WakeupSourceType\nKind Type\nDerived from uint32\nECUM_WKSOURCE_POWER 0x01 Power cycle (bit 0)\nECUM_WKSOURCE_RESET\n(default)\n0x02 Hardware reset (bit 1).\nIf the Mcu driver cannot\ndistinguish between a power cycle\nand a reset reason, then this shall\nbe the default wakeup source.\n▽\n101 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nECUM_WKSOURCE_\nINTERNAL_RESET\n0x04 Internal reset ofµC (bit 2)\nThe internal reset typically only\nresets theµC core but not\nperipherals or memory controllers.\nThe exact behavior is hardware\nspecific. This source may also\nindicate an unhandled exception.\nECUM_WKSOURCE_\nINTERNAL_WDG\n0x08 Reset by internal watchdog (bit 3)\nECUM_WKSOURCE_\nEXTERNAL_WDG\n0x10 Reset by external watchdog (bit\n4), if detection supported by\nhardware\nDescription EcuM_WakeupSourceType defines a bitfield with 5 pre-defined positions (see Range). The bitfield\nprovides one bit for each wakeup source.\nIn WAKEUP , all bits cleared indicates that no wakeup source is known.\nIn STARTUP , all bits cleared indicates that no reason for restart or reset is known. In this case,\nECUM_WKSOURCE_RESET shall be assumed.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02165] ⌈Additional wakeup sources (to the pre-defined sources) shall be\nassigned individually to bitfield positions 5 to 31 by configuration. The bit assignment\nshall be done by the configuration tool.⌋()\n[SWS_EcuM_02166] ⌈The EcuMWakeupSourceId (see ECUC_EcuM_00151) field in\nthe EcuMWakeupSource container shall define the position corresponding to that\nwakeup source in all instances the EcuM_WakeupSourceType bitfield.⌋()\n\n### EcuM_WakeupStatusType\n\n[SWS_EcuM_04041] ⌈\nName EcuM_WakeupStatusType\nKind Type\nDerived from uint8\nECUM_WKSTATUS_NONE 0 No pending wakeup event was\ndetected\nECUM_WKSTATUS_PENDING 1 The wakeup event was detected\nbut not yet validated\nECUM_WKSTATUS_VALIDATED 2 The wakeup event is valid\nRange\nECUM_WKSTATUS_EXPIRED 3 The wakeup event has not been\nvalidated and has expired\ntherefore\nDescription The type describes the possible states of a wakeup source.\nAvailable via EcuM.h\n⌋() NOTE: This declaration has to be changed to a mode. The name has to be\nchanged.\n102 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuM_ResetType\n\n[SWS_EcuM_04044] ⌈\nName EcuM_ResetType\nKind Type\nDerived from uint8\nECUM_RESET_MCU 0 Microcontroller reset via Mcu_\nPerformReset\nECUM_RESET_WDG 1 Watchdog reset via WdgM_\nPerformReset\nRange\nECUM_RESET_IO 2 Reset by toggeling an I/O line.\nDescription This type describes the reset mechanisms supported by the ECU State Manager. It can be\nextended by configuration.\nAvailable via EcuM.h\n⌋()\n\n### EcuM_StateType\n\n[SWS_EcuM_91005] ⌈\nName EcuM_StateType\nKind Type\nDerived from uint8\nECUM_SUBSTATE_MASK 0x0f –\nECUM_STATE_STARTUP 0x10 –\nECUM_STATE_RUN 0x32 –\nECUM_STATE_POST_RUN 0x33 –\nECUM_STATE_SHUTDOWN 0x40 –\nRange\nECUM_STATE_SLEEP 0x50 –\nDescription ECU State Manager states.\nAvailable via EcuM.h\n⌋(SRS_BSW_00331)\n[SWS_EcuM_02664] ⌈The ECU Manager module shall define all states as listed in the\nEcuM_StateType.⌋()\n\n## Function Definitions\n\nThis is a list of functions provided for upper layer modules.\n103 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### General\n\n\n\n#### EcuM_GetVersionInfo\n\n[SWS_EcuM_02813] ⌈\nService Name EcuM_GetVersionInfo\nSyntax void EcuM_GetVersionInfo (\nStd_VersionInfoType* versioninfo\n)\nService ID [hex] 0x00\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) versioninfo Pointer to where to store the version information of this module.\nReturn value None\nDescription Returns the version information of this module.\nAvailable via EcuM.h\n⌋(SRS_BSW_00407, SRS_BSW_00411)\n\n### Initialization and Shutdown Sequences\n\n\n\n#### EcuM_GoDownHaltPoll\n\n[SWS_EcuM_91002] ⌈\nService Name EcuM_GoDownHaltPoll\nSyntax Std_ReturnType EcuM_GoDownHaltPoll (\nEcuM_UserType UserID\n)\nService ID [hex] 0x2c\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) UserID Id of the user calling this API. Only configured users are allowed\nto call this function.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_NOT_OK: The request was not accepted.\nE_OK: If the ShutdownTargetType is SLEEP the call successfully\nreturns, the ECU has left the sleep again.\nIf the ShutdownTargetType is RESET or OFF this call will not\nreturn.\nDescription Instructs the ECU State Manager module to go into a sleep mode, Reset or OFF depending on\nthe previously selected shutdown target.\n▽\n104 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_Init\n\n[SWS_EcuM_02811] ⌈\nService Name EcuM_Init\nSyntax void EcuM_Init (\nvoid\n)\nService ID [hex] 0x01\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Initializes the ECU state manager and carries out the startup procedure. The function will never\nreturn (it calls StartOS)\nAvailable via EcuM.h\n⌋(SRS_BSW_00358, SRS_BSW_00414, SRS_BSW_00101)\n\n#### EcuM_StartupTwo\n\n[SWS_EcuM_02838] ⌈\nService Name EcuM_StartupTwo\nSyntax void EcuM_StartupTwo (\nvoid\n)\nService ID [hex] 0x1a\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This function implements the STARTUP II state.\n▽\n105 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02806] ⌈Caveats of EcuM_StartupTwo: This function must be called\nfrom a task, which is started directly as a consequence of StartOS. I.e. either the\nEcuM_StartupTwo function must be called from an autostart task or the EcuM_Startup\nTwo function must be called from a task, which is explicitly started.⌋()\nClarification to [SWS_EcuM_02806] : The OS offers different mechanisms to activate\na task on startup. Normally EcuM_StartupTwo would be configured as an autostart\ntask in the default application mode.\nThe integrator can configure the OS to activate the EcuM_StartupTwo task by any\nmechanism, as long as it is started immediately after StartOS is called. The task can\nalso be activated from within another task and this other task could be an autostart\ntask.\nStarting EcuM_StartupTwo as an autostart task is an implicit activation. The other\nmechanisms would be an explicit activation.\n\n#### EcuM_Shutdown\n\n[SWS_EcuM_02812] ⌈\nService Name EcuM_Shutdown\nSyntax void EcuM_Shutdown (\nvoid\n)\nService ID [hex] 0x02\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Typically called from the shutdown hook, this function takes over execution control and will carry\nout GO OFF II activities.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09114)\n106 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### State Management\n\n\n\n#### EcuM_ SetState\n\n[SWS_EcuM_04122] ⌈\nService Name EcuM_SetState\nSyntax void EcuM_SetState (\nEcuM_StateType state\n)\nService ID [hex] 0x2b\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) state State indicated by BswM.\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Function called by BswM to notify about State Switch.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_04123] ⌈The EcuM_SetState function shall set the EcuM State to the\nvalue of the State parameter.\nIf the State parameter is not a valid value, the EcuM_SetState function shall not change\nthe State and if Development Error Reporting is turned on, the EcuM_SetState function\nshall additionally send an ECUM_E_STATE_PAR_OUT_OF_RANGE error message to\nthe DET module.⌋(SRS_ModeMgm_09116)\n\n#### EcuM_RequestRUN\n\n[SWS_EcuM_04124] ⌈\nService Name EcuM_RequestRUN\nSyntax Std_ReturnType EcuM_RequestRUN (\nEcuM_UserType user\n)\nService ID [hex] 0x03\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user ID of the entity requesting the RUN state.\nParameters (inout) None\nParameters (out) None\n▽\n107 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nReturn value Std_ReturnType E_OK: The request was accepted by EcuM.\nE_NOT_OK: The request was not accepted by EcuM\nDescription Places a request for the RUN state. Requests can be placed by every user made known to the\nstate manager at configuration time.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_04125] ⌈Requests of EcuM_RequestRUN cannot be nested, i.e. one\nuser can only place one request but not more. Additional or duplicate user requests by\nthe same user shall be reported to DET. Of course the DET will only be notified under\ndevelopment conditions.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_04126] ⌈An implementation must track requests for each user known on\nthe ECU. Run requests are specific to the user.⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03024] ⌈If development error detection is enabled and there are multiple\nrequests by the same user detected byEcuM_RequestRUN the function shall report\nECUM_E_MULTIPLE_RUN_REQUESTS to Det.⌋()\n\n#### EcuM_ReleaseRUN\n\n[SWS_EcuM_04127] ⌈\nService Name EcuM_ReleaseRUN\nSyntax Std_ReturnType EcuM_ReleaseRUN (\nEcuM_UserType user\n)\nService ID [hex] 0x04\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user ID of the entity releasing the RUN state.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The release request was accepted by EcuM\nE_NOT_OK: The release request was not accepted by EcuM\nDescription Releases a RUN request previously done with a call to EcuM_RequestRUN. The service is\nintended for implementing AUTOSAR ports.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03023] ⌈If development error detection is enabled and EcuM_Re-\nleaseRUN did not find a previous matching request for the provided user, then the\nfunction shall reportECUM_E_MISMATCHED_RUN_RELEASE to Det.⌋()\nConfiguration of EcuM_ReleaseRUN: Refer to EcuM_UserType for more information\nabout user IDs and their generation.\n108 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### EcuM_RequestPOST_RUN\n\n[SWS_EcuM_04128] ⌈\nService Name EcuM_RequestPOST_RUN\nSyntax Std_ReturnType EcuM_RequestPOST_RUN (\nEcuM_UserType user\n)\nService ID [hex] 0x0a\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user ID of the entity requesting the POST RUN state.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The request was accepted by EcuM\nE_NOT_OK: The request was not accepted by EcuM\nDescription Places a request for the POST RUN state. Requests can be placed by every user made known\nto the state manager at configuration time. Requests for RUN and POST RUN must be tracked\nindependently (in other words: two independent variables). The service is intended for\nimplementing AUTOSAR ports.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03025] ⌈If development error detection is enabled and there are multiple\nrequests by the same user detected byEcuM_RequestPOST_RUN the function shall\nreport ECUM_E_MULTIPLE_RUN_REQUESTS to Det.⌋()\nAll requirements of 8.3.3.2 EcuM_RequestRUN apply accordingly to the function Ecu\nM_RequestPOST_RUN.\nConfiguration of EcuM_RequestPOST_RUN: Refer to EcuM_UserType for more infor-\nmation about user IDs and their generation.\n\n#### EcuM_ReleasePOST_RUN\n\n[SWS_EcuM_04129] ⌈\nService Name EcuM_ReleasePOST_RUN\nSyntax Std_ReturnType EcuM_ReleasePOST_RUN (\nEcuM_UserType user\n)\nService ID [hex] 0x0b\nSync/Async Synchronous\nReentrancy Reentrant\n▽\n109 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nParameters (in) user ID of the entity releasing the POST RUN state.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The release request was accepted by EcuM\nE_NOT_OK: The release request was not accepted by EcuM\nDescription Releases a POST RUN request previously done with a call to EcuM_RequestPOST_RUN. The\nservice is intended for implementing AUTOSAR ports.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09116)\n[SWS_EcuM_03026] ⌈If development error detection is enabled andEcuM_Release-\nPOST_RUN did not find a previous matching request for the provided user, then the\nfunction shall reportECUM_E_MISMATCHED_RUN_RELEASE to Det.⌋()\nConfiguration of EcuM_ReleasePOST_RUN: Refer to EcuM_UserType for more infor-\nmation about user IDs and their generation.\n\n### Shutdown Management\n\n\n\n#### EcuM_SelectShutdownTarget\n\n[SWS_EcuM_02822] ⌈\nService Name EcuM_SelectShutdownTarget\nSyntax Std_ReturnType EcuM_SelectShutdownTarget (\nEcuM_ShutdownTargetType shutdownTarget,\nEcuM_ShutdownModeType shutdownMode\n)\nService ID [hex] 0x06\nSync/Async Synchronous\nReentrancy Reentrant\nshutdownTarget The selected shutdown target.Parameters (in)\nshutdownMode The identfier of a sleep mode (if target is ECUM_SHUTDOWN_\nTARGET_SLEEP) or a reset mechanism (if target is ECUM_\nSHUTDOWN_TARGET_RESET) as defined by configuration.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The new shutdown target was set\nE_NOT_OK: The new shutdown target was not set\nDescription EcuM_SelectShutdownTarget selects the shutdown target. EcuM_SelectShutdownTarget is\npart of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09114, SRS_ModeMgm_09128, SRS_ModeMgm_09235)\n110 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_00624] ⌈The EcuM_SelectShutdownTarget function shall set the shut-\ndown target to the value of the shutdownTarget parameter.⌋(SRS_ModeMgm_09114,\nSRS_ModeMgm_09235)\n[SWS_EcuM_02185] ⌈The parameter mode of the function EcuM_SelectShutdown\nTarget shall be the identifier of a sleep or reset mode. The mode parameter shall\nonly be used if the target parameter equals ECUM_SHUTDOWN_TARGET_SLEEP or\nECUM_SHUTDOWN_TARGET_RESET. In all other cases, it shall be ignored. Only\nsleep or reset modes that are defined at configuration time and are stored in the Ecu\nMCommonConfiguration container (see ECUC_EcuM_00181) are allowed as parame-\nters.⌋(SRS_ModeMgm_09114)\n[SWS_EcuM_02585] ⌈EcuM_SelectShutdownTarget shall not initiate any setup activi-\nties but only store the value for later use in the SHUTDOWN or SLEEP phase.⌋(SRS_-\nModeMgm_09114)\nImplementation hint: The ECU Manager module does not define any mechanism to\nresolve conflicts arising from requests from different sources. The shutdown target is\nalways the last value set.\n\n#### EcuM_GetShutdownTarget\n\n[SWS_EcuM_02824] ⌈\nService Name EcuM_GetShutdownTarget\nSyntax Std_ReturnType EcuM_GetShutdownTarget (\nEcuM_ShutdownTargetType* shutdownTarget,\nEcuM_ShutdownModeType* shutdownMode\n)\nService ID [hex] 0x09\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nshutdownTarget One of these values is returned: ECUM_SHUTDOWN_TARGET_\nSLEEP ECUM_SHUTDOWN_TARGET_RESET ECUM_\nSHUTDOWN_TARGET_OFF\nParameters (out)\nshutdownMode If the out parameter \"shutdownTarget\" is ECUM_SHUTDOWN_\nTARGET_SLEEP , sleepMode tells which of the configured sleep\nmodes was actually chosen. If \"shutdownTarget\" is ECUM_\nSHUTDOWN_TARGET_RESET, sleepMode tells which of the\nconfigured reset modes was actually chosen.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service has failed, e.g. due to NULL pointer\nbeing passed\nDescription EcuM_GetShutdownTarget returns the currently selected shutdown target as set by EcuM_\nSelectShutdownTarget. EcuM_GetShutdownTarget is part of the ECU Manager Module port\ninterface.\n▽\n111 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09128, SRS_ModeMgm_09235)\n[SWS_EcuM_02788] ⌈If the pointer to the shutdownMode parameter is NULL, EcuM_\nGetShutdownTarget shall simply ignore the shutdownMode parameter. If Development\nError Detection is activated,EcuM_GetShutdownTarget shall send the ECUM_E_\nPARAM_POINTER development error to the DET module.⌋()\n\n#### EcuM_GetLastShutdownTarget\n\n[SWS_EcuM_02825] ⌈\nService Name EcuM_GetLastShutdownTarget\nSyntax Std_ReturnType EcuM_GetLastShutdownTarget (\nEcuM_ShutdownTargetType* shutdownTarget,\nEcuM_ShutdownModeType* shutdownMode\n)\nService ID [hex] 0x08\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nshutdownTarget One of these values is returned: ECUM_SHUTDOWN_TARGET_\nSLEEP ECUM_SHUTDOWN_TARGET_RESET ECUM_\nSHUTDOWN_TARGET_OFF\nParameters (out)\nshutdownMode If the out parameter \"shutdownTarget\" is ECUM_SHUTDOWN_\nTARGET_SLEEP , sleepMode tells which of the configured sleep\nmodes was actually chosen. If \"shutdownTarget\" is ECUM_\nSHUTDOWN_TARGET_RESET, sleepMode tells which of the\nconfigured reset modes was actually chosen.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service has failed, e.g. due to NULL pointer\nbeing passed\nDescription EcuM_GetLastShutdownTarget returns the shutdown target of the previous shutdown process.\nEcuM_GetLastShutdownTarget is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09128, SRS_ModeMgm_09235)\n[SWS_EcuM_02156] ⌈EcuM_GetLastShutdownTarget shall return the ECU state from\nwhich the last wakeup or power up occurred in the shutdownTarget parameter. EcuM_\nGetLastShutdownTarget shall always return the same value until the next shutdown.⌋\n(SRS_ModeMgm_09235)\n[SWS_EcuM_02336] ⌈If the call of GetLastShutdownTarget() passes ECU_STATE_\nSLEEP in the parameter shutdownTarget, in the parameter shutdownMode it returns\nwhich of the configured sleep modes was actually chosen.\n112 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nIf the call of GetLastShutdownTarget() passes ECU_STATE_RESET in the parameter\nshutdownTarget, in the parameter sleepMode it returns which of the configured reset\nmodes was actually chosen.⌋()\n[SWS_EcuM_02337] ⌈If the pointer to the shutdownMode parameter is NULL, Ecu\nM_GetLastShutdownTarget shall simply ignore the shutdownMode parameter and re-\nturn the last shutdown target regardless of whether it was SLEEP or not. If Develop-\nment Error Detection is activated, EcuM_GetShutdownTarget shall send the ECUM_\nE_PARAM_POINTER development error to the DET module.⌋()\n[SWS_EcuM_02157] ⌈EcuM_GetLastShutdownTarget may return a shutdown target in\na STARTUP phase that set late in a previous SHUTDOWN phase. If so, implementation\nspecific limitations shall be clearly documented.⌋()\nRationale for [SWS_EcuM_02157]\nThe EcuM_GetLastShutdownTarget function is intended primarily for use in the\nECU STARTUP or RUN states. To simplify implementation, it is acceptable if the value\nis set in late shutdown phase for use during the next startup.\n\n#### EcuM_SelectShutdownCause\n\n[SWS_EcuM_04050] ⌈\nService Name EcuM_SelectShutdownCause\nSyntax Std_ReturnType EcuM_SelectShutdownCause (\nEcuM_ShutdownCauseType target\n)\nService ID [hex] 0x1b\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) target The selected shutdown cause.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The new shutdown cause was set\nE_NOT_OK: The new shutdown cause was not set\nDescription EcuM_SelectShutdownCause elects the cause for a shutdown. EcuM_SelectShutdownCause\nis part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_GetShutdownCause\n\n[SWS_EcuM_04051] ⌈\n113 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_GetShutdownCause\nSyntax Std_ReturnType EcuM_GetShutdownCause (\nEcuM_ShutdownCauseType* shutdownCause\n)\nService ID [hex] 0x1c\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) shutdownCause The selected cause of the next shutdown.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service has failed, e.g. due to NULL pointer\nbeing passed\nDescription EcuM_GetShutdownCause returns the selected shutdown cause as set by EcuM_Select\nShutdownCause. EcuM_GetShutdownCause is part of the ECU Manager Module port\ninterface.\nAvailable via EcuM.h\n⌋()\n\n### Wakeup Handling\n\n\n\n#### EcuM_GetPendingWakeupEvents\n\n[SWS_EcuM_02827] ⌈\nService Name EcuM_GetPendingWakeupEvents\nSyntax EcuM_WakeupSourceType EcuM_GetPendingWakeupEvents (\nvoid\n)\nService ID [hex] 0x0d\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value EcuM_WakeupSource\nType\nAll wakeup events\nDescription Gets pending wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_01156] ⌈EcuM_GetPendingWakeupEvents shall return wakeup\nevents which have been set to pending but not yet validated as bits set in aEcuM_-\nWakeupSourceType bitmask.⌋()\n114 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_02172] ⌈EcuM_GetPendingWakeupEvents shall be callable from in-\nterrupt context, from OS context and an OS-free context.⌋()\n[SWS_EcuM_03003] ⌈Caveat of EcuM_GetPendingWakeupEvents: This function\nonly returns the wakeup events with status ECUM_WKSTATUS_PENDING.⌋()\n\n#### EcuM_ClearWakeupEvent\n\n[SWS_EcuM_02828] ⌈\nService Name EcuM_ClearWakeupEvent\nSyntax void EcuM_ClearWakeupEvent (\nEcuM_WakeupSourceType sources\n)\nService ID [hex] 0x16\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) sources Events to be cleared\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Clears wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_02683] ⌈EcuM_ClearWakeupEvent clears all pending events passed as\na bit set in the sources in parameter (EcuM_WakeupSourceType bitmask) from the\ninternal pending wakeup events variable, the internal validated events variable and the\ninternal expired events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02807] ⌈EcuM_ClearWakeupEvent shall be callable from interrupt con-\ntext, from OS context and an OS-free context.⌋()\nIntegration note: The clearing of wakeup sources shall take place during ECU shut-\ndown prior to the call of Dem_Shutdown() and NvM_WriteAll(). This can be achieved\nby configuring BswMRules in the BswM module containing BswMActions of type\nBswMUserCallout with their BswMUserCalloutFunction parameter set to \"EcuM_Clear\nWakeupEvents(<sources>)\". Hereby <sources> needs to be derived from the Ecu\nMWakeupSourceIds in the EcuM configuration. These BswMRules must then be con-\nfigured in a way that they get triggered during ECU shutdown prior to the call of Dem_\nShutdown() and NvM_WriteAll().\n115 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### EcuM_GetValidatedWakeupEvents\n\n[SWS_EcuM_02830] ⌈\nService Name EcuM_GetValidatedWakeupEvents\nSyntax EcuM_WakeupSourceType EcuM_GetValidatedWakeupEvents (\nvoid\n)\nService ID [hex] 0x15\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value EcuM_WakeupSource\nType\nAll wakeup events\nDescription Gets validated wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_02533] ⌈EcuM_GetValidatedWakeupEvent shall return wakeup\nevents which have been set to validated in the internal validated events variable as\nbits set in aEcuM_WakeupSourceType bitmask.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02532] ⌈EcuM_GetValidatedWakeupEvent shall be callable from in-\nterrupt context, from OS context and an OS-free context.⌋()\n\n#### EcuM_GetExpiredWakeupEvents\n\n[SWS_EcuM_02831] ⌈\nService Name EcuM_GetExpiredWakeupEvents\nSyntax EcuM_WakeupSourceType EcuM_GetExpiredWakeupEvents (\nvoid\n)\nService ID [hex] 0x19\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) None\nParameters (inout) None\nParameters (out) None\n▽\n116 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nReturn value EcuM_WakeupSource\nType\nAll wakeup events: Returns all events that have been set and for\nwhich validation has failed. Events which do not need validation\nmust never be reported by this function.\nDescription Gets expired wakeup events.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09126)\n[SWS_EcuM_04076] ⌈EcuM_GetExpiredWakeupEvents shall return wakeup\nevents which have been set to validated in the internal expired events variable as bits\nset in aEcuM_WakeupSourceType bitmask.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02589] ⌈EcuM_GetExpiredWakeupEvents shall be callable from in-\nterrupt context, from OS context and an OS-free context.⌋()\n\n### Alarm Clock\n\n\n\n#### EcuM_SetRelWakeupAlarm\n\n[SWS_EcuM_04054] ⌈\nService Name EcuM_SetRelWakeupAlarm\nSyntax Std_ReturnType EcuM_SetRelWakeupAlarm (\nEcuM_UserType user,\nEcuM_TimeType time\n)\nService ID [hex] 0x22\nSync/Async Synchronous\nReentrancy Reentrant\nuser The user that wants to set the wakeup alarm.Parameters (in)\ntime Relative time from now in seconds.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nECUM_E_EARLIER_ACTIVE: An earlier alarm is already set\nDescription EcuM_SetRelWakeupAlarm sets a user’s wakeup alarm relative to the current point in time.\nEcuM_SetRelWakeupAlarm is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09186, SRS_ModeMgm_09190)\n[SWS_EcuM_04055] ⌈If the relative time from now is earlier than the current wakeup\ntime, EcuM_SetRelWakeupAlarm shall update the wakeup time.⌋(SRS_ModeMgm_-\n09186)\n117 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_04056] ⌈If the relative time from now is later than the current wakeup\ntime, EcuM_SetRelWakeupAlarm shall not update the wakeup time and shall return\nECUM_E_EARLIER_ACTIVE.⌋(SRS_ModeMgm_09186)\n\n#### EcuM_SetAbsWakeupAlarm\n\n[SWS_EcuM_04057] ⌈\nService Name EcuM_SetAbsWakeupAlarm\nSyntax Std_ReturnType EcuM_SetAbsWakeupAlarm (\nEcuM_UserType user,\nEcuM_TimeType time\n)\nService ID [hex] 0x23\nSync/Async Synchronous\nReentrancy Reentrant\nuser The user that wants to set the wakeup alarm.Parameters (in)\ntime Absolute time in seconds. Note that, absolute alarms use\nknowledge of the current time.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nECUM_E_EARLIER_ACTIVE: An earlier alarm is already set\nECUM_E_PAST: The given point in time has already passed\nDescription EcuM_SetAbsWakeupAlarm sets the user’s wakeup alarm to an absolute point in time. EcuM_\nSetAbsWakeupAlarm is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09186, SRS_ModeMgm_09199)\n[SWS_EcuM_04058] ⌈If the time parameter is earlier than the current wakeup\ntime, EcuM_SetAbsWakeupAlarm shall update the wakeup time.⌋(SRS_ModeMgm_-\n09186)\n[SWS_EcuM_04059] ⌈If the time parameter is later than the current wakeup time,\nEcuM_SetAbsWakeupAlarm shall not update the wakeup time and shall return\nECUM_E_EARLIER_ACTIVE.⌋(SRS_ModeMgm_09186)\n[SWS_EcuM_04060] ⌈If the time parameter is earlier than now,EcuM_SetAbsWake-\nupAlarm shall not update the wakeup time and shall return ECUM_E_PAST.⌋(SRS_-\nModeMgm_09186)\n\n#### EcuM_AbortWakeupAlarm\n\n[SWS_EcuM_04061] ⌈\n118 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_AbortWakeupAlarm\nSyntax Std_ReturnType EcuM_AbortWakeupAlarm (\nEcuM_UserType user\n)\nService ID [hex] 0x24\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) user The user that wants to cancel the wakeup alarm.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nECUM_E_NOT_ACTIVE: No owned alarm found\nDescription Ecum_AbortWakeupAlarm aborts the wakeup alarm previously set by this user. EcuM_Abort\nWakeupAlarm is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_GetCurrentTime\n\n[SWS_EcuM_04062] ⌈\nService Name EcuM_GetCurrentTime\nSyntax Std_ReturnType EcuM_GetCurrentTime (\nEcuM_TimeType* time\n)\nService ID [hex] 0x25\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) time Absolute time in seconds since battery connect.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: time points to NULL or the module is not initialized\nDescription EcuM_GetCurrentTime returns the current value of the EcuM clock (i.e. the time since battery\nconnect). EcuM_GetCurrentTime is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_GetWakeupTime\n\n[SWS_EcuM_04063] ⌈\n119 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_GetWakeupTime\nSyntax Std_ReturnType EcuM_GetWakeupTime (\nEcuM_TimeType* time\n)\nService ID [hex] 0x26\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) time Absolute time in seconds for next wakeup. 0xFFFFFFFF means\nno active alarm.\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: time points to NULL or the module is not initialized\nDescription EcuM_GetWakeupTime returns the current value of the master alarm clock (the minimum\nabsolute time of all user alarm clocks). EcuM_GetWakeupTime is part of the ECU Manager\nModule port interface.\nAvailable via EcuM.h\n⌋()\n\n#### EcuM_SetClock\n\n[SWS_EcuM_04064] ⌈\nService Name EcuM_SetClock\nSyntax Std_ReturnType EcuM_SetClock (\nEcuM_UserType user,\nEcuM_TimeType time\n)\nService ID [hex] 0x27\nSync/Async Synchronous\nReentrancy Reentrant\nuser User that wants to set the clockParameters (in)\ntime Absolute time in seconds since battery connect.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The service has succeeded\nE_NOT_OK: The service failed\nDescription EcuM_SetClock sets the EcuM clock time to the provided value. This API is useful for testing\nthe alarm services; Alarms that take days to expire can be tested. EcuM_SetClock is part of the\nECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_ModeMgm_09194)\n120 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Miscellaneous\n\n\n\n#### EcuM_SelectBootTarget\n\n[SWS_EcuM_02835] ⌈\nService Name EcuM_SelectBootTarget\nSyntax Std_ReturnType EcuM_SelectBootTarget (\nEcuM_BootTargetType target\n)\nService ID [hex] 0x12\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) target The selected boot target.\nParameters (inout) None\nParameters (out) None\nReturn value Std_ReturnType E_OK: The new boot target was accepted by EcuM\nE_NOT_OK: The new boot target was not accepted by EcuM\nDescription EcuM_SelectBootTarget selects a boot target. EcuM_SelectBootTarget is part of the ECU\nManager Module port interface.\nAvailable via EcuM.h\n⌋()\n[SWS_EcuM_02247] ⌈The service EcuM_SelectBootTarget shall store the se-\nlected target in a way that is compatible with the boot loader.⌋()\nExplanation for [SWS_EcuM_02247]: This may mean format AND location. The imple-\nmenter must ensure that the boot target information is placed at a safe location which\nthen can be evaluated by the boot manager after a reset.\n[SWS_EcuM_03000] ⌈Caveat for the functionEcuM_SelectBootTarget: This ser-\nvice may depend on the boot loader used. This service is only intended for use by\nSW-C’s related to diagnostics (boot management).⌋()\n\n#### EcuM_GetBootTarget\n\n[SWS_EcuM_02836] ⌈\nService Name EcuM_GetBootTarget\nSyntax Std_ReturnType EcuM_GetBootTarget (\nEcuM_BootTargetType * target\n)\nService ID [hex] 0x13\n▽\n121 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) target The currently selected boot target.\nReturn value Std_ReturnType E_OK: The service always succeeds.\nDescription EcuM_GetBootTarget returns the current boot target - see EcuM_SelectBootTarget. EcuM_Get\nBootTarget is part of the ECU Manager Module port interface.\nAvailable via EcuM.h\n⌋(SRS_BSW_00172)\n\n## Callback Definitions\n\n\n\n### Callbacks from Wakeup Sources\n\n\n\n#### EcuM_CheckWakeup\n\nSee EcuM_StartCheckWakeup ([SWS_EcuM_02929]) for a description of the\nEcuM_CheckWakeup function.\nThis serviceEcuM_CheckWakeup is a Callout of the ECU Manager module as well as\na Callback that wakeup sources invoke when they process wakeup interrupts.\n\n#### EcuM_SetWakeupEvent\n\n[SWS_EcuM_02826] ⌈\nService Name EcuM_SetWakeupEvent\nSyntax void EcuM_SetWakeupEvent (\nEcuM_WakeupSourceType sources\n)\nService ID [hex] 0x0c\nSync/Async Synchronous\nReentrancy Non-Reentrant, Non-Interruptible\nParameters (in) sources Value to be set\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription Sets the wakeup event.\nAvailable via EcuM.h\n⌋(SRS_BSW_00359, SRS_BSW_00360, SRS_BSW_00440, SRS_ModeMgm_-\n09098)\n122 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_01117] ⌈EcuM_SetWakeupEvent sets (OR-operation) all events\npassed as a bit set in the sources in parameter (EcuM_WakeupSourceType bitmask)\nin the internal pending wakeup events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n[SWS_EcuM_02707] ⌈EcuM_SetWakeupEvent shall start the wakeup validation\ntimeout timer according toWakeup Validation Timeout.⌋()\nSee section 7.6.4.3 Wakeup Validation Timeout.\n[SWS_EcuM_02867] ⌈If Development Error Reporting is turned on and parame-\nter \"sources\" contains an unknown (unconfigured) wakeup source,EcuM_SetWake-\nupEvent shall not update its internal variable and shall send the ECUM_E_UN-\nKNOWN_WAKEUP_SOURCE error message to the DET module instead.⌋()\n[SWS_EcuM_02171] ⌈EcuM_SetWakeupEvent must be callable from interrupt con-\ntext, from OS context and an OS-free context.⌋(SRS_BSW_00333)\n[SWS_EcuM_04138] ⌈EcuM_SetWakeupEvent shall ignore all events passed in the\nsources parameter that are not associated to the selected sleep mode.⌋()\n\n#### EcuM_ValidateWakeupEvent\n\n[SWS_EcuM_02829] ⌈\nService Name EcuM_ValidateWakeupEvent\nSyntax void EcuM_ValidateWakeupEvent (\nEcuM_WakeupSourceType sources\n)\nService ID [hex] 0x14\nSync/Async Synchronous\nReentrancy Reentrant\nParameters (in) sources Events that have been validated\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription After wakeup, the ECU State Manager will stop the process during the WAKEUP VALIDATION\nstate/sequence to wait for validation of the wakeup event.This API service is used to indicate to\nthe ECU Manager module that the wakeup events indicated in the sources parameter have\nbeen validated.\nAvailable via EcuM.h\n⌋(SRS_BSW_00359, SRS_BSW_00360, SRS_BSW_00440)\n[SWS_EcuM_04078] ⌈EcuM_ValidateWakeupEvent sets (OR-operation) all events\npassed as a bit set in the sources in parameter (EcuM_WakeupSourceType bitmask)\nin the internal validated wakeup events variable.⌋()\nSee also section 7.6.3 Internal Representation of Wakeup States.\n123 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n[SWS_EcuM_04079] ⌈EcuMValidateWakeupEvent shall invoke BswM_EcuM_Current\nWakeup with its sources parameter and state value ECUM_WKSTATUS_VALIDATED.⌋\n()\n[SWS_EcuM_02645] ⌈EcuM_ValidateWakeupEvent shall invoke ComM_EcuM_\nWakeUpIndication for each wakeup event if the EcuMComMChannelRef parameter\n(see ECUC_EcuM_00101) in the EcuMWakeupSource configuration container for the\ncorresponding wakeup source is configured.⌋()\n[SWS_EcuM_02868] ⌈If Development Error Reporting is turned on and the sources\nparameter contains an unknown (unconfigured) wakeup source,EcuM_Validate-\nWakeupEvent shall ignore the call and send the ECUM_E_UNKNOWN_WAKEUP_\nSOURCE error message to the DET module.⌋()\n[SWS_EcuM_02345] ⌈EcuM_ValidateWakeupEvent shall be callable from interrupt\ncontext and task context.⌋(SRS_BSW_00333)\n[SWS_EcuM_02790] ⌈EcuM_ValidateWakeupEvent shall return without effect for\nall sources except communication channels when called while the ECU Manager mod-\nule is in the RUN state.⌋()\n[SWS_EcuM_02791] ⌈EcuM_ValidateWakeupEvent shall have full effect in any\nECU Phase for those sources that correspond to a communication channel (see\n[SWS_EcuM_02645]).⌋()\n[SWS_EcuM_04140] ⌈EcuM_ValidateWakeupEvent shall invoke ComM_EcuM_\nPNCWakeUpIndication for each wakeup event and for every referenced PNC if at least\none EcuMComMPNCRef parameter (see ECUC_EcuM_00228) in the EcuMWakeup\nSource configuration container for the corresponding wakeup source is configured.⌋()\n\n## Callout Definitions\n\nCallouts are code fragments that must be added to the ECU Manager module during\nECU integration. The content of most callouts is hand-written code. The ECU Manager\nmodule configuration tool generates a default implementation for some callouts which\nis edited manually by the integrator. Conceptually, these callouts belong to the ECU\nintegration code.\n\n### Generic Callouts\n\n\n\n#### EcuM_ErrorHook\n\n[SWS_EcuM_02904] ⌈\n124 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_ErrorHook\nSyntax void EcuM_ErrorHook (\nuint16 reason\n)\nService ID [hex] 0x30\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) reason Reason for calling the error hook\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The ECU State Manager will call the error hook if the error codes \"ECUM_E_RAM_CHECK_\nFAILED\" or \"ECUM_E_CONFIGURATION_DATA_INCONSISTENT\" occur. In this situation it is\nnot possible to continue processing and the ECU must be stopped. The integrator may choose\nthe modality how the ECU is stopped, i.e. reset, halt, restart, safe state etc.\nAvailable via EcuM_Externals.h\n⌋() The ECU Manager module can invokeEcuM_ErrorHook: in all phases\nClass ofEcuM_ErrorHook: Mandatory\nEcuM_ErrorHook is integration code and the integrator is free to define additional\nindividual error codes to be passed as the reason parameter. These codes shall not\nconflict with the development and production error codes as defined in Table 7.1 and\nTable 7.13.1 nor with the standard error codes, i.e. E_OK, E_NOT_OK, etc.\n\n### Callouts from the STARTUP Phase\n\n\n\n#### EcuM_AL_SetProgrammableInterrupts\n\n[SWS_EcuM_04085] ⌈\nService Name EcuM_AL_SetProgrammableInterrupts\nSyntax void EcuM_AL_SetProgrammableInterrupts (\nvoid\n)\nService ID [hex] 0x4A\nSync/Async Asynchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\n▽\n125 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nDescription If the configuration parameter EcuMSetProgrammableInterrupts is set to true, this callout Ecu\nM_AL_SetProgrammableInterrupts is executed and shall set the interrupts on ECUs with\nprogrammable interrupts.\nAvailable via EcuM_Externals.h\n⌋()\n\n#### EcuM_AL_DriverInitZero\n\n[SWS_EcuM_02905] ⌈\nService Name EcuM_AL_DriverInitZero\nSyntax void EcuM_AL_DriverInitZero (\nvoid\n)\nService ID [hex] 0x31\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall provide driver initialization and other hardware-related startup activities for\nloading the post-build configuration data. Beware: Here only pre-compile and link-time\nconfigurable modules may be used.\nAvailable via EcuM_Externals.h\n⌋() The ECU Manager module invokesEcuM_AL_DriverInitZero early in the Pre\nOS Sequence (see section 7.3.2 Activities in StartPreOS Sequence)\nThe ECU Manager module configuration tool must generate a default implementation\nof theEcuM_AL_DriverInitZero callout ([SWS_EcuM_02905]) from the sequence\nof modules defined in the EcuMDriverInitListZero configuration container (see ECUC_\nEcuM_00114). See also [SWS_EcuM_02559] and [SWS_EcuM_02730].\n\n#### EcuM_DeterminePbConfiguration\n\n[SWS_EcuM_02906] ⌈\n126 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_DeterminePbConfiguration\nSyntax const EcuM_ConfigType* EcuM_DeterminePbConfiguration (\nvoid\n)\nService ID [hex] 0x32\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value const EcuM_ConfigType* Pointer to the EcuM post-build configuration which contains\npointers to all other BSW module post-build configurations.\nDescription This callout should evaluate some condition, like port pin or NVRAM value, to determine which\npost-build configuration shall be used in the remainder of the startup process. It shall load this\nconfiguration data into a piece of memory that is accessible by all BSW modules and shall\nreturn a pointer to the EcuM post-build configuration as a base for all BSW module post-build\nconfigrations.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokesEcuM_DeterminePbConfiguration early in the\nPreOS Sequence (see section 7.3.2 Activities in StartPreOS Sequence)\n\n#### EcuM_AL_DriverInitOne\n\n[SWS_EcuM_02907] ⌈\nService Name EcuM_AL_DriverInitOne\nSyntax void EcuM_AL_DriverInitOne (\nvoid\n)\nService ID [hex] 0x33\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall provide driver initialization and other hardware-related startup activities in\ncase of a power on reset.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_AL_DriverInitOne in the PreOS Sequence\n(see section 7.3.2 Activities in StartPreOS Sequence)\n127 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nThe ECU Manager module configuration tool must generate a default implementation\nof the EcuM_AL_DriverInitOne callout from the sequence of modules defined in the\nEcuMDriverInitListOne configuration container (see ECUC_EcuM_00111). See also\n[SWS_EcuM_02559] and [SWS_EcuM_02730].\nBesides driver initialization, the following initialization sequences should be considered\nin this block: MCU initialization according to AUTOSAR_SWS_Mcu_Driver chapter 9.1.\n\n#### EcuM_LoopDetection\n\n[SWS_EcuM_04137] ⌈\nService Name EcuM_LoopDetection\nSyntax void EcuM_LoopDetection (\nvoid\n)\nService ID [hex] 0x4B\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription If the configuration parameter EcuMResetLoopDetection is set to true, this callout EcuM_Loop\nDetection is called on every startup.\nAvailable via EcuM_Externals.h\n⌋()\n\n### Callouts from the SHUTDOWN Phase\n\n\n\n#### EcuM_OnGoOffOne\n\n[SWS_EcuM_02916] ⌈\nService Name EcuM_OnGoOffOne\nSyntax void EcuM_OnGoOffOne (\nvoid\n)\nService ID [hex] 0x3C\nSync/Async Synchronous\nReentrancy Non Reentrant\n▽\n128 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This call allows the system designer to notify that the GO OFF I state is about to be entered.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_OnGoOffOne on entry to the OffPreOS Se-\nquence (see section 7.4.1 Activities in the OffPreOS Sequence).\n\n#### EcuM_OnGoOffTwo\n\n[SWS_EcuM_02917] ⌈\nService Name EcuM_OnGoOffTwo\nSyntax void EcuM_OnGoOffTwo (\nvoid\n)\nService ID [hex] 0x3D\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This call allows the system designer to notify that the GO OFF II state is about to be entered.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_OnGoOffTwo on entry to the OffPostOS\nSequence (see section 7.4.2 Activities in the OffPostOS Sequence).\n\n#### EcuM_AL_SwitchOff\n\n[SWS_EcuM_02920] ⌈\n129 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_AL_SwitchOff\nSyntax void EcuM_AL_SwitchOff (\nvoid\n)\nService ID [hex] 0x3E\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall take the code for shutting off the power supply of the ECU. If the ECU cannot\nunpower itself, a reset may be an adequate reaction.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_AL_SwitchOff as the last activity in the Off\nPostOS Sequence (see section 7.4.2 Activities in the OffPostOS Sequence).\nNote: In some cases of HW/SW concurrency, it may happen that during the power\ndown in EcuM_AL_SwitchOff (endless loop) some hardware (e.g. a CAN transceiver)\nswitches on the ECU again. In this case the ECU may be in a deadlock until the\nhardware watchdog resets the ECU. To reduce the time until the hardware watchdog\nfixes this deadlock, the integrator code in EcuM_AL_SwitchOff as last action can limit\nthe endless loop and after a sufficient long time reset the ECU using Mcu_Perform\nReset().\n\n#### EcuM_AL_Reset\n\n[SWS_EcuM_04065] ⌈\nService Name EcuM_AL_Reset\nSyntax void EcuM_AL_Reset (\nEcuM_ResetType reset\n)\nService ID [hex] 0x4C\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) reset Type of reset to be performed.\nParameters (inout) None\nParameters (out) None\nReturn value None\n▽\n130 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nDescription This callout shall take the code for resetting the ECU.\nAvailable via EcuM_Externals.h\n⌋()\n\n### Callouts from the SLEEP Phase\n\n\n\n#### EcuM_EnableWakeupSources\n\n[SWS_EcuM_02918] ⌈\nService Name EcuM_EnableWakeupSources\nSyntax void EcuM_EnableWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x3F\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The ECU Manager Module calls EcuM_EnableWakeupSource to allow the system designer to\nnotify wakeup sources defined in the wakeupSource bitfield that SLEEP will be entered and to\nadjust their source accordingly.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_EnableWakeupSources in the GoSleep Se-\nquence (see section 7.5.1 Activities in the GoSleep Sequence)\n[SWS_EcuM_02546] ⌈The ECU Manager module shall derive the wakeup sources to\nbe enabled (and used as the wakeupSource parameter) from the EcuMWakeupSource\n(see ECUC_EcuM_00152) bitfield configured for the current sleep mode.⌋()\n\n#### EcuM_GenerateRamHash\n\n[SWS_EcuM_02919] ⌈\n131 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_GenerateRamHash\nSyntax void EcuM_GenerateRamHash (\nvoid\n)\nService ID [hex] 0x40\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription see EcuM_CheckRamHash\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_GenerateRamHash: in the Halt Sequence\njust before putting the ECU physically to sleep (see section 7.5.2 Activities in the Halt\nSequence).\n\n#### EcuM_SleepActivity\n\n[SWS_EcuM_02928] ⌈\nService Name EcuM_SleepActivity\nSyntax void EcuM_SleepActivity (\nvoid\n)\nService ID [hex] 0x41\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout is invoked periodically in all reduced clock sleep modes. It is explicitely allowed to\npoll wakeup sources from this callout and to call wakeup notification functions to indicate the\nend of the sleep state to the ECU State Manager.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_SleepActivity periodically during the Poll\nSequence (see section 7.5.3 Activities in the Poll Sequence) if the MCU is not halted\n(i.e. clock is reduced).\n132 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nNote: If called from the Poll sequence the EcuMcalls this callout functions in a blocking\nloop at maximum frequency. The callout implementation must ensure by other means\nif callout code shall be executed with a lower period. The integrator may choose any\nmethod to control this, e.g. with the help of OS counters, OS alarms, or Gpt timers.\n\n#### EcuM_StartCheckWakeup\n\n[SWS_EcuM_04096] ⌈\nService Name EcuM_StartCheckWakeup\nSyntax void EcuM_StartCheckWakeup (\nEcuM_WakeupSourceType WakeupSource\n)\nService ID [hex] 0x00\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) WakeupSource For this wakeup source the corresponding CheckWakeupTimer\nshall be started.\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This API is called by the ECU Firmware to start the CheckWakeupTimer for the corresponding\nWakeupSource. If EcuMCheckWakeupTimeout > 0 the CheckWakeupTimer for the Wakeup\nSource is started. If EcuMCheckWakeupTimeout <= 0 the API call is ignored by the EcuM.\nAvailable via EcuM_Externals.h\n⌋()\n\n#### EcuM_CheckWakeup\n\n[SWS_EcuM_02929] ⌈\nService Name EcuM_CheckWakeup\nSyntax void EcuM_CheckWakeup (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x42\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\n▽\n133 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nDescription This callout is called by the EcuM to poll a wakeup source. It shall also be called by the ISR of a\nwakeup source to set up the PLL and check other wakeup sources that may be connected to\nthe same interrupt.\nAvailable via EcuM_Externals.h\n⌋()\n[SWS_EcuM_04098] ⌈If EcuM_SetWakeupEvent is called for the corresponding\nwakeup source the CheckWakeupTimer is cancelled.⌋()\n\n#### EcuM_EndCheckWakeup\n\n[SWS_EcuM_02927] ⌈\nService Name EcuM_EndCheckWakeup\nSyntax void EcuM_EndCheckWakeup (\nEcuM_WakeupSourceType WakeupSource\n)\nService ID [hex] 0x00\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) WakeupSource For this wakeup source the corresponding CheckWakeupTimer\nshall be canceled.\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This API is called by any SW Module whose wakeup source is checked asynchronously (e.g.\nasynchronous Can Trcv Driver) and the Check of the Wakeup returns a negative Result (no\nWakeup by this Source). The API cancels the CheckWakeupTimer for the WakeupSource. If\nthe correponding CheckWakeupTimer is canceled the check of this wakeup source is finished.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_CheckWakeup periodically during the Poll\nSequence (see section 7.5.3 Activities in the Poll Sequence) if the MCU is not halted,\nor when handling a wakeup interrupt.\nNote: If called from the Poll sequence the EcuMcalls this callout functions in a blocking\nloop at maximum frequency. The callout implementation must ensure by other means\nif callout code shall be executed with a lower period. The integrator may choose any\nmethod to control this, e.g. with the help of OS counters, OS alarms, or Gpt timers.\n[SWS_EcuM_04080] ⌈The ECU Manager module shall derive the wakeup sources\nto be checked (and used as the wakeupSource parameter) from the EcuMWakeup\nSource (see ECUC_EcuM_00152) bitfield configured for the current sleep mode. The\nintegration code used for this callout must determine which wakeup sources must be\nchecked.⌋()\n134 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### EcuM_CheckRamHash\n\n[SWS_EcuM_02921] ⌈\nService Name EcuM_CheckRamHash\nSyntax uint8 EcuM_CheckRamHash (\nvoid\n)\nService ID [hex] 0x43\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value uint8 0: RAM integrity test failed\nelse: RAM integrity test passed\nDescription This callout is intended to provide a RAM integrity test. The goal of this test is to ensure that\nafter a long SLEEP duration, RAM contents is still consistent. The check does not need to be\nexhaustive since this would consume quite some processing time during wakeups. A well\ndesigned check will execute quickly and detect RAM integrity defects with a sufficient\nprobability. This specification does not make any assumption about the algorithm chosen for a\nparticular ECU. The areas of RAM which will be checked have to be chosen carefully. It\ndepends on the check algorithm itself and the task structure. Stack contents of the task\nexecuting the RAM check e.g. very likely cannot be checked. It is good practice to have the\nhash generation and checking in the same task and that this task is not preemptible and that\nthere is only little activity between hash generation and hash check. The RAM check itself is\nprovided by the system designer. In case of applied multi core and existence of Satellite-Ecu\nM(s): this API will be called by the Master-EcuM only.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_CheckRamHash early in the WakeupRestart\nSequence (see section 7.5.5 Activities in the WakeupRestart Sequence)\n[SWS_EcuM_02987] ⌈When the RAM check fails on wakeup the ECU Manager mod-\nule shall invokeEcuM_ErrorHook with the parameterECUM_E_RAM_CHECK_FAILED\n. It is left integrator’s discretion to allowEcuM_ErrorHook to relay the error to the DEM\nwhen he judges that the DEM will not write damaged NVRAM blocks.⌋(SRS_BSW_-\n00339)\nSee also section 7.5.2 Activities in the Halt Sequence.\n\n#### EcuM_DisableWakeupSources\n\n[SWS_EcuM_02922] ⌈\n135 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nService Name EcuM_DisableWakeupSources\nSyntax void EcuM_DisableWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x44\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The ECU Manager Module calls EcuM_DisableWakeupSources to set the wakeup source(s)\ndefined in the wakeupSource bitfield so that they are not able to wake the ECU up.\nAvailable via EcuM_Externals.h\n⌋()\nThe ECU Manager module invokes EcuM_DisableWakeupSources in the Wakeup\nRestart Sequence (see section 7.5.5 Activities in the WakeupRestart Sequence)\n[SWS_EcuM_04084] ⌈The ECU Manager module shall derive the wakeup sources\nto be disabled (and used as the wakeupSource parameter) from the internal pend-\ning events variable (NOT operation). The integration code used for this callout must\ndetermine which wakeup sources must be disabled.⌋()\n\n#### EcuM_AL_DriverRestart\n\n[SWS_EcuM_02923] ⌈\nService Name EcuM_AL_DriverRestart\nSyntax void EcuM_AL_DriverRestart (\nvoid\n)\nService ID [hex] 0x45\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout shall provide driver initialization and other hardware-related startup activities in the\nwakeup case.\nAvailable via EcuM_Externals.h\n⌋()\n136 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nThe ECU Manager module invokes EcuM_EcuM_AL_DriverRestart in the Wakeup\nRestart Sequence (see section 7.5.5 Activities in the WakeupRestart Sequence)\nThe ECU Manager module Configuration Tool shall generate a default implementation\nof the EcuM_AL_DriverRestart callout from the sequence of modules defined in the\nEcuMDriverRestartList configuration container (see ECUC_EcuM_00115). See also\n[SWS_EcuM_02561], [SWS_EcuM_02559] and [SWS_EcuM_02730].\n\n### Callouts from the UP Phase\n\n\n\n#### EcuM_StartWakeupSources\n\n[SWS_EcuM_02924] ⌈\nService Name EcuM_StartWakeupSources\nSyntax void EcuM_StartWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x46\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The callout shall start the given wakeup source(s) so that they are ready to perform wakeup\nvalidation.\nAvailable via EcuM_Externals.h\n⌋()\nThe EcuM Manager module invokes EcuM_StartWakeupSources in the WakeupVali-\ndation Sequence (see section 7.6.4 Activities in the WakeupValidation Sequence).\n\n#### EcuM_CheckValidation\n\n[SWS_EcuM_02925] ⌈\nService Name EcuM_CheckValidation\nSyntax void EcuM_CheckValidation (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x47\n▽\n137 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callout is called by the EcuM to validate a wakeup source. If a valid wakeup has been\ndetected, it shall be reported to EcuM via EcuM_ValidateWakeupEvent().\nAvailable via EcuM_Externals.h\n⌋()\nThe EcuM Manager module invokes EcuM_CheckValidation in the WakeupValidation\nSequence (see section 7.6.4 Activities in the WakeupValidation Sequence).\n\n#### EcuM_StopWakeupSources\n\n[SWS_EcuM_02926] ⌈\nService Name EcuM_StopWakeupSources\nSyntax void EcuM_StopWakeupSources (\nEcuM_WakeupSourceType wakeupSource\n)\nService ID [hex] 0x48\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) wakeupSource –\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription The callout shall stop the given wakeup source(s) after unsuccessful wakeup validation.\nAvailable via EcuM_Externals.h\n⌋()\nThe EcuM Manager module invokes EcuM_StopWakeupSources in the WakeupVali-\ndation Sequence (see section 7.6.4 Activities in the WakeupValidation Sequence).\n\n## Scheduled Functions\n\nThese functions are directly called by Basic Software Scheduler. The following func-\ntions shall have no return value and no parameter. All functions shall be non reentrant.\n138 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuM_MainFunction\n\n[SWS_EcuM_02837] ⌈\nService Name EcuM_MainFunction\nSyntax void EcuM_MainFunction (\nvoid\n)\nService ID [hex] 0x18\nDescription The purpose of this service is to implement all activities of the ECU State Manager while the\nOS is up and running.\nAvailable via SchM_EcuM.h\n⌋(SRS_BSW_00425, SRS_BSW_00373) To determine the period, the system de-\nsigner should consider:\n•The function will perform wakeup validation (see 7.8 Wakeup Validation Protocol).\nThe shortest validation timeout typically should limit the period.\n•As a rule of thumb, the period of this function should be approximately half as\nlong as the shortest validation timeout.\nEcuM_MainFunction should not be called from tasks that may invoke runnable entities.\n\n## Expected Interfaces\n\nIn this chapter all interfaces required from other modules are listed.\nThis chapter defines all interfaces which are required to fulfill the core functionality of\nthe module.\n[SWS_EcuM_02858] ⌈\nAPI Function Header File Description\nBswM_Deinit BswM.h Deinitializes the BSW Mode Manager.\nBswM_EcuM_CurrentWakeup BswM_EcuM.h Function called by EcuM to indicate the current state\nof a wakeup source.\nBswM_Init BswM.h Initializes the BSW Mode Manager.\nCanSM_StartWakeupSource CanSM.h This function shall be called by EcuM when a\nwakeup source shall be started.\nCanSM_StopWakeupSource CanSM.h This function shall be called by EcuM when a\nwakeup source shall be stopped.\nComM_EcuM_PNCWakeUpIndication ComM_EcuM.h Notification of a wake up on the corresponding\npartial network cluster.\nComM_EcuM_WakeUpIndication ComM_EcuM.h Notification of a wake up on the corresponding\nchannel.\n▽\n139 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nAPI Function Header File Description\nDem_Init Dem.h Initializes or reinitializes this module.\nDem_PreInit Dem.h Initializes the internal states necessary to process\nevents reported by BSW-modules.\nDem_Shutdown Dem.h Shuts down this module.\nGetResource Os.h –\nMcu_GetResetReason Mcu.h The service reads the reset type from the hardware,\nif supported.\nMcu_Init Mcu.h This service initializes the MCU driver.\nMcu_PerformReset Mcu.h The service performs a microcontroller reset.\nMcu_SetMode Mcu.h This service activates the MCU power modes.\nReleaseResource Os.h –\nSchM_Deinit SchM.h SchM_Deinit is used to finalize Basic Software\nScheduler part of the RTE of the core on which it is\ncalled. This service releases all system resources\nallocated by the Basic Software Scheduler part on\nthat core.\nSchM_Init SchM.h SchM_Init is intended to allocate and initialize\nsystem resources used by the Basic Software\nScheduler part of the RTE for the core on which it is\ncalled.\nShutdownOS Os.h –\nStartOS Os.h –\n⌋()\n\n### Optional Interfaces\n\nThis chapter defines all interfaces which are required to fulfill an optional functionality\nof the module.\n[SWS_EcuM_02859] ⌈\nAPI Function Header File Description\nAdc_Init Adc.h Initializes the ADC hardware units and driver.\nCan_Init Can.h This function initializes the module.\nCanTrcv_Init CanTrcv.h Initializes the CanTrcv module.\nDet_Init Det.h Service to initialize the Default Error Tracer.\nDet_ReportError Det.h Service to report development errors.\nEth_Init Eth.h Initializes the Ethernet Driver\nEthSwt_Init EthSwt.h Initializes the Ethernet Switch Driver\nEthTrcv_Init EthTrcv.h Initializes the Ethernet Transceiver Driver\nFls_Init Fls.h Initializes the Flash Driver.\nFr_Init Fr.h Initializes the Fr.\nFrTrcv_Init FrTrcv.h This service initializes the FrTrcv.\nGetCoreID Os.h The function returns a unique core identifier.\n▽\n140 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nAPI Function Header File Description\nGpt_Init Gpt.h Initializes the GPT driver.\nIcu_Init Icu.h This function initializes the driver.\nIoHwAb_Init<Init_Id> IoHwAb.h Initializes either all the IO Hardware Abstraction\nsoftware or is a part of the IO Hardware Abstraction.\nLin_Init Lin.h Initializes the LIN module.\nLinTrcv_Init LinTrcv.h Initializes the Lin Transceiver Driver module.\nOcu_Init Ocu.h Service for OCU initialization.\nPort_Init Port.h Initializes the Port Driver module.\nPwm_Init Pwm.h Service for PWM initialization.\nShutdownAllCores Os.h After this service the OS on all AUTOSAR cores is\nshut down. Allowed at TASK level and ISR level and\nalso internally by the OS. The function will never\nreturn. The function will force other cores into a\nshutdown.\nSpi_Init Spi.h Service for SPI initialization.\nStartCore Os.h It is not supported to call this function after Start\nOS(). The function starts the core specified by the\nparameter CoreID. The OUT parameter allows the\ncaller to check whether the operation was\nsuccessful or not. If a core is started by means of\nthis function StartOS shall be called on the core.\nWdg_Init Wdg.h Initializes the module.\nWdgM_PerformReset WdgM.h Instructs the Watchdog Manager to cause a\nwatchdog reset.\n⌋()\n\n### Configurable interfaces\n\n\n\n#### Callbacks from the STARTUP phase\n\n[SWS_EcuM_91001] ⌈\nService Name EcuM_AL_DriverInitBswM_<x>\nSyntax void EcuM_AL_DriverInitBswM_<x> (\nvoid\n)\nService ID [hex] 0x28\nSync/Async Synchronous\nReentrancy Non Reentrant\nParameters (in) None\nParameters (inout) None\nParameters (out) None\nReturn value None\nDescription This callback shall provide BSW module initializations to be called by the BSW Mode Manager.\n▽\n141 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nAvailable via EcuM.h\n⌋()\nThe EcuM_AL_DriverInitBswM_<x> callbacks are called by the BSW Mode Manager\nduring initialization. The ECU Manager module configuration tool must generate a\ndefault implementation of the EcuM_AL_DriverInitBswM_<x> callbacks from the se-\nquence of modules defined in the EcuMDriverInitListBswM configuration container (see\nECUC_EcuM_00226). See also [SWS_EcuM_04142].\n[SWS_EcuM_04114] ⌈EcuM_AL_DriverInitBswM_<x> is generated for every config-\nured EcuMDriverInitListBswM. The name of the generated functions shall be EcuM_\nAL_DriverInitBswM_<x>, where <x> represents the short name of the EcuMDriverInit\nListBswM container.⌋()\n\n## Specification of the Port Interfaces\n\nThis chapter specifies the port interfaces and ports needed to access the ECU Man-\nager module over the VFB.\n\n### Ports and Port Interface for EcuM_ShutdownTarget Interface\n\n\n\n#### General Approach\n\nThe EcuM_ShutdownTarget client-server interface allows an SW-C to select a shut-\ndown target which will be respected during the next shutdown phase. Note that the\nECU Manager module does not offer a port interface to allow a SW-C to initiate shut-\ndown, however.\n\n#### Service Interfaces\n\n[SWS_EcuM_03011] ⌈\nName EcuM_ShutdownTarget\nComment A SW-C can select a shutdown target using this interface\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\n142 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nOperation GetLastShutdownTarget\nComment Returns the shutdown target of the previous shutdown\nVariation –\nshutdownTarget\nType EcuM_ShutdownTargetType\nDirection OUT\nComment The shutdown target of the previous shutdown\nVariation –\nshutdownMode\nType EcuM_ShutdownModeType\nDirection OUT\nComment The sleep mode (if target is ECUM_SHUTDOWN_TARGET_SLEEP) or the\nreset mechanism (if target is ECUM_SHUTDOWN_TARGET_RESET) of the\nshutdown\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation GetShutdownCause\nComment Returns the selected shutdown cause as set by the operation SelectShutdownCause.\nVariation –\nshutdownCause\nType EcuM_ShutdownCauseType\nDirection OUT\nComment The selected cause of the next shutdown\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation GetShutdownTarget\nComment Returns the currently selected shutdown target for the next shutdown as set by the operation\nSelectShutdownTarget.\nVariation –\nshutdownTarget\nType EcuM_ShutdownTargetType\nDirection OUT\nComment The shutdown target of the next shutdown\nVariation –\nshutdownMode\nType EcuM_ShutdownModeType\nDirection OUT\nComment The sleep mode (if target is ECUM_SHUTDOWN_TARGET_SLEEP) or the\nreset mechanism (if target is ECUM_SHUTDOWN_TARGET_RESET) of the\nshutdown\nParameters\nVariation –\n▽\n143 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n△\nPossible Errors E_OK\nE_NOT_OK\nOperation SelectShutdownCause\nComment –\nVariation –\nshutdownCause\nType EcuM_ShutdownCauseType\nDirection IN\nComment The selected shutdown cause\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation SelectShutdownTarget\nComment The SW-C selects the cause corresponding to the next shutdown target\nVariation –\nshutdownTarget\nType EcuM_ShutdownTargetType\nDirection IN\nComment The selected shutdown cause\nVariation –\nshutdownMode\nType EcuM_ShutdownModeType\nDirection IN\nComment The identfier of a sleep mode (if shutdownTarget is ECUM_SHUTDOWN_\nTARGET_SLEEP) or a reset mechanism (if shutdownTarget is ECUM_\nSHUTDOWN_TARGET_RESET) as defined by configuration.\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n[SWS_EcuM_02979] ⌈The shutdownMode parameter shall determine the specific\nsleep or reset mode (see ECUC_EcuM_00132) relevant to SelectShutdownTarget,\nGetShutdownTarget and GetLastShutdownTarget. The ECU Manager module shall\nonly use the shutdownMode parameter is if the shutdownTarget parameter is equal\nto ECUM_SHUTDOWN_TARGET_SLEEP or ECUM_SHUTDOWN_TARGET_RESET,\notherwise it shall be ignored.⌋()\n144 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Port Interface for EcuM_BootTarget Interface\n\n\n\n#### General Approach\n\nA SW-C that wants to select a boot target must require the client-server interface Ecu\nM_BootTarget.\n\n#### Service Interfaces\n\n[SWS_EcuM_03012] ⌈\nName EcuM_BootTarget\nComment A SW-C that wants to select a boot target must use the client-server interface EcuM_Boot\nTarget.\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\nOperation GetBootTarget\nComment Returns the current boot target\nVariation –\ntarget\nType EcuM_BootTargetType\nDirection OUT\nComment The currently selected boot target\nParameters\nVariation –\nPossible Errors E_OK\nOperation SelectBootTarget\nComment Selects a boot target\nVariation –\ntarget\nType EcuM_BootTargetType\nDirection IN\nComment The selected boot target\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n145 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### Port Interface for EcuM_AlarmClock Interface\n\n\n\n#### General Approach\n\nA SW-C that wants to use an alarm clock must require the client-server interface Ecu\nM_AlarmClock. The EcuM_AlarmClock interface uses port-defined argument values\nto identify the user that manages its alarm clock. See [SWS_Rte_1350] in the Specifi-\ncation of RTE [2] for a description of port-defined argument values.\n\n#### Service Interfaces\n\n[SWS_EcuM_04105] ⌈\nName EcuM_AlarmClock\nComment A SW-C that wants to use an alarm clock must use the client-server interface EcuM_Alarm\nClock.\nIsService true\nVariation {ecuc(EcuM/EcuMFlexGeneral/EcuMAlarmClockPresent)} == True\n\n# E_OK Operation successful\n\n\n\n# E_NOT_OK Operation failed\n\n\n\n# ECUM_E_EARLIER_\n\nACTIVE\nAn earlier alarm is already set\n\n# ECUM_E_PAST The desired point in time has already passed\n\nPossible Errors\n\n# ECUM_E_NOT_ACTIVE No active alarm found\n\nOperation AbortWakeupAlarm\nComment Aborts the wakeup alarm previously set by this user\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nECUM_E_NOT_ACTIVE\nOperation SetAbsWakeupAlarm\nComment Sets the user’s wakeup alarm to an absolute point in time\nVariation –\ntime\nType EcuM_TimeType\nDirection IN\nComment Absolute time in seconds. Note that, absolute alarms use knowledge of the\ncurrent time\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nECUM_E_EARLIER_ACTIVE\nECUM_E_PAST\n146 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nOperation SetClock\nComment Sets the EcuM clock time to the provided value\nVariation –\ntime\nType EcuM_TimeType\nDirection IN\nComment Absolute time in seconds since battery connect\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation SetRelWakeupAlarm\nComment Sets a user’s wakeup alarm relative to the current point in time\nVariation –\ntime\nType EcuM_TimeType\nDirection IN\nComment Relative time from now in seconds\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nECUM_E_EARLIER_ACTIVE\n⌋()\n\n### Port Interface for EcuM_Time Interface\n\n\n\n#### General Approach\n\nA SW-C that wants to use the time functionality of the EucM must require the client-\nserver interface EcuM_Time.\n\n#### Data Types\n\nThe EcuM_Time service does not have any specific data types.\n\n#### Service Interfaces\n\n[SWS_EcuM_04109] ⌈\n147 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuM_Time\nComment –\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\nOperation GetCurrentTime\nComment Returns the current value of the EcuM clock (i.e. the time in seconds since battery connect)\nVariation –\ntime\nType EcuM_TimeType\nDirection OUT\nComment Absolute time in seconds since battery connect\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation GetWakeupTime\nComment Returns the current value of the master alarm clock (the minimum absolute time of all user\nalarm clocks)\nVariation –\ntime\nType EcuM_TimeType\nDirection OUT\nComment Absolute time in seconds for next wakeup. 0xFFFFFFFF means no active\nalarm.\nParameters\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n\n### Port Interface for EcuM_StateRequest Interface\n\n[SWS_EcuM_04130] ⌈The ECU State Manager module shall provide System Services\nfor the following functionalities when the container EcuMModeHandling (see 10.2.1) is\navailable:\n•requesting RUN\n•releasing RUN\n•requesting POST_RUN\n•releasing POST_RUN\n⌋(SRS_ModeMgm_09116)\n148 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### General Approach\n\nA SW-C which needs to keep the ECU alive or needs to execute any operations before\nthe ECU is shut down shall require the client-server interface EcuM_StateRequest.\nThis interface uses port-defined argument values to identify the user that requests\nmodes. See [SWS_Rte_1350] for a description of port-defined argument values.\n\n#### Data Types\n\nNo data types are needed for this interface.\n\n#### Service Interfaces\n\n[SWS_EcuM_04131] ⌈\nName EcuM_StateRequest\nComment Interface to request a specific ECU state\nIsService true\nVariation –\n\n# E_OK Operation successfulPossible Errors\n\n\n\n# E_NOT_OK Operation failed\n\nOperation ReleasePOSTRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation ReleaseRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\nOperation RequestPOSTRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n149 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nOperation RequestRUN\nComment –\nVariation –\nPossible Errors E_OK\nE_NOT_OK\n⌋()\n\n### Port Interface for EcuM_CurrentMode Interface\n\n\n\n#### General Approach\n\n[SWS_EcuM_04132] ⌈The mode port of the ECU State Manager module shall declare\nthe following modes:\n•STARTUP\n•RUN\n•POST_RUN\n•SLEEP\n•SHUTDOWN\n⌋(SRS_ModeMgm_09116)\nThis definition is a simplified view of ECU Modes that applications do need to know. It\ndoes not restrict or limit in any way how application modes could be defined. Applica-\ntions modes are completely handled by the application itself.\n[SWS_EcuM_04133] ⌈Mode changes shall be notified to SW-Cs through the RTE\nmode ports when the mode change occurs.\nThis specification assumes that the port name is currentMode and that the direct API\nof RTE will be used. Under these conditions mode changes signaled by invoking\nRte_StatusType Rte_Switch_currentMode_currentMode(\nRte_ModeType_EcuM_Mode mode)\nwhere mode is the new mode to be notified. The value range is specified by the previ-\nous requirement. The return value shall be ignored.\nA SW-C which wants to be notified of mode changes should require the mode switch\ninterface EcuM_CurrentMode.⌋()\n150 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n#### Data Types\n\nThe mode declaration group EcuM_Mode represents the modes of the ECU State\nManager module that will be notified to the SW-Cs.\nModeDeclarationGroup EcuM_Mode {\n{ STARTUP , RUN, POST_RUN, SLEEP , SHUTDOWN }\ninitialMode = STARTUP\n};\n[SWS_EcuM_04107] ⌈\nName EcuM_Mode\nKind ModeDeclarationGroup\nCategory ALPHABETIC_ORDER\nInitial mode STARTUP\nOn transition value –\nPOST_RUN –\nRUN –\nSHUTDOWN –\nSLEEP –\nModes\nSTARTUP –\nDescription –\n⌋()\n\n#### Service Interfaces\n\n[SWS_EcuM_04108] ⌈\nName EcuM_CurrentMode\nComment Interface to read the current ECU mode\nIsService true\nVariation –\nModeGroup currentMode EcuM_Mode\n⌋()\n\n### Definition of the ECU Manager Service\n\nThis section provides guidance on the definition of the ECU Manager module Service.\nNote that these definitions can only be completed during ECU configuration (since\ncertain ECU Manager module configuration parameters determine the number of ports\n151 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nprovided by the ECU Manager module service). Also note a SW-C’s implementation\ndoes not depend on these definitions.\nIn an AUTOSAR system, there are ports both above and below the RTE. The ECU\nManager module service description defines ports provided to the RTE and the de-\nscriptions of every SW-C that uses this service must contain \"service ports\" which\nrequired these ECU Manager module ports from the RTE.\nThe EcuM provides the following ports:\n[SWS_EcuM_04111] ⌈\nName ShutdownTarget_{UserName}\nKind ProvidedPort Interface EcuM_ShutdownTarget\nDescription Provides an interface to SW-Cs to select a new shutdown target and query the current shutdown\ntarget.\nVariation UserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUserConfig/Ecu\nMFlexUser.SHORT -NAME)}\n⌋()\n[SWS_EcuM_04110] ⌈\nName BootTarget_{UserName}\nKind ProvidedPort Interface EcuM_BootTarget\nDescription Provides an interface to SW-Cs to select a new boot target and query the current boot target.\nVariation UserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUserConfig/Ecu\nMFlexUser.SHORT -NAME)}\n⌋()\n[SWS_EcuM_03017] ⌈\nName AlarmClock_{UserName}\nKind ProvidedPort Interface EcuM_AlarmClock\nDescription Provides to SW-Cs an alarm clock. The EcuM_AlarmClock port uses port-defined argument values\nto identify the user that manages its alarm clock.\nType EcuM_UserTypePort Defined\nArgument Value(s) Value {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUser\nConfig/EcuMFlexUser.value)}\nVariation {ecuc(EcuM/EcuMFlexGeneral/EcuMAlarmClockPresent)} == true\nUserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMAlarm\nClock.SHORT -NAME)}\n⌋()\n[SWS_EcuM_04113] ⌈\n152 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName time\nKind ProvidedPort Interface EcuM_Time\nDescription Provides the EcuM’s time service to SWCs\nVariation –\n⌋()\n[SWS_EcuM_04135] ⌈\nName StateRequest_{UserName}\nKind ProvidedPort Interface EcuM_StateRequest\nDescription Provides an interface to SW-Cs to request state changes of the ECU state. The port uses\nport-defined argument values to identify the user.\nType EcuM_UserTypePort Defined\nArgument Value(s) Value {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUser\nConfig/EcuMFlexUser.value)}\nVariation UserName = {ecuc(EcuM/EcuMConfiguration/EcuMFlexConfiguration/EcuMFlexUserConfig/Ecu\nMFlexUser.SHORT -NAME)}\n⌋()\n[SWS_EcuM_04112] ⌈\nName currentMode\nKind ProvidedPort Interface EcuM_CurrentMode\nDescription –\nVariation –\n⌋()\nThe EcuM provides the following types:\n[SWS_EcuM_91004] ⌈\nName EcuM_UserType\nKind Type\nDerived from uint8\nDescription Unique value for each user.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04102] ⌈\n153 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuM_TimeType\nKind Type\nDerived from uint32\nDescription This data type represents the time of the ECU Manager module.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[] ⌈\nName EcuM_BootTargetType\nKind Type\nDerived from uint8\nECUM_BOOT_TARGET_APP 0 The ECU will boot into the\napplication\nECUM_BOOT_TARGET_OEM_\nBOOTLOADER\n\n# The ECU will boot into the OEM\n\nbootloader\nRange\nECUM_BOOT_TARGET_SYS_\nBOOTLOADER\n\n# The ECU will boot into the system\n\nsupplier bootloader\nDescription This type represents the boot targets the ECU Manager module can be configured with. The\ndefault boot target is ECUM_BOOT_TARGET_OEM_BOOTLOADER.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04045] ⌈\nName EcuM_ShutdownCauseType\nKind Type\nDerived from uint8\nECUM_CAUSE_UNKNOWN 0 No cause was set.\nECUM_CAUSE_ECU_STATE 1 ECU state machine entered a\nstate for shutdown\nECUM_CAUSE_WDGM 2 Watchdog Manager detected a\nfailure\nRange\nECUM_CAUSE_DCM 3 Diagnostic Communication\nManager requests a shutdown\ndue to a service request\nDescription This type describes the cause for a shutdown by the ECU State Manager. It can be extended by\nconfiguration.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04101] ⌈\n154 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuM_ShutdownModeType\nKind Type\nDerived from uint16\n{ecuc(EcuM/EcuMConfiguration/\nEcuMFlexConfiguration/Ecu\nMResetMode.SHORT -NAME)}\n{256 + ecuc(EcuM/Ecu\nMConfiguration/Ecu\nMFlexConfiguration/\nEcuMResetMode.Ecu\nMResetModeId)}\nConfigured Reset ModesRange\n{ecuc(EcuM/EcuMConfiguration/\nEcuMCommonConfiguration/Ecu\nMSleepMode.SHORT -NAME)}\n{ecuc(EcuM/ Ecu\nMConfiguration/Ecu\nMCommon\nConfiguration/Ecu\nMSleepMode.Ecu\nMSleepModeId)}\nConfigured Sleep Modes\nDescription This data type represents the modes of the ECU Manager module.\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04136] ⌈\nName EcuM_ShutdownTargetType\nKind Type\nDerived from uint8\nECUM_SHUTDOWN_TARGET_\nSLEEP\n0x0 –\nECUM_SHUTDOWN_TARGET_\nRESET\n0x1 –\nRange\nECUM_SHUTDOWN_TARGET_\nOFF\n0x2 –\nDescription –\nVariation –\nAvailable via Rte_EcuM_Type.h\n⌋()\n[SWS_EcuM_04094] ⌈In the case of a MultiCore ECU, the EcuM AUTOSAR service\n(Standardized AUTOSAR Interfaces) may be offered on one or more cores.⌋()\nAlthough the EcuM service interfaces are available on every core (see section 7.9 Multi\nCore for details), the EcuC allows the provided ports to be bound to the interface on\na particular partition, and therefore to a particular core (see the Specification of ECU\nConfiguration [5]) and only that port will be visible to the VFB. In the case of Multi-Core,\nthis should be bound to the master core. SW-Cs and CDDs on the ECU that need to\naccess EcuM Services can access the master core via the IOC as generated by the\nRTE.\n[SWS_EcuM_04095] ⌈In the case of a MultiCore ECU, the EcuM C-API Interfaces\n(Standardized Interfaces) which are used by other BSW modules shall be offered in\nevery partition a EcuM runs in.⌋()\n155 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nThe C-API interfaces which are used by other BSW module to communicate with the\nEcuM are offered by every EcuM instance because every EcuM instance can do some\nindependent actions. If BSW modules want to use the EcuM but are inside partitions\nthat contain no own EcuM instance. These modules can use the SchM functions to\ncross partition boundaries.\n\n## API Parameter Checking\n\n[SWS_EcuM_03009] ⌈If Development Error Detection is enabled for this module, then\nall functions shall test input parameters and running conditions and use the following\nerror codes in an adequate way:\n•ECUM_E_UNINIT\n•ECUM_E_SERVICE_DISABLED\n•ECUM_E_PARAM_POINTER\n•ECUM_E_INVALID_PAR\nSpecific development errors are listed in the functions, where they apply.⌋(SRS_BSW_-\n00323)\n156 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Sequence Charts\n\n\n\n## State Sequences\n\nSequence charts showing the behavior of the ECU Manager module in various states\nare contained in the flow of the specification text. The following list shows all sequence\ncharts presented in this specification.\n•Figure 7.3 - STARTUP Phase\n•Figure 7.4 - StartPreOS Sequence\n•Figure 7.5 - StartPostOS Sequence\n•Figure 7.7 - SHUTDOWN Phase\n•Figure 7.8 - OffPreOS Sequence\n•Figure 7.9 - OffPostOS Sequence\n•Figure 7.10 - SLEEP Phase\n•Figure 7.11 - GoSleep Sequence\n•Figure 7.12 - Halt Sequence\n•Figure 7.13 - Poll Sequence\n•Figure 7.14 - WakeupRestart Sequence\n•Figure 7.16 - The WakeupValidation Sequence\n\n## Wakeup Sequences\n\nThe Wake-up Sequences show how a number of modules cooperate to put the ECU\ninto a sleep state to be able to wake up and startup the ECU when a wake up event\nhas occurred.\n\n### GPT Wakeup Sequences\n\nThe General Purpose Timer (GPT) is one of the possible wake up sources. Usually\nthe GPT is started before the ECU is put to sleep and the hardware timer causes an\ninterrupt when it expires. The interrupt wakes the microcontroller, and executes the\ninterrupt handler in the GPT module. It informs the ECU State Manager module that a\nGPT wake up has occurred. In order to distinguish different GPT channels that caused\nthe wake up, the integrator can assign a different wake up source identifier to each\nGPT channel. Figure 9.1 shows the corresponding sequence of calls.\n157 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nIntegration Code «Peripheral»\nGPT Hardware\n«module»\nMcu\n«module»\nEcuM\n«module»\nOs\n«module»\nGpt\n\u0001 \u0002 \u0004 \u0005 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \n \u000e \u000b \u000b \u000f \u0010 \u0004 \u0011 \u0006 \u0012 \b \u0013 \n \u000e \f \u0006 \t \u0012 \u0014 \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u000e \u0004 \u000e \u0014 \u000f \u0010 \u0004 \u0012 \u0014 \u0014 \n \f \u0006 \t \u0004 \u0005 \u0012 \u0004 \u0004 \u0005 \u0006 \u0015 \f \u0010 \u0016 \f \u0012 \u0017 \u0002 \u000b \u0010 \n \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014\n\u0012 \u0002 \u0004 \u0006 \f\n\u0018 \u0019 \u001a \u001b\n\u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f \u0011 \u0006 \b \u0012 \n \u0014 \u0006 \f \u0006\n\u001c\n\u0014 \b \u0005 \u0006 \t \n \u000b \u000e \u000f \u0016 \u0004 \u0012\n\u001d\n\u0006 \u0014 \u0015 \u000b \u0012 \b \u0006 \u0012 \u0002 \u0004 \u0006 \f \u0010 \b \b \n \f \f \u0006 \u000f \b \u0006 \u0010 \u0002 \u0012 \u000f \u0001 \u0007\n\u001e \u001f\n\u0012 \u0004\n !\nGOSLEEP\nHALT\n\" # \u0006 \b \n \u0004 \u000e \u0010 \u000f \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014 \u0012 \u0002 \u0004 \u0006 \f\n\u0018 \u0019 \u001a \u001b\n\u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f\n!\nWAKEUP I\nSLEEP\n\u001e\n\u0006 \u000b \u0006 \u0012 \u0014 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u0004 \u0010 \u0012 \u000b \u000b \u0010 \n \u0010 \u0004 \u0005 \u0006 \f \u0004 \u0012 \u0014\n\u001d\n\u0014 \u0004 \u0010 \f \n \u000f\n!\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nMcu_SetMode(Mcu_ModeType)\nDisableAllInterrupts()\nGpt_SetMode(Gpt_ModeType)\nGpt_SetMode(Gpt_ModeType)\nEnableAllInterrupts()\nEnableAllInterrupts()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources()\nGpt_CheckWakeup()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nReturn from\ninterrupt()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nGpt_EnableWakeup(Gpt_ChannelType)\nReleaseResource()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nWakeup\ninterrupt()\nMcu_SetMode()\nGpt_DisableWakeup(Gpt_ChannelType)\nMcu_SetMode()\nGpt_CheckWakeup(EcuM_WakeupSourceType)\nGpt_StartTimer(Gpt_ChannelType,\nGpt_ValueType)\nDisableAllInterrupts()\nMcu_SetMode(Mcu_ModeType)\nGpt_EnableWakeup()\nEcuM_CheckWakeup()\nGetResource()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nGpt_DisableWakeup()\nEcuM_SetWakeupEvent()\nEcuM_EnableWakeupSources()\nFigure 9.1: GPT wake up by interrupt\nIf the GPT hardware is capable of latching timer overruns, it is also possible to poll the\nGPT for wake ups as shown in Figure 9.2 .\n158 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \t \n \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \t \u000e \u000f \u0006 \u0007 \u0010 \u0007 \u0011 \t \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013\n\u0015\n\u0006 \u000e\n\u0016\n\u0006 \u0004 \u0011 \u0011 \u0005 \u0011\n\u0017 \u0018\n«module»\nEcuM\nIntegration Code «module»\nOs\n«module»\nMcu\n«module»\nGpt\nGOSLEEP\nSLEEP\nWAKEUP I\nloop WHILE no pending/validated events\nopt Wakeup detected\n\u0019\n\u0002 \u0004\n\u001a\n\u000b \u0007 \t\n\u0019\n\u000e \f \u0007\n\u001b \u001c\n\u000f \u0004 \t \u0013 \t \n \u0007\n\u0016\n\u0005 \u0002 \u0006 \u000e \u0002 \u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006 \u0005 \u0011\n\u0013 \u000e\n\u0016\n\u0007 \u000f \u000e \u001d \u0007 \u0006 \u0013 \u0012 \u0010\u0005 \u0011\n\u0017 \u0016\n\u000e \f \u0007\n\u0018\n\u001e \u0011 \t \n \u0005 \u0013\n\u0016\n\u000e \f \u0007\n\u0013 \u000e\n\u0015\n\t \u001d \u0012 \u0006 \u0007 \u0007\n\u001f\n\u0007 \u0002 \u0004 \t \u0005 \u000e \u0011 \u0002 \u000e \u0011 \t \u0005 \u0011 \u0004 \u0007 \u0013\n !\n\u0004 \t \u001d \u0005 \t \n\u0006 \u0007 \f \u0004 \u0002 \u0007 \f \u0002 \n \u000e \u0002 \u0014 \u0013 \u000f \u0007 \u0007 \f\n\u0018\n\"\n\u0007 \n \u0007 \u0012 \u0013 \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \u0006 \u0007 \u0013 \u000e \u0004 \u0006 \u0002 \u0007 \t \u000e \u0012 \n \n \u000e \u001d \u000e \t \n \u0007 \u0006\n\t \u0012 \u0013 \u0014 \u0013 \t \u000e \u0006 \u0004 \u0011\n\u0018\nEcuM_SetWakeupEvent()\nGpt_StartTimer(Gpt_ChannelType,\nGpt_ValueType)\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nGpt_EnableWakeup()\nGpt_DisableWakeup()\nGpt_CheckWakeup()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nDisableAllInterrupts()\nReleaseResource()\nMcu_SetMode()\nEcuM_EnableWakeupSources()\nGpt_EnableWakeup(Gpt_ChannelType)\nEnableAllInterrupts()\nGpt_DisableWakeup(Gpt_ChannelType)\nMcu_SetMode(Mcu_ModeType)\nEcuM_SleepActivity()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources()\nDisableAllInterrupts()\nEcuM_SleepActivity()\nMcu_SetMode()\nGpt_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nGetResource()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nGpt_SetMode(Gpt_ModeType)\nGpt_SetMode(Gpt_ModeType)\nEcuM_CheckWakeup()\nFigure 9.2: GPT wake up by polling\n159 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### ICU Wakeup Sequences\n\nThe Input Capture Unit (ICU) is another wake up source. In contrast to GPT, the ICU\ndriver is not itself the wake up source. It is just the module that processes the wake\nup interrupt. Therefore, only the driver of the wake up source can tell if it was re-\nsponsible for that wake up. This makes it necessary for EcuM_CheckWakeup (see [\nSWS_EcuM_02929]) to ask the module that is the actual wake up source. In order to\nknow which module to ask, the ICU has to pass the identifier of the wake up source to\nEcuM_CheckWakeup. For shared interrupts the Integration Code may have to check\nmultiple wake up sources within EcuM_CheckWakeup (see [SWS_EcuM_02929]). To\nthis end, the ICU has to pass the identifiers of all wake up sources that may have\ncaused this interrupt to EcuM_CheckWakeup. Note that, EcuM_WakeupSourceType\n(see 8.2.3 EcuM_WakeupSourceType) contains one bit for each wake up source, so\nthat multiple wake up sources can be passed in one call. Figure 9.3 shows the result-\ning sequence of calls. Since the ICU is only responsible for processing the wake up\ninterrupt, polling the ICU is not sensible. For polling the wake up sources have to be\nchecked directly as shown in Figure 38.\n160 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\nIntegration Code «module»\nWakeup Source\n«module»\nOs\n«module»\nMcu\n«module»\nIcu\n«Peripheral»\nICU Hardware\nHALT\nGOSLEEP\nSLEEP\nWAKEUP I\n\u0001 \u0002 \u0003 \u0002 \u0004 \u0005 \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \f \u0002 \u0005 \n \u000b \f \b \u0002 \u000e \n \u0004 \u0003 \u0003 \n \u000f \n \u000e \t \u0002 \f \u000e \u0004 \u0005 \u0010 \u0005 \u000e \n \f \u000b \u0011 \u0012\n\u0013 \u0014 \u0002 \b \u000b \u000e \u0015 \n \u0011 \b \n \u0011 \u000e \u0015 \u0011 \u000b \u0002 \u0005 \u0004 \u0016 \u000e \u0002 \f \u0017 \u0018 \u0019 \u001a \u0015 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0015 \n \u0011 \u0012\n\u001b\n\u0016 \u000e \t \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \u000f \u0015 \u0003 \u0003 \u0011 \n \u000e\n\u001c\n\u0002 \u0004 \b\n\u001d\n\u000b \u0015 \f \u0002 \n \u0004 \u0005 \f \u0002 \u0005 \n \u000b \f \b \u0002 \u0015 \u000e \u0015 \u0005 \u0011 \n \u000e \u0004 \u0005 \u0005 \u000b \f \u0002 \n \u000e \t \u0004 \u000e \u000e \t \u0002\n\u001e\n\f \n\n\u001f\n\f \u0004\n \n\u0016 \u0003 \n \u000f \b \n \u0011 \u000e \u0015 \u0011 \u000b \u0002 \u0005 \u0004 \u0016 \u000e \u0002 \f\n\u0017 \u0018 \u0019 \u001a \u0015 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0015 \n \u0011\n\u001c\n\u0002 \b \u0004 \u000b \u0005 \u0002 \f \u0002 ! \u0005 \b \t \u0002 \n \u000b \u0003 \u0015 \u0011\n\u001f\n\u000e \u0004 \u0010 \u0002 \u0005\n\u001e\n\u0003 \u0004 \b \u0002 \u0004 \u0016 \u000e \u0002 \f \n \b \b \u000b \f \f \u0002 \u0011 \b \u0002 \n \u0016 \u0004 \u0011\n\u001b\n\u0007 \u0001 \" \u0004 \u000e # \u0012\nIcu_DisableWakeup()\n<Module>_CheckWakeup()\nIcu_EnableWakeup()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources()\nReleaseResource()\nEnableAllInterrupts()\nEcuM_CheckWakeup()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nDisableAllInterrupts()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nEcuM_DisableWakeupSources()\nMcu_SetMode()\nIcu_DisableWakeup(Icu_ChannelType)\n<Module>_CheckWakeup\n(EcuM_WakeupSourceType)\nIcu_EnableWakeup(Icu_ChannelType)\nWakeup\ninterrupt()\nMcu_SetMode()\nactivate\nPLL()\nGetResource()\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nReturn from\ninterrupt()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nEnableAllInterrupts()\nEcuM_SetWakeupEvent()\nDisableAllInterrupts()\nFigure 9.3: ICU wake up by interrupt\n161 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### CAN Wakeup Sequences\n\nOn CAN a wake up can be detected by the transceiver or the communication con-\ntroller using either an interrupt or polling. Wake up source identifiers should be shared\nbetween transceiver and controller as the ECU State Manager module only needs to\nknow the network that has woken up and passes that on to the Communication Man-\nager module.\nIn interrupt case or in shared interrupt case it is not clear which specific wake up\nsource (CAN controller, CAN transceiver, LIN controller etc.) detected the wake\nup. Therefore the integrator has to assign the derived wakeupSource of EcuM_\nCheckWakeup(wakeupSource), which could stand for a shared interrupt or just for\nan interrupt channel, to specific wake up sources which are passed to CanIf_Check\nWakeup(WakeupSource). So here the parameters wakeupSource from EcuM_Check\nWakeup() could be different to WakeupSource of CanIf_CheckWakeup or they could\nequal. It depends on the hardware topology and the implementation in the integrator\ncode of EcuM_CheckWakeup().\nDuring CanIf_CheckWakeup(WakeupSource) the CAN Interface module (CanIf) will\ncheck if any device (CAN communication controller or transceiver) is configured with\nthe value of \"WakeupSource\". If this is the case, the device is checked for wake up via\nthe corresponding device driver module. If the device detected a wake up, the device\ndriver informs EcuM via EcuM_SetWakeupEvent(sources). The parameter \"sources\"\nis set to the configured value at the device. Thus it is set to the value CanIf_Check\nWakeup() was called with.\nMultiple devices might be configured with the same wake up source value. But if de-\nvices are connected to different bus medium and they are wake-able, it makes sense\nto configure them with different wake up sources.\nThe following CAN Wake-up Sequences are partly optional, because there is no spec-\nification for the \"Integration Code\". Thus it is implementation specific if e.g. during Ecu\nM_CheckWakeup() the CanIf is called to check the wake up source.\n162 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«Peripheral»\nCAN Transceiver\nHardware\n«Peripheral»\nCanController\n«module»\nCanTrcv\n«module»\nCan\n«module»\nCanIf\n«module»\nIcu\n«module»\nMcu\nIntegration\nCode\n«module»\nEcuM\n«module»\nOs\n\u0001 \u0002 \u0003 \u0002 \u0004 \u0005 \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \f \u0002 \u0005 \n \u000b \f \b \u0002 \u000e \n \u0004 \u0003 \u0003 \n \u000f \n \u000e \t \u0002 \f \u000e \u0004 \u0005 \u0010 \u0005 \u000e \n \f \u000b \u0011 \u0012\n\u0013 \u0014\n\u000e \t \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \u000f\n\u0015\n\u0003 \u0003 \u0011 \n \u000e\n\u0016\n\u0002 \u0004 \b\n\u0017\n\u000b\n\u0015\n\f \u0002 \n \u0004 \u0005 \f \u0002 \u0005 \n \u000b \f \b \u0002\n\u0015\n\u000e\n\u0015\n\u0005 \u0011 \n \u000e \u0004 \u0005 \u0005 \u000b \f \u0002 \n \u000e \t \u0004 \u000e \u000e \t \u0002\n\u0018\n\f \n\n\u0019\n\f \u0004\n\u001a \u0014\n\u0003 \n \u000f \b \n \u0011 \u000e\n\u0015\n\u0011 \u000b \u0002 \u0005 \u0004\n\u0014\n\u000e \u0002 \f\n\u001b \u001c \u001d \u001e \u0015\n\u0011 \u0005 \u000e \f \u000b \b \u000e\n\u0015\n\n \u0011\n\u0016\n\u0002 \b \u0004 \u000b \u0005 \u0002 \f \u0002\n\u001f\n\u0005 \b \t \u0002 \n \u000b \u0003\n\u0015\n\u0011\n\u0019\n\u000e \u0004 \u0010 \u0002 \u0005\n\u0018\n\u0003 \u0004 \b \u0002 \u0004\n\u0014\n\u000e \u0002 \f \n \b \b \u000b \f \f \u0002 \u0011 \b \u0002 \n\n\u0014\n\u0004 \u0011\n\u0013\n\u0007 \u0001\n \n\u0004 \u000e\n!\n\u0012\nHALT\n\" #\n\u0002 \b \u000b \u000e\n\u0015\n\n \u0011 \b \n \u0011 \u000e\n\u0015\n\u0011 \u000b \u0002 \u0005 \u0004\n\u0014\n\u000e \u0002 \f\n\u001b \u001c \u001d \u001e \u0015\n\u0011 \u0005 \u000e \f \u000b \b \u000e\n\u0015\n\n \u0011 \u0012\n \n\u0004 \u0011 \u0007\n$\n\u000f\n\u0015\n\u0003 \u0003 \t \u0004\n%\n\u0002 \b \u0004 \u0003 \u0003 \u0002 \n \n\u0004 \u0011\n\u0013 \u0014 &\n\u0007 \u0002 \u000e\n \n\n \u0011 \u000e \f \n \u0003 \u0003 \u0002 \f\n$\n\n \n \u0002 \u0004 \u0011 \n \n\u0004 \u0011\n\u0013 \u0014 &\n\u0007 \u0002 \u000e\n\u001e\n\f \u0004 \u0011 \u0005 \b \u0002\n\u0015 %\n\u0002 \f\n$\n\n \n \u0002 \u000f \t \u0002 \u0011\n\u0019\n\n\n\u0015\n\u0011\n\u0019\n\u000e \n \u0005 \u0003 \u0002 \u0002\n\u0018\n\u0012\nGOSLEEP\nSLEEP\nWAKEUP I\nWAKEUP \nVALIDATION\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nCanIf_SetTrcvWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nCanTrcv_SetWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nWakeup\ninterrupt()\nCanTrcv_SetWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nMcu_SetMode()\nactivate\nPLL()\nGetResource(uint8)\nCanIf_CheckWakeup(EcuM_WakeupSourceType):\nStd_ReturnType\nReturn from\ninterrupt()\nEnableAllInterrupts()\nCanTrcv_CheckWakeup(uint8):\nStd_ReturnType\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nReleaseResource(uint8)\nEnableAllInterrupts()\nCanIf_SetTrcvWakeupMode(uint8,\nCanTrcv_TrcvWakeupModeType)\nMcu_SetMode\n(Mcu_ModeType)\nDisableAllInterrupts()\nIcu_DisableWakeup(Icu_ChannelType)\nDisableAllInterrupts()\nIcu_EnableWakeup(Icu_ChannelType)\nFigure 9.4: CAN transceiver wake up by interrupt\n163 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nFigure 9.4 shows the CAN transceiver wakeup via interrupt. The interrupt is usually\nhandled by the ICU Driver as described in Chapter 9.2.2.\nA CAN controller wakeup by interrupt works similar to the GPT wakeup. Here the\ninterrupt handler and the CheckWakeup functionality are both encapsulated in the CAN\nDriver module, as shown in Figure 9.5 .\n«Peripheral»\nCanController\n«module»\nCanTrcv\n«module»\nIcu\nIntegration\nCode\n«module»\nCanIf\n«module»\nCan\n«module»\nMcu\n«module»\nEcuM\n«module»\nOs\n«Peripheral»\nCAN Transceiver\nHardware\nHALT\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e \u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t \u0013\nGOSLEEP\n\u0014 \f \t \u0015 \u0016 \u0017 \u0007 \u0018 \u0018 \u0019 \f \u001a \u0003 \u0004 \f \u0018 \u0018 \u0003 \u001b \u0014 \f \t \u001c \n \u001d \u0015 \u0003 \u0006 \u0014 \b \t \u0006 \u000e \b \u0018 \u0018 \u0003 \u000e \u0016 \b \u001b \u0003 \f \t \u001b \u0014 \f \t \u001c \n \u001d \u0015 \u0003 \u0006 \u0012 \u000e \f \t \u000b \u0004 \u0003 \u0007 \u001a \u0003 \u000e \u0016 \b \u001b \u0003 \u0017 \u0019 \u0003 \t \u001e \b \u0007 \t \u001e \u0006 \b \u000b \u0018 \u0003 \u0003 \u001f \u0013\nSLEEP\n\u001c \n \u0006 \u0019 \u0003 \u0015 \u0004 \u0019 \u0003 \u001b \u0005 \u0018 \u0003 \u000e \u0017 \u0007 \u0018 \u0018 \t \b \u0006  \u0003 \f \u0004 ! \u0005 \u0007 \u000e \u0003 \u001b \f \u000b \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0007 \u0006 \u0007 \u000b \t \b \u0006 \f \u000b \u000b \u0005 \u000e \u0003 \u001b \u0006 \u0019 \f \u0006 \u0006 \u0019 \u0003 \u001f \u000e \b \u001e \u000e \f \" \n \u0018 \b \u0017 \u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e\n\u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t  \u0003 \u0004 \f \u0005 \u000b \u0003 \u000e \u0003\n#\n\u000b \u0004 \u0019 \u0003 \u001b \u0005 \u0018 \u0007 \t \u001e \u0006 \f\n$\n\u0003 \u000b \u001f \u0018 \f \u0004 \u0003 \f \n \u0006 \u0003 \u000e \b \u0004 \u0004 \u0005 \u000e \u000e \u0003 \t \u0004 \u0003 \b \n \f \t \u001c \u0015\n%\n\u0014 \f \u0006\n&\n\u0013\nWAKEUP I\nWAKEUP \nVALIDATION\n%\n\u0003 \u0018 \u0003 \f \u000b \u0003 \u0015 \u0004 \u0019 \u0003 \u001b \u0005 \u0018 \u0003 \u000e \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0006 \b \f \u0018 \u0018 \b \u0017 \b \u0006 \u0019 \u0003 \u000e \u0006 \f \u000b\n$\n\u000b \u0006 \b \u000e \u0005 \t \u0013\nDisableAllInterrupts()\nEnableAllInterrupts()\nCanIf_CheckWakeup(EcuM_WakeupSourceType):\nStd_ReturnType\nReleaseResource(uint8)\nGetResource(uint8)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nDisableAllInterrupts()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nReturn from\ninterrupt()\nActivate\nPLL()\nMcu_SetMode()\nCan_CheckWakeup(Std_ReturnType, uint8)\nWakeup\ninterrupt()\nFigure 9.5: CAN controller wake up by interrupt\n164 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nWake up by polling is possible both for CAN transceiver and controller. The ECU State\nManager module will regularly check the CAN Interface module, which in turn asks\neither the CAN Driver module or the CAN Transceiver Driver module depending on the\nwake up source parameter passed to the CAN Interface module, as shown in Figure\n9.6 .\n165 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \t \n \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \t \u000e \u000f \u0006 \u0007 \u0010 \u0007 \u0011 \t \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \u0015 \u0006 \u000e \u0016 \u0006 \u0004 \u0011 \u0011 \u0005 \u0011 \u0017 \u0018\n«Peripheral»\nCAN Transceiver\nHardware\n«Peripheral»\nCanController\n«module»\nCanTrcv\n«module»\nCan\n«module»\nCanIf\n«module»\nIcu\n«module»\nMcu\nIntegration Code«module»\nEcuM\n«module»\nOs\nGOSLEEP\nSLEEP\nWAKEUP I\nWAKEUP \nVALIDATION\nloop WHILE no pending/validated events\nalt WakeupSource parameter of CanIf_CheckWakeup()\n[CAN Controller]\n[CAN Transceiver]\n\u0019\n\u0012 \u0011 \u000b\n\u001a \u001b\n\u0005 \n \n \n \u0012 \u0010 \u0007 \u0002 \u0012 \n \n \u0007 \f\n\u0019\n\u0012 \u0011\n\u001c\n\u0015\n\u001d\n\u000b \u0007 \t\n\u0019\n\u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006\n\u001a\n\u000e \f \u0007 \u0012 \u0011 \f\n\u0019\n\u0012 \u0011\n\u001c\n\u0015\n\u001d\n\u000b \u0007 \t\n\u001e\n\u0006 \u0012 \u0011 \u0013 \u0002 \u0007 \u0005 \u0010 \u0007 \u0006\n\u001a\n\u000e \f \u0007\n\u001b\n\n \u0007 \u0011 \u0017 \u000e \u0005 \u0011 \u0017 \t \u000e \u0013 \n \u0007 \u0007 \u000f \u0018\nopt Wakeup Detected\nopt Wakeup Detected\n\u001f \u0007 \n \u0007 \u0012 \u0013 \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \u0006 \u0007 \u0013 \u000e \u0004 \u0006 \u0002 \u0007 \t \u000e \u0012 \n \n \u000e\n\u001b\n\u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \t \u000e \u0006 \u0004 \u0011 \u0018\n\u001a\n\u0002 \u0004\n\u001d\n\u000b \u0007 \t\n\u001a\n\u000e \f \u0007\n !\n\u000f \u0004 \t \u0013 \t \n \u0007 \u0016 \u0005 \u0002 \u0006 \u000e \u0002 \u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006 \u0005 \u0011\n\u0013 \u000e \u0016 \u0007 \u000f \u000e\n\u001b\n\u0007 \u0006 \u0013 \u0012 \u0010 \u0005 \u0011 \u0017 \u0016 \u000e \f \u0007 \u0018\n\u001c\n\u0011 \t \n \u0005 \u0013 \u0016 \u000e \f \u0007\n\u0013 \u000e \u0015 \t\n\u001b\n\u0012 \u0006 \u0007 \u0007\n\"\n\u0007 \u0002 \u0004 \t \u0005 \u000e \u0011 \u0002 \u000e \u0011 \t \u0005 \u0011 \u0004 \u0007 \u0013\n# $\n\u0004 \t\n\u001b\n\u0005 \t \n\u0006 \u0007 \f \u0004 \u0002 \u0007 \f \u0002 \n \u000e \u0002 \u0014 \u0013 \u000f \u0007 \u0007 \f \u0018\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode()\nMcu_SetMode\n(Mcu_ModeType)\nCanTrcv_CheckWakeup(Std_ReturnType, uint8)\nCan_CheckWakeup(Std_ReturnType, uint8)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_SleepActivity()\nEnableAllInterrupts()\nEnableAllInterrupts()\nGetResource(uint8)\nReleaseResource(uint8)\nDisableAllInterrupts()\nDisableAllInterrupts()\nCanIf_CheckWakeup(EcuM_WakeupSourceType):\nStd_ReturnType\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode\n(Mcu_ModeType)\nFigure 9.6: CAN controller or transceiver wake up by polling\n166 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nAfter the detection of a wake up event from the CAN transceiver or controller by either\ninterrupt or polling, the wake up event can be validated (see [SWS_EcuM_02566]).\nThis is done by switching on the corresponding CAN transceiver and controller in\nEcuM_StartWakeupSources (see [SWS_EcuM_02924]). It depends on the used\nCAN transceivers and controllers, which function calls in Integrator Code EcuM_Start\nWakeupSource are necessary. In Figure 9.7 e.g. the needed function calls to start and\nstop the wake up sources from CAN state manager module are mentioned.\nNote that, although controller and transceiver are switched on, no CAN message will\nbe forwarded by the CAN interface module (CanIf) to any upper layer module.\nOnly when the corresponding PDU channel modes of the CanIf are set to \"Online\", it\nwill forward CAN messages.\nThe CanIf recognizes the successful reception of at least one message and\nrecords it as a successful validation. During validation the ECU State Manager\nmodule regularly checks the CanIf in Integrator Code EcuM_CheckValidation (see\n[SWS_EcuM_02925]).\nThe ECU State Manager module will, after successful validation, continue the normal\nstartup of the CAN network via the Communication Manager module.\nOtherwise, it will shutdown the CAN controller and transceiver in EcuM_StopWakeup\nSources (see [SWS_EcuM_02926]) and go back to sleep.\nThe resulting sequence is shown in Figure 9.7 .\n167 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«module»\nEcuM\n\u0001 \u0002 \u0004 \u0005 \u0006 \u0007 \b \t \t \n \u0007 \u0007 \u000b \b \f \n \u000e \f \u000f \u0010 \u000e \u0011 \u000f \u0012 \u0002 \u000f \u0007 \u000f \u0002 \u0010 \u000f \t \u000e \u0011 \n \u0010 \u0013 \u0014\n\u000e \t \u0012\n\u0015 \u0015\n\n \t \u0011 \f \u0014\n\u0015\n\n \t \n \u000f \n \n \u0010\n\u0016\n\n \u0007 \u0007 \u000e\n\u0017\n\n\u0018\nIntegration Code «module»\nMcu\n«module»\nIcu\n«module»\nCanIf\n«module»\nCanSM\nWAKEUP \nVALIDATION\nGOSLEEP\nloop Validate Wakeup Event\nalt Check Validation Result\n[SUCCESSFUL VALIDATION]\n[NO VALIDATION YET]\n[VALIDATION TIMEOUT]\nEcuM_StartWakeupSources(EcuM_WakeupSourceType)\nEcuM_ValidateWakeupEvent(EcuM_WakeupSourceType)\nStart validation\ntimeout()\nStop validation\ntimeout()\nEcuM_StopWakeupSources(EcuM_WakeupSourceType)\nCanIf_CheckValidation(EcuM_WakeupSourceType)\nCanSM_StopWakeupSource(Std_ReturnType,\nNetworkHandleType)\nEcuM_CheckValidation(EcuM_WakeupSourceType)\nDetect validation\ntimeout()\nCanSM_StartWakeupSource(Std_ReturnType,\nNetworkHandleType)\nFigure 9.7: CAN wake up validation\n168 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### LIN Wakeup Sequences\n\nFigure 9.8 shows the LIN transceiver wakeup via interrupt. The interrupt is usually\nhandled by the ICU Driver as described in Chapter 9.2.2 .\n169 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n«Peripher...\nLin Transceiver\nHardware\n«module»\nLinIf\n«module»\nLin\n«module»\nIcu\n«module»\nMcu\nIntegration\nCode\n«module»\nEcuM\n«module»\nOs\n«module»\nLinTrcv\nHALT\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \t \u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e \u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t \u0013\nGOSLEEP\n\u0011 \u0007 \t\n\u0014 \u0015 \u0016\n\u0007\n\u0017 \u0017\n\f\n\u0017\n\u000e \u0003 \f\n\u0018 \u0019 \u001a\n\f\n\u001b\n\u0003 \u0004 \f\n\u0017 \u0017\n\u0003\n\u0018\n\u0011 \u0007 \t\n\u001c\n\n\n\u001d \u001e\n\b \u0006 \b\n\u0014 \u0017\n\u0003 \u0003\n\u001f \u0016 \u001a\n\u0003 \t \u0004\n\u001a\n\f \t\n \n\u0007 \t\n \n\u0006 \b\n! \" \u001d # \" \u0015\n\u000b \u0006 \f \u0006 \u0003 \u0013\n\u001c\n\t\n\u0014 \u0017\n\u0003 \u0003\n\u001f\n\u000b \u0006 \f \u0006 \u0003 \u0006\n\u001a\n\u0003 \u0011\n\u001c ! #\n\b \t \u0006 \u000e \b\n\u0017 \u0017\n\u0003 \u000e \u0007 \u000b\n\u0016\n\f $ \u0003 \f %\n\u0017\n\u0003 \b \u000e \t \b \u0006 %\n\u0019\n\u0004 \b \t \n \u0007\n \n\u0005 \u000e \f \u0006 \u0007 \b \t \u0013\nSLEEP\n\u001c\n\n \u0006\n\u001a\n\u0003\n\u0014\n\u0004\n\u001a\n\u0003\n\u0018\n\u0005\n\u0017\n\u0003 \u000e\n\u0016\n\u0007\n\u0017 \u0017\n\t \b \u0006 % \u0003 \f \u0004 & \u0005 \u0007 \u000e \u0003\n\u0018\n\f \u000b \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0007 \u0006 \u0007 \u000b \t \b \u0006 \f \u000b \u000b \u0005 \u000e \u0003\n\u0018\n\u0006\n\u001a\n\f \u0006 \u0006\n\u001a\n\u0003\n\u001f\n\u000e \b\n \n\u000e \f ' \n\n\u0017\n\b\n\u0016\n\u0004 \b \t \u0006 \u0007 \t \u0005 \u0003 \u000b \f \n \u0006 \u0003 \u000e\n\u000f \u0010 \u0011 \u0012 \u0007 \t \u000b \u0006 \u000e \u0005 \u0004 \u0006 \u0007 \b \t % \u0003 \u0004 \f \u0005 \u000b \u0003 \u000e \u0003\n(\n\u000b \u0004\n\u001a\n\u0003\n\u0018\n\u0005\n\u0017\n\u0007 \t\n \n\u0006 \f $ \u0003 \u000b\n\u001f \u0017\n\f \u0004 \u0003 \f \n \u0006 \u0003 \u000e \b \u0004 \u0004 \u0005 \u000e \u000e \u0003 \t \u0004 \u0003 \b \n \f \t\n\u001c \u0014 ) #\n\f \u0006\n*\n\u0013\n)\n\u0003\n\u0017\n\u0003 \f \u000b \u0003\n\u0014\n\u0004\n\u001a\n\u0003\n\u0018\n\u0005\n\u0017\n\u0003 \u000e \u000e \u0003 \u000b \b \u0005 \u000e \u0004 \u0003 \u0006 \b \f\n\u0017 \u0017\n\b\n\u0016\n\b \u0006\n\u001a\n\u0003 \u000e \u0006 \f \u000b $ \u000b \u0006 \b \u000e \u0005 \t \u0013\nWAKEUP I\nEnableAllInterrupts()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nActivate\nPLL()\nEnableAllInterrupts()\nLinTrcv_CheckWakeup(uint8)\nMcu_SetMode()\nIcu_DisableWakeup(Icu_ChannelType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nLinIf_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nWakeup\ninterrupt()\nDisableAllInterrupts()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nIcu_EnableWakeup(Icu_ChannelType)\nReleaseResource(uint8)\nReturn from\ninterrupt()\nDisableAllInterrupts()\nGetResource(uint8)\nFigure 9.8: LIN transceiver wake up by interrupt\n170 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nAs shown in Figure 9.9 , the LIN controller wake up by interrupt works similar to the\nCAN controller wake up by interrupt. In both cases the Driver module encapsulates the\ninterrupt handler.\n«module»\nLinIf\n«module»\nLin\n«module»\nIcu\n«module»\nMcu\nIntegration Code«module»\nEcuM\n«module»\nOs\n«module»\nLinTrcv\n«Peripheral»\nLinController/UART\n\u0001 \u0002 \u0003 \u0002 \u0004 \u0005 \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \f \u0002 \u0005 \n \u000b \f \b \u0002 \u000e \n \u0004 \u0003 \u0003 \n \u000f \n \u000e \t \u0002 \f \u000e \u0004 \u0005 \u0010 \u0005 \u000e \n \f \u000b \u0011 \u0012\nHALT\n\u0013 \u0014 \u0011 \u0007 \u0015 \u000f \u0014 \u0003 \u0003 \u0004 \u0003 \f \u0002 \u0004 \n \u0016 \t \u0004 \u0017 \u0002 \b \u0004 \u0003 \u0003 \u0002 \n \u0013 \u0014 \u0011 \u0018 \u0019 \u001a \u001b \n \u000e \n \u0007 \u0003 \u0002 \u0002 \u001c \u000f \t \u0002 \u0011 \b \t \u0004 \u0011 \u001d \u0014 \u0011 \u001d \u000e \n \u001e \u001f \u001a  \u001f \u0015 \u0005 \u000e \u0004 \u000e \u0002 \u0012\n\u0018 \u0011 \u0007 \u0003 \u0002 \u0002 \u001c \u0005 \u000e \u0004 \u000e \u0002 \u000e \t \u0002 \u0013 \u0018 \u001e  \n \u0011 \u000e \f \n \u0003 \u0003 \u0002 \f \u0014 \u0005 \u000f \u0004 \u0010 \u0002 \u0004\n!\n\u0003 \u0002 \n \f \u0011 \n \u000e\n!\n\u0016 \b \n \u0011 \u0019 \u0014 \u001d \u000b \f \u0004 \u000e \u0014 \n \u0011 \u0012\n\u001e \n \u000e \t \u0014 \u0011 \u001d \u000e \n\n!\n\u0002 \n \n \u0011 \u0002 \u0014 \u0011 \u000e \t \u0014 \u0005 \b \u0004 \u0003 \u0003 \n \u000b \u000e \u0012\n\" \b \u000b \u0015 \u000f \u0014 \u0003 \u0003 \u0003 \u0004 \u000e \u0002 \f \u0014 \u0011 \u0019 \n \f #  \n # \u0015 \u0004\n!\n\n \u000b \u000e \u000e \t \u0002 \u000f \u0004 \u0010 \u0002 \u000b \u001c \u000f \t \u0014 \b \t \u0014 \u0011 \u000e \u000b \f \u0011 \u000f \u0014 \u0003 \u0003 \u0014 \u0011 \u0019 \n \f #\n\u0013 \u0014 \u0011 \u0007 \u0015\n$\n\u000f \t \u0014 \b \t \u000f \u0014 \u0003 \u0003 \u000e \t \u0002 \u0011 \b \u0004 \u0003 \u0003 \u0013 \u0014 \u0011 \u0018 \u0019 \u001a\n%\n\u0004 \u0010 \u0002 \u000b \u001c \u0012\nGOSLEEP\n\u0018 \u0019 \u000e \t \u0002 \u0007 \b \t \u0002 \n \u000b \u0003 \u0002 \f \u000f \u0014 \u0003 \u0003 \u0011 \n \u000e\n!\n\u0002 \u0004 \b & \u000b \u0014 \f \u0002 \n \u0004 \u0005 \f \u0002 \u0005 \n \u000b \f \b \u0002 \u0014 \u000e \u0014 \u0005 \u0011 \n \u000e \u0004 \u0005 \u0005 \u000b \f \u0002 \n \u000e \t \u0004 \u000e \u000e \t \u0002 \u001c \f \n \u001d \f \u0004 # \u0019 \u0003 \n \u000f \b \n \u0011 \u000e \u0014 \u0011 \u000b \u0002 \u0005 \u0004 \u0019 \u000e \u0002 \f\n' ( \u0013 ) \u0014 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0014 \n \u0011\n!\n\u0002 \b \u0004 \u000b \u0005 \u0002 \f \u0002 * \u0005 \b \t \u0002 \n \u000b \u0003 \u0014 \u0011 \u001d \u000e \u0004 \u0010 \u0002 \u0005 \u001c \u0003 \u0004 \b \u0002 \u0004 \u0019 \u000e \u0002 \f \n \b \b \u000b \f \f \u0002 \u0011 \b \u0002 \n \u0019 \u0004 \u0011 \u0018 \u0007 \u0001  \u0004 \u000e + \u0012\nSLEEP\n\" , \u0002 \b \u000b \u000e \u0014 \n \u0011 \b \n \u0011 \u000e \u0014 \u0011 \u000b \u0002 \u0005 \u0004 \u0019 \u000e \u0002 \f ' ( \u0013 ) \u0014 \u0011 \u0005 \u000e \f \u000b \b \u000e \u0014 \n \u0011 \u0012\nWAKEUP I\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nDisableAllInterrupts()\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nActivate\nPLL()\nWakeup\ninterrupt()\nDisableAllInterrupts()\nLin_CheckWakeup(uint8)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nReturn from\ninterrupt()\nMcu_SetMode(Mcu_ModeType)\nEnableAllInterrupts()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode()\nMcu_SetMode(Mcu_ModeType)\nLinIf_CheckWakeup(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEnableAllInterrupts()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nFigure 9.9: LIN controller wake up by interrupt\n171 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nWake up by polling is possible for LIN transceiver and controller. The ECU State Man-\nager module will regularly check the LIN Interface module, which in turn asks either the\nLIN Driver module or the LIN Transceiver Driver module, as shown in Figure 9.10 .\n«Peripheral»\nLin Transceiver\nHardware\n«module»\nLinIf\n«module»\nLin\n«module»\nIcu\n«module»\nMcu\nIntegration Code«module»\nEcuM\n«module»\nOs\n«module»\nLinTrcv\nGOSLEEP\nSLEEP\nWAKEUP I\nloop WHILE no pending/validated events\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0007 \u0002 \b \b \t \b \n \u000b \t \f \n \u000e \t \u000f \u000b \u0010 \t \b \b \u000b \f \u0001 \u0002 \u0003 \u0011 \u0012 \u0013 \u0014 \u0015 \u0016 \u0015 \u0004 \b \u000b \u000b \u0017 \u0007 \u000e \u000b \u0003 \u0010 \u000e \t \u0003 \u0018 \u0002 \u0003 \u0018 \u0016 \u0015 \u0019 \u001a \u0013 \u001b \u001a \u0005 \u001c \u0016 \t \u0016 \u000b \u001d\n\u0011 \u0003 \u0004 \b \u000b \u000b \u0017 \u001c \u0016 \t \u0016 \u000b \u0016 \u000e \u000b \u0001 \u0011 \u0019 \u001b \u0015 \u0003 \u0016 \n \u0015 \b \b \u000b \n \u0002 \u001c \u0007 \t\n\u001e\n\u000b \t\n\u001f\n\b \u000b \u0015 \n \u0003 \u0015 \u0016\n\u001f\n\n \u0010 \u0015 \u0003 \u0012 \u0002 \u0018\n \n\n \t \u0016 \u0002 \u0015 \u0003 \u001d\n\u0019 \u0015 \u0016 \u000e \u0002 \u0003 \u0018 \u0016 \u0015\n\u001f\n\u000b \f \u0015 \u0003 \u000b \u0002 \u0003 \u0016 \u000e \u0002 \u001c \u0010 \t \b \b \u0015\n \n\u0016 \u001d\nalt WakeupSource parameter of LinIf_CheckWakeup()\n!\n\u0010\n\"  \n\u0002 \n \u000b \u0016 \u000e \u000b \u0004 \u0010 \u000e \u000b \f\n \n\b \u000b \n \u0016 \u0015 \u0017 \n \u000b \u000f \u000b \u0003 \u0016 \u0015 \u0016 \u000e \u000b \n \u0016 \t \u001c\n\u001e\n\u001c \u0012 \n \u0015\n#\n\n \n\u0003 \u0003 \u0002 \u0003 \u0018 \u001d\n$ \u000b \b \u000b \t \u001c \u000b \u0004 \u0010 \u000e \u000b \f\n \n\b \u000b \n \n \u000b \u001c \u0015\n \n\n \u0010 \u000b \u0016 \u0015 \t \b \b \u0015 \u0007 \u0015 \u0016 \u000e \u000b \n \u0016 \t \u001c\n\u001e\n\u001c \u0016 \u0015 \n \n\u0003 \u001d\n\u0005 \u0010\n \n\u0013 \u0004 \u000b \u0016 \u0005 \u0015 \f \u000b\n% &\n\u0017\n \n\u0016 \u001c \u0016 \u000e \u000b\n#\n\u0002 \u0010 \n \u0015 \u0010 \u0015 \u0003 \u0016 \n \u0015 \b \b \u000b \n \u0002 \u0003\n\u001c \u0015\n#\n\u000b \u0017 \u0015 \u0007 \u000b \n \u001c \t \u000f \u0002 \u0003 \u0018\n#\n\u0015 \f \u000b \u001d \u0011 \u0003 \u0016 \u000e \u0002 \u001c\n#\n\u0015 \f \u000b\n\u001c \u0015 \u0012 \u0016 \u0007 \t \n \u000b \u000b\n'\n\u000b \u0010\n \n\u0016 \u0002 \u0015 \u0003 \u0010 \u0015 \u0003 \u0016 \u0002 \u0003\n \n\u000b \u001c\n( \u001f  \n\u0016 \u0007 \u0002 \u0016 \u000e\n\n \u000b \f\n \n\u0010 \u000b \f \u0010 \b \u0015 \u0010\n\u001e\n\u001c \u0017 \u000b \u000b \f \u001d\nGetResource(uint8)\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nLin_CheckWakeup(uint8)\nLinIf_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nReleaseResource(uint8)\nLinTrcv_CheckWakeup(uint8)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\n*\nFigure 9.10: LIN controller or transceiver wake up by polling\nNote that LIN does not require wakeup validation.\n172 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### FlexRay Wakeup Sequences\n\nFor FlexRay a wake up is only possible via the FlexRay transceivers. There are two\ntransceivers for the two different channels in a FlexRay cluster. They are treated as\nbelonging to one network and thus, there should be only one wake up source identifier\nconfigured for both channels. Figure 9.11 shows the FlexRay transceiver wakeup via\ninterrupt. The interrupt is usually handled by the ICU Driver as described in Chapter\n9.2.2.\n173 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\u0001 \u0002 \u0004 \u0005 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \n \u000e \u000b \u000b \u000f \u0010 \u0004 \u0011 \u0006 \u0012 \b \u0013 \n \u000e \f \u0006 \t \u0012 \u0014 \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u000e \u0004 \u000e \u0014 \u000f \u0010 \u0004 \u0012 \u0014 \u0014 \n \f \u0006 \t \u0004 \u0005 \u0012 \u0004 \u0004 \u0005 \u0006 \u0015 \f \u0010 \u0016 \f \u0012 \u0017 \u0002 \u000b \u0010 \n \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014 \u0012 \u0002 \u0004 \u0006 \f\n\u0018 \u0019 \u001a \u001b \u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f \u0011 \u0006 \b \u0012 \n \u0014 \u0006 \f \u0006 \u001c \u0014 \b \u0005 \u0006 \t \n \u000b \u000e \u000f \u0016 \u0004 \u0012 \u001d \u0006 \u0014 \u0015 \u000b \u0012 \b \u0006 \u0012 \u0002 \u0004 \u0006 \f \u0010 \b \b \n \f \f \u0006 \u000f \b \u0006 \u0010 \u0002 \u0012 \u000f \u0001 \u0007 \u001e \u001f \u0012 \u0004  !\n«Peripheral»\nFlexRay Transceiver\nHardware\n«module»\nOs\n«module»\nEcuM\nIntegration\nCode\n«module»\nMcu\n«module»\nIcu\n«module»\nFrIf\n«module»\nFr\n«module»\nFrTrcv\n«Peripheral»\nFlexRay\nController\nHALT\nGOSLEEP\nSLEEP\nWAKEUP I\nopt Wakeup detected\n\" # \u0006 \b \n \u0004 \u000e \u0010 \u000f \b \u0010 \u000f \u0004 \u000e \u000f \n \u0006 \u0014 \u0012 \u0002 \u0004 \u0006 \f \u0018 \u0019 \u001a \u001b \u000e \u000f \u0014 \u0004 \f \n \b \u0004 \u000e \u0010 \u000f !\n\u001b \u0005 \u000e \u0014 \b \u0012 \u000b \u000b \u0005 \u0012 \u0014 \u0004 \u0010 \u0011 \u0006 \f \u0006 \u0015 \u0006 \u0012 \u0004 \u0006 \t \u0002 \u0010 \f \u0011 \u0010 \u0004 \u0005 $ \u000b \u0006 # \u001e \u0012 % \b \u0005 \u0012 \u000f \u000f \u0006 \u000b \u0014 \u0010 \u000f\n\u0004 \u0005 \u0006 \u0014 \u0012 \u0017 \u0006 \u000f \u0006 \u0004 \n \u0010 \f \u001d\n&\n\u000e ! \u0006 ! $ \u000b \u0006 # \u001e \u0012 % \b \u000b \n \u0014 \u0004 \u0006 \f\n' (\n\u001e \u0006 \u000b \u0006 \u0012 \u0014 \u0006 \u0007 \b \u0005 \u0006 \t \n \u000b \u0006 \f \f \u0006 \u0014 \u0010 \n \f \b \u0006 \u0004 \u0010 \u0012 \u000b \u000b \u0010 \n \u0010 \u0004 \u0005 \u0006 \f \u0004 \u0012 \u0014 \u001d \u0014 \u0004 \u0010 \f \n \u000f !\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nEnableAllInterrupts()\nFrTrcv_CheckWakeupByTransceiver(uint8)\nGetResource()\nMcu_SetMode()\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nIcu_EnableWakeup(Icu_ChannelType)\nEcuM_CheckWakeup()\nIcu_EnableWakeup()\nIcu_DisableWakeup(Icu_ChannelType)\nFrIf_CheckWakeupByTransceiver()\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nMcu_SetMode()\nEcuM_SetWakeupEvent()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nIcu_DisableWakeup()\nDisableAllInterrupts()\nFrIf_CheckWakeupByTransceiver(uint8,\nFr_ChannelType)\nEcuM_DisableWakeupSources()\nEnableAllInterrupts()\nWakeup\ninterrupt()\nReturn from\ninterrupt()\nMcu_SetMode(Mcu_ModeType)\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nactivate\nPLL()\nReleaseResource()\nMcu_SetMode(Mcu_ModeType)\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nEcuM_EnableWakeupSources()\nFrTrcv_CheckWakeupByTransceiver()\nDisableAllInterrupts()\nFigure 9.11: FlexRay transceiver wake up by interrupt\n174 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nNote that in EcuM_CheckWakeup (see [SWS_EcuM_02929]) there need to be two\nseparate calls to FrIf_WakeupByTransceiver, one for each FlexRay channel.\n«Peripheral»\nFlexRay Transceiver\nHardware\n«Periphe...\nFlexRay\nController\n«module»\nFrTrcv\n«module»\nFr\n«module»\nFrIf\n«module»\nIcu\n«module»\nMcu\nIntegration\nCode\n«module»\nEcuM\n«module»\nOs\nGOSLEEP\nSLEEP\nWAKEUP I\nloop WHILE no pending/validated events\n\u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \t \n \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \t \u000e \u000f \u0006 \u0007 \u0010 \u0007 \u0011 \t \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \u0015 \u0006 \u000e \u0016 \u0006 \u0004 \u0011 \u0011 \u0005 \u0011 \u0017 \u0018\nopt Wakeup detected\n\u0019\n\u0002 \u0004\n\u001a\n\u000b \u0007 \t\n\u0019\n\u000e \f \u0007\n\u001b \u001c\n\u000f \u0004 \t \u0013 \t \n \u0007 \u0016 \u0005 \u0002 \u0006 \u000e \u0002 \u000e \u0011 \t \u0006 \u000e \n \n \u0007 \u0006 \u0005 \u0011\n\u0013 \u000e \u0016 \u0007 \u000f \u000e \u001d \u0007 \u0006 \u0013 \u0012 \u0010 \u0005 \u0011 \u0017 \u0016 \u000e \f \u0007 \u0018 \u001e \u0011 \t \n \u0005 \u0013 \u0016 \u000e \f \u0007\n\u0013 \u000e \u0015 \t \u001d \u0012 \u0006 \u0007 \u0007\n\u001f\n\u0007 \u0002 \u0004 \t \u0005 \u000e \u0011 \u0002 \u000e \u0011 \t \u0005 \u0011 \u0004 \u0007 \u0013\n !\n\u0004 \t \u001d \u0005 \t \n\u0006 \u0007 \f \u0004 \u0002 \u0007 \f \u0002 \n \u000e \u0002 \u0014 \u0013 \u000f \u0007 \u0007 \f \u0018\n\" \u0007 \n \u0007 \u0012 \u0013 \u0007 \u000b \u0002 \n \u0007 \f \u0004 \n \u0007 \u0006 \u0006 \u0007 \u0013 \u000e \u0004 \u0006 \u0002 \u0007 \t \u000e \u0012 \n \n \u000e \u001d \u000e \t \n \u0007 \u0006 \t \u0012 \u0013 \u0014 \u0013 \t \u000e \u0006 \u0004 \u0011 \u0018\n#\n\n \u0005 \u0013 \u0002 \u0012 \n \n \n \u0012 \u0013 \t \u000e\n!\n\u0007 \u0006 \u0007 \u000f \u0007 \u0012 \t \u0007 \f \u0015 \u000e \u0006\n!\n\u000e \t \n$\n\n \u0007\n\u001f\n\" \u0012\n%\n\u0002 \n \u0012 \u0011 \u0011 \u0007 \n \u0013 \u000e \u0011 \t \n \u0007\n\u0013 \u0012 \u0016 \u0007 \u0011 \u0007 \t \u001d \u000e \u0006 \u0014\n\u001b\n\u0005 \u0018 \u0007 \u0018\n$\n\n \u0007\n\u001f\n\" \u0012\n%\n\u0002 \n \u0004 \u0013 \t \u0007 \u0006\n\u001c &\nReleaseResource(RES_AUTOSAR_ECUM_<core#>)\nDisableAllInterrupts()\nFrTrcv_CheckWakeupByTransceiver(uint8)\nMcu_SetMode()\nEcuM_SetWakeupEvent()\nDisableAllInterrupts()\nEcuM_CheckWakeupEvent()\nMcu_SetMode()\nEcuM_EnableWakeupSources(EcuM_WakeupSourceType)\nEcuM_DisableWakeupSources(EcuM_WakeupSourceType)\nEcuM_CheckWakeup(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nEcuM_SleepActivity()\nFrIf_CheckWakeupByTransceiver()\nFrTrcv_CheckWakeupByTransceiver()\nFrIf_CheckWakeupByTransceiver(uint8,\nFr_ChannelType)\nGetResource()\nEcuM_SetWakeupEvent(EcuM_WakeupSourceType)\nMcu_SetMode(Mcu_ModeType)\nEnableAllInterrupts()\nReleaseResource()\nEnableAllInterrupts()\nGetResource(RES_AUTOSAR_ECUM_<core#>)\nFigure 9.12: FlexRay transceiver wake up by polling\n175 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n# Configuration specification\n\nIn general, this chapter defines configuration parameters and their clustering into con-\ntainers.\nChapters 10.1 and 10.2 specify the structure (containers) and the parameters of the\nmodule ECU Manager.\nChapter 10.3 specifies published information of the module ECU State Manager.\n\n## Common Containers and configuration parameters\n\nThe following chapters summarize all configuration parameters. The detailed meanings\nof the parameters describe Chapters 7 and Chapter 8.\nThe following containers contain various references to initialization structures of BSW\nmodules. NULL shall be a valid reference meaning ’no configuration data available’ but\nonly if the implementation of the initialized BSW module supports this.\n176 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuM\n\nEcuM: EcucModuleDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMGeneral: \nEcucParamConfContainerDef\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMFlexGeneral: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMFlexUserConfig: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMFlexEcucPartitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+subContainer\n+container\n+container\n+reference\n+subContainer\n+container\n+subContainer\nFigure 10.1: EcuM configuration overview\nModule SWS Item ECUC_EcuM_00225\nModule Name EcuM\nModule Description Configuration of the EcuM (ECU State Manager) module.\nPost-Build Variant\nSupport\ntrue\nSupported Config\nVariants\nVARIANT -POST -BUILD, VARIANT -PRE-COMPILE\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMConfiguration 1 This container contains the configuration (parameters)\nof the ECU State Manager.\nEcuMFlexGeneral 0..1 This container holds the general, pre-compile\nconfiguration parameters for the EcuMFlex.\nOnly applicable if EcuMFlex is implemented.\nEcuMGeneral 1 This container holds the general, pre-compile\nconfiguration parameters.\n177 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuMGeneral\n\nEcuMDevErrorDetect: \nEcucBooleanParamDef\ndefaultValue = false\nEcuMVersionInfoApi: \nEcucBooleanParamDef\ndefaultValue = false\nEcuMGeneral: \nEcucParamConfContainerDef\nEcuMMainFunctionPeriod: \nEcucFloatParamDef\nmin = 0\nmax = INF\n+parameter\n+parameter\n+parameter\nFigure 10.2: EcuMGeneral configuration overview\nSWS Item [ECUC_EcuM_00116]\nContainer Name EcuMGeneral\nParent Container EcuM\nDescription This container holds the general, pre-compile configuration\nparameters.\nConfiguration Parameters\nName EcuMDevErrorDetect [ECUC_EcuM_00108]\nParent Container EcuMGeneral\nDescription Switches the development error detection and notification on or off.\n• true: detection and notification is enabled.\n• false: detection and notification is disabled.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value false\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMMainFunctionPeriod [ECUC_EcuM_00121]\nParent Container EcuMGeneral\nDescription This parameter defines the schedule period of EcuM_MainFunction.\nUnit: [s]\nMultiplicity 1\nType EcucFloatParamDef\nRange ]0 .. INF[\nDefault Value\n178 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: ECU\nName EcuMVersionInfoApi [ECUC_EcuM_00149]\nParent Container EcuMGeneral\nDescription Switches the version info API on or off\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value false\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n179 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuMConfiguration\n\nEcuMConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nOsAppMode: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nEcuMDefaultAppMode: \nEcucReferenceDef\nEcuMConfigConsistencyHash: \nEcucIntegerParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMDriverInitListOne: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMSleepMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMDefaultShutdownTarget: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 1\nEcuMDriverInitListZero: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMOSResource: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nOsResource: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 0EcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMDriverRestartList: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\n+subContainer+subContainer\n+parameter\n+reference +destination\n+subContainer\n+destination\n+subContainer\n+subContainer\n+subContainer\n+subContainer\n+reference\n+subContainer\n+subContainer\n+subContainer\nFigure 10.3: EcuMConfiguration configuration overview\nSWS Item [ECUC_EcuM_00103]\nContainer Name EcuMConfiguration\nParent Container EcuM\nDescription This container contains the configuration (parameters) of the ECU\nState Manager.\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMCommon\nConfiguration\n\n# This container contains the common configuration\n\n(parameters) of the ECU State Manager.\n180 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nEcuMFlexConfiguration 0..1 This container contains the configuration (parameters)\nof the EcuMFlex.\nOnly applicable if EcuMFlex is implemented.\n\n### EcuMCommonConfiguration\n\nSWS Item [ECUC_EcuM_00181]\nContainer Name EcuMCommonConfiguration\nParent Container EcuMConfiguration\nDescription This container contains the common configuration (parameters) of the\nECU State Manager.\nConfiguration Parameters\nName EcuMConfigConsistencyHash [ECUC_EcuM_00102]\nParent Container EcuMCommonConfiguration\nDescription In the pre-compile and link-time configuration phase a hash value is\ngenerated across all pre-compile and link-time parameters of all BSW\nmodules.\nIn the post-build phase a hash value is generated across all\npre-compile and link-time parameters, except for parameters located in\nEcucParamConfContainerDef instances or subContainers which have\nbeen introduced at post-build configuration time.\nThis hash value is compared against each other and allows checking\nthe consistency of the entire configuration.\nNote: In systems which do not make use of post-build configurations\nthis parameter can be omitted.\nMultiplicity 0..1\nType EcucIntegerParamDef\nRange 0 ..\n\n# Default Value\n\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\n181 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMDefaultAppMode [ECUC_EcuM_00104]\nParent Container EcuMCommonConfiguration\nDescription The default application mode loaded when the ECU comes out of reset.\nMultiplicity 1\nType Reference to OsAppMode\nPost-Build Variant\nValue\ntrue\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\nName EcuMOSResource [ECUC_EcuM_00183]\nParent Container EcuMCommonConfiguration\nDescription This parameter is a reference to a OS resource which is used to bring\nthe ECU into sleep mode.\nIn case of multi core each core shall have an own OsResource.\nMultiplicity 1..*\nType Reference to OsResource\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDefaultShutdown\nTarget\n\n# This container describes the default shutdown target to\n\nbe selected by EcuM. The actual shutdown target may\nbe overridden by the EcuM_SelectShutdownTarget\nservice.\nEcuMDriverInitListOne 0..1 Container for Init Block I.\nThis container holds a list of modules to be initialized.\nEach module in the list will be called for initialization in\nthe list order.\nAll modules in this list are initialized before the OS is\nstarted and so these modules require no OS support.\n182 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nEcuMDriverInitListZero 0..1 Container for Init Block 0.\nThis container holds a list of modules to be initialized.\nEach module in the list will be called for initialization in\nthe list order.\nAll modules in this list are initialized before the post-build\nconfiguration has been loaded and the OS is initialized.\nTherefore, these modules may not use post-build\nconfiguration.\nEcuMDriverRestartList 0..1 List of modules to be initialized.\nEcuMSleepMode 1..256 These containers describe the configured sleep modes.\nThe names of these containers specify the symbolic\nnames of the different sleep modes.\nEcuMWakeupSource 1..32 These containers describe the configured wakeup\nsources.\n\n### EcuMDefaultShutdownTarget\n\nEcuMDefaultShutdownTarget: \nEcucEnumerationParamDef\nEcuMDefaultSleepModeRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nrequiresSymbolicNameValue = true\nEcuMSleepMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMDefaultShutdownTarget: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 1\nEcuMShutdownTargetSleep: \nEcucEnumerationLiteralDef\nEcuMShutdownTargetOff: \nEcucEnumerationLiteralDef\nEcuMShutdownTargetReset: \nEcucEnumerationLiteralDef\nEcuMDefaultResetModeRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nrequiresSymbolicNameValue = true\nEcuMResetMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\n+literal\n+literal\n+reference\n+reference\n+destination\n+destination\n+parameter\n+literal\nFigure 10.4: EcuMDefaultShutdownTarget configuration overview\nSWS Item [ECUC_EcuM_00105]\nContainer Name EcuMDefaultShutdownTarget\nParent Container EcuMCommonConfiguration\nDescription This container describes the default shutdown target to be selected by\nEcuM. The actual shutdown target may be overridden by the\nEcuM_SelectShutdownTarget service.\nConfiguration Parameters\n183 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMDefaultShutdownTarget [ECUC_EcuM_00107]\nParent Container EcuMDefaultShutdownTarget\nDescription This parameter describes the state part of the default shutdown target\nselected when the ECU comes out of reset. If\nEcuMShutdownTargetSleep is selected, the parameter\nEcuMDefaultSleepModeRef selects the specific sleep mode.\nMultiplicity 1\nType EcucEnumerationParamDef\nRange EcuMShutdownTargetOff Corresponds to\nECUM_SHUTDOWN_TARGET_OFF\nin EcuM_ShutdownTargetType.\nEcuMShutdownTarget\nReset\nCorresponds to\nECUM_SHUTDOWN_TARGET_RESET\nin EcuM_ShutdownTargetType. This\nliteral is only be applicable for\nEcuMFlex.\nEcuMShutdownTarget\nSleep\nCorresponds to\nECUM_SHUTDOWN_TARGET_SLEEP\nin EcuM_ShutdownTargetType.\nPost-Build Variant\nValue\ntrue\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\nName EcuMDefaultResetModeRef [ECUC_EcuM_00205]\nParent Container EcuMDefaultShutdownTarget\nDescription If EcuMDefaultShutdownTarget is EcuMShutdownTargetReset, this\nparameter selects the default reset mode. Otherwise this parameter\nmay be ignored.\nMultiplicity 0..1\nType Symbolic name reference to EcuMResetMode\nPost-Build Variant\nMultiplicity\ntrue\nPost-Build Variant\nValue\ntrue\nMultiplicity\nConfiguration Class\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\n184 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMDefaultSleepModeRef [ECUC_EcuM_00106]\nParent Container EcuMDefaultShutdownTarget\nDescription If EcuMDefaultShutdownTarget is EcuMShutdownTargetSleep, this\nparameter selects the default sleep mode. Otherwise this parameter\nmay be ignored.\nMultiplicity 0..1\nType Symbolic name reference to EcuMSleepMode\nPost-Build Variant\nMultiplicity\ntrue\nPost-Build Variant\nValue\ntrue\nMultiplicity\nConfiguration Class\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nValue Configuration\nClass\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nScope / Dependency scope: local\nNo Included Containers\n\n### EcuMDriverInitListOne\n\nEcuMDriverInitListOne: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMDriverInitListZero: \nEcucParamConfContainerDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\n+subContainer\n+subContainer\n+subContainer\n+subContainer\nFigure 10.5: EcuMInitLists configuration overview\nSWS Item [ECUC_EcuM_00111]\nContainer Name EcuMDriverInitListOne\nParent Container EcuMCommonConfiguration\nDescription Container for Init Block I.\nThis container holds a list of modules to be initialized. Each module in\nthe list will be called for initialization in the list order.\nAll modules in this list are initialized before the OS is started and so\nthese modules require no OS support.\nPost-Build Variant\nMultiplicity\nfalse\n185 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMDriverInitListZero\n\nSWS Item [ECUC_EcuM_00114]\nContainer Name EcuMDriverInitListZero\nParent Container EcuMCommonConfiguration\nDescription Container for Init Block 0.\nThis container holds a list of modules to be initialized. Each module in\nthe list will be called for initialization in the list order.\nAll modules in this list are initialized before the post-build configuration\nhas been loaded and the OS is initialized. Therefore, these modules\nmay not use post-build configuration.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMDriverRestartList\n\nSWS Item [ECUC_EcuM_00115]\nContainer Name EcuMDriverRestartList\nParent Container EcuMCommonConfiguration\nDescription List of modules to be initialized.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\n186 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nConfiguration Parameters\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMDriverInitItem\n\nEcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMModuleService: \nEcucStringParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nARElem ent\nEcucModuleConfigurationValues\n+ ecucDefEdition: RevisionLabelString [0..1]\n+ implementationConfigVariant: EcucConfigurationVariantEnum [0..1]\n+ postBuildVariantUsed: Boolean [0..1]\nEcuMModuleRef: EcucForeignReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\ndestinationType = ECUC-MODULE-CONFIGURATION-VALUES\nEcuMModuleParameter: \nEcucEnumerationParamDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nPOSTBUILD_PTR: \nEcucEnumerationLiteralDef\nNULL_PTR: \nEcucEnumerationLiteralDef\nVOID: \nEcucEnumerationLiteralDef\nEcucCoreDefinition: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nEcuMEcucCoreDefinitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+reference\n+literal\n+literal\n+literal\n+parameter\n+reference\n+destination\n+parameter\nFigure 10.6: EcuMDriverInitItem configuration overview\nSWS Item [ECUC_EcuM_00110]\nContainer Name EcuMDriverInitItem\nParent Container EcuMDriverInitListBswM, EcuMDriverInitListOne, EcuMDriverInitList\nZero, EcuMDriverRestartList\nDescription These containers describe the entries in a driver init list.\nAttributes:\nrequiresIndex=true\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\n187 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nConfiguration Parameters\nName EcuMModuleParameter [ECUC_EcuM_00224]\nParent Container EcuMDriverInitItem\nDescription Definition of the function prototype and the parameter passed to the\nfunction.\nMultiplicity 1\nType EcucEnumerationParamDef\nRange NULL_PTR If NULL_PTR is configured EcuM\nexpects as prototype: void\n<Mip>_<EcuMModuleService>(const\n<Mip>_ConfigType* <Mip>_Config).\nEcuM shall call this function with NULL\nPointer:\n<Mip>_<EcuMModuleService>(NULL).\nPOSTBUILD_PTR If POSTBUILD_PTR is configured\nEcuM expects as prototype: void\n<Mip>_<EcuMModuleService>(const\n<Mip>_ConfigType* <Mip>_Config).\nEcuM shall call this function with a\nvalid pointer:\n<Mip>_<EcuMModuleService>\n(&<Mip>_Config\n[Predefinedvariant.shortName]).\nVOID If VOID is configured EcuM expects as\nprototype: void\n<Mip>_<EcuMModuleService>(void).\nEcuM will call\n<Mip>_<EcuMModuleService>().\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMModuleService [ECUC_EcuM_00124]\nParent Container EcuMDriverInitItem\nDescription The service to be called to initialize that module, e.g. Init, PreInit, Start\netc. If nothing is defined \"Init\" is taken by default.\nMultiplicity 0..1\nType EcucStringParamDef\nDefault Value\nRegular Expression\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\n188 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMEcucCoreDefinitionRef [ECUC_EcuM_00229]\nParent Container EcuMDriverInitItem\nDescription Reference denotes the core the EcuM AUTOSAR services shall be\noffered on.\nMultiplicity 0..1\nType Reference to EcucCoreDefinition\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMModuleRef [ECUC_EcuM_00223]\nParent Container EcuMDriverInitItem\nDescription Foreign reference to the configuration of a module instance which shall\nbe initialized by EcuM\nMultiplicity 1\nType Foreign reference to ECUC-MODULE-CONFIGURATION-VALUES\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n189 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuMSleepMode\n\nEcuMSleepMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMSleepModeMcuModeRef: \nEcucReferenceDef\nrequiresSymbolicNameValue = true\nEcuMWakeupSourceMask: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nMcuModeSettingConf: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMSleepModeSuspend: \nEcucBooleanParamDef\nEcuMSleepModeId: \nEcucIntegerParamDef\nmax = 255\nmin = 0\nsymbolicNameValue = true\n+parameter\n+reference\n+destination\n+destination\n+reference\n+parameter\nFigure 10.7: EcuMSleepMode configuration overview\nSWS Item [ECUC_EcuM_00131]\nContainer Name EcuMSleepMode\nParent Container EcuMCommonConfiguration\nDescription These containers describe the configured sleep modes.\nThe names of these containers specify the symbolic names of the\ndifferent sleep modes.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMSleepModeId [ECUC_EcuM_00132]\nParent Container EcuMSleepMode\nDescription This ID identifies this sleep mode in services like\nEcuM_SelectShutdownTarget.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: ECU\n190 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMSleepModeSuspend [ECUC_EcuM_00136]\nParent Container EcuMSleepMode\nDescription Flag, which is set true, if the CPU is suspended, halted, or powered off\nin the sleep mode. If the CPU keeps running in this sleep mode, then\nthis flag must be set to false.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMSleepModeMcuModeRef [ECUC_EcuM_00133]\nParent Container EcuMSleepMode\nDescription This parameter is a reference to the corresponding MCU mode for this\nsleep mode.\nMultiplicity 1\nType Symbolic name reference to McuModeSettingConf\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMWakeupSourceMask [ECUC_EcuM_00152]\nParent Container EcuMSleepMode\nDescription These parameters are references to the wakeup sources that shall be\nenabled for this sleep mode.\nMultiplicity 1..*\nType Symbolic name reference to EcuMWakeupSource\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\n191 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nNo Included Containers\n\n### EcuMWakeupSource\n\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMValidationTimeout: \nEcucFloatParamDef\nmin = 0\nmax = INF\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMResetReasonRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcuMWakeupSourceId: \nEcucIntegerParamDef\nmin = 5\nmax = 31\nsymbolicNameValue = true\nComMChannel: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMComMChannelRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcuMWakeupSourcePolling: \nEcucBooleanParamDef\nMcuResetReasonConf: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nEcuMCheckWakeupTimeout: \nEcucFloatParamDef\nmin = 0.0\nmax = 10.0\nlowerMultiplicity = 0\nupperMultiplicity = 1\ndefaultValue = 0.0\nComMPnc: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 504\nEcuMComMPNCRef: EcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\n+parameter\n+reference\n+parameter\n+destination\n+destination+reference\n+parameter\n+parameter\n+destination+reference\nFigure 10.8: EcuMWakeupSource configuration overview\nSWS Item [ECUC_EcuM_00150]\nContainer Name EcuMWakeupSource\nParent Container EcuMCommonConfiguration\nDescription These containers describe the configured wakeup sources.\nPost-Build Variant\nMultiplicity\ntrue\nMultiplicity\nConfiguration Class\nPre-compile time X VARIANT -PRE-COMPILE\nLink time –\nPost-build time X VARIANT -POST -BUILD\nConfiguration Parameters\n192 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMCheckWakeupTimeout [ECUC_EcuM_00208]\nParent Container EcuMWakeupSource\nDescription This Parameter is the initial Value for the Time of the EcuM to delay\nshut down of the ECU if the check of the Wakeup Source is done\nasynchronously (CheckWakeupTimer).\nThe unit is in seconds.\nMultiplicity 0..1\nType EcucFloatParamDef\nRange [0 .. 10]\nDefault Value 0\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMValidationTimeout [ECUC_EcuM_00148]\nParent Container EcuMWakeupSource\nDescription The validation timeout (period for which the ECU State Manager will\nwait for the validation of a wakeup event) can be defined for each\nwakeup source independently. The timeout is specified in seconds.\nWhen the timeout is not instantiated, there is no validation routine and\nthe ECU Manager shall not validate the wakeup source.\nMultiplicity 0..1\nType EcucFloatParamDef\nRange [0 .. INF]\nDefault Value\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\n193 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMWakeupSourceId [ECUC_EcuM_00151]\nParent Container EcuMWakeupSource\nDescription This parameter defines the identifier of this wakeup source. The first\nfive bits are reserved values from the EcuM_WakeupSourceType.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 5 .. 31\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: ECU\nName EcuMWakeupSourcePolling [ECUC_EcuM_00153]\nParent Container EcuMWakeupSource\nDescription This parameter describes if the wakeup source needs polling.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMComMChannelRef [ECUC_EcuM_00101]\nParent Container EcuMWakeupSource\nDescription This parameter could reference multiple Networks (channels) defined\nin the Communication Manager. No reference indicates that the\nwakeup source is not a communication channel.\nMultiplicity 0..*\nType Symbolic name reference to ComMChannel\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\n194 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMComMPNCRef [ECUC_EcuM_00228]\nParent Container EcuMWakeupSource\nDescription This is a reference to a one or more PNC’s defined in the\nCommunication Manager.\nNo reference indicates that the wakeup source is not assigned to a\npartial network.\nMultiplicity 0..*\nType Symbolic name reference to ComMPnc\nPost-Build Variant\nMultiplicity\ntrue\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMResetReasonRef [ECUC_EcuM_00128]\nParent Container EcuMWakeupSource\nDescription This parameter describes the mapping of reset reasons detected by\nthe MCU driver into wakeup sources.\nMultiplicity 0..*\nType Symbolic name reference to McuResetReasonConf\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n195 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n## EcuM-Flex Containers and configuration parameters\n\nEcuM: EcucModuleDef\nupperMultiplicity = 1\nlowerMultiplicity = 0\nEcuMConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMGeneral: \nEcucParamConfContainerDef\nEcuMCommonConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMFlexGeneral: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+subContainer\n+container\n+subContainer\n+container\n+container\nFigure 10.9: EcuMFlex configuration overview\n\n### EcuMFlexGeneral\n\nEcuMFlexGeneral: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMResetLoopDetection: \nEcucBooleanParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMAlarmClockPresent: \nEcucBooleanParamDef\nEcuMAlarmWakeupSource: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nrequiresSymbolicNameValue = true\nEcuMWakeupSource: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 32\nEcuMSetProgrammableInterrupts: \nEcucBooleanParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMModeHandling: \nEcucBooleanParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\n+parameter\n+destination\n+parameter\n+parameter\n+parameter\n+reference\nFigure 10.10: EcuMFlexGeneral configuration overview\nSWS Item [ECUC_EcuM_00168]\nContainer Name EcuMFlexGeneral\nParent Container EcuM\nDescription This container holds the general, pre-compile configuration parameters\nfor the EcuMFlex.\nOnly applicable if EcuMFlex is implemented.\nPost-Build Variant\nMultiplicity\nfalse\n196 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMAlarmClockPresent [ECUC_EcuM_00199]\nParent Container EcuMFlexGeneral\nDescription This flag indicates whether the optional AlarmClock feature is present.\nMultiplicity 1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMModeHandling [ECUC_EcuM_00221]\nParent Container EcuMFlexGeneral\nDescription If false, Run Request Protocol is not performed.\nMultiplicity 0..1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMResetLoopDetection [ECUC_EcuM_00171]\nParent Container EcuMFlexGeneral\nDescription If false, no reset loop detection is performed. If this configuration\nparameter exists and is set to true, the callout \"EcuM_LoopDetection\"\nis called during startup of EcuM (during StartPreOS).\nMultiplicity 0..1\nType EcucBooleanParamDef\nDefault Value\n197 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMSetProgrammableInterrupts [ECUC_EcuM_00210]\nParent Container EcuMFlexGeneral\nDescription If this configuration parameter exists and is to true, the callout\n\"EcuM_AL_SetProgrammableInterrupts\" is called during startup of\nEcuM (during StartPreOS).\nMultiplicity 0..1\nType EcucBooleanParamDef\nDefault Value\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMAlarmWakeupSource [ECUC_EcuM_00200]\nParent Container EcuMFlexGeneral\nDescription This parameter describes the reference to the EcuMWakeupSource\nbeing used for the EcuM AlarmClock.\nMultiplicity 0..1\nType Symbolic name reference to EcuMWakeupSource\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\n198 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n199 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuMFlexConfiguration\n\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMResetMode: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMResetModeId: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMShutdownCause: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMShutdownCauseId: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMAlarmClock: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nEcuMAlarmClockId: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMAlarmClockTimeOut: \nEcucFloatParamDef\nmin = 0\nmax = INFEcuMAlarmClockUser: \nEcucReferenceDef\nrequiresSymbolicNameValue = true\nEcuMFlexUserConfig: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMSetClockAllowedUserRef: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcuMSetClockAllowedUsers: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMNormalMcuModeRef: \nEcucReferenceDef\nrequiresSymbolicNameValue = true\nMcuModeSettingConf: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nEcuMGoDownAllowedUsers: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMGoDownAllowedUserRef: \nEcucReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = *\nrequiresSymbolicNameValue = true\nEcucPartition: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\nEcuMPartitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = *\n+subContainer\n+parameter\n+destination\n+reference\n+parameter\n+reference\n+reference\n+destination\n+parameter\n+subContainer\n+subContainer\n+parameter\n+subContainer\n+destination\n+reference\n+subContainer\n+destination\n+reference\n+subContainer\n+destination\nFigure 10.11: EcuMFlexConfiguration configuration overview\nSWS Item [ECUC_EcuM_00167]\nContainer Name EcuMFlexConfiguration\nParent Container EcuMConfiguration\nDescription This container contains the configuration (parameters) of the\nEcuMFlex.\nOnly applicable if EcuMFlex is implemented.\n200 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMNormalMcuModeRef [ECUC_EcuM_00204]\nParent Container EcuMFlexConfiguration\nDescription This parameter is a reference to the normal MCU mode to be restored\nafter a sleep.\nMultiplicity 1\nType Symbolic name reference to McuModeSettingConf\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMPartitionRef [ECUC_EcuM_00217]\nParent Container EcuMFlexConfiguration\nDescription Reference denotes the partition a EcuM shall run inside. Please note\nthat in case of a multicore ECU this reference is mandatory.\nMultiplicity 0..*\nType Reference to EcucPartition\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMAlarmClock 0..* These containers describe the configured alarm clocks.\nThe name of these conatiners allows giving a symbolic\nname to one alarm clock.\n201 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nEcuMDriverInitListBswM 0..* This container holds a list of modules to be initialized by\nthe BswM.\nEcuMFlexUserConfig 1..256 These containers describe the identifiers that are\nneeded to refer to a software component or another\nappropriate entity in the system which uses the\nEcuMFlex Interfaces.\nEcuMGoDownAllowed\nUsers\n0..1 This container describes the collection of allowed users\nwhich are allowed to call the EcuM_GoDownHaltPoll API\n(only applies in the case that the previously set\nshutdown target is TARGET_RESET or TARGET_OFF).\nEcuMResetMode 1..256 These containers describe the configured reset modes.\nThe name of these containers allows one of the following\nsymbolic names to be given to the different reset modes:\n• ECUM_RESET_MCU\n• ECUM_RESET_WDG\n• ECUM_RESET_IO.\nEcuMSetClockAllowed\nUsers\n0..1 This container describes the collection of allowed users\nwhich are allowed to call the EcuM_SetClock API.\nEcuMShutdownCause 1..256 These containers describe the configured shut down or\nreset causes. The name of these containers allows to\ngive one of the following symbolic names to the different\nshut down causes:\n• ECUM_CAUSE_ECU_STATE - ECU state\nmachine entered a state for shutdown,\n• ECUM_CAUSE_WDGM - WdgM detected failure,\n• ECUM_CAUSE_DCM - Dcm requests shutdown\n(split into UDS services?),\n• and values from configuration.\n\n### EcuMAlarmClock\n\nSWS Item [ECUC_EcuM_00184]\nContainer Name EcuMAlarmClock\nParent Container EcuMFlexConfiguration\nDescription These containers describe the configured alarm clocks.\nThe name of these conatiners allows giving a symbolic name to one\nalarm clock.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\n202 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMAlarmClockId [ECUC_EcuM_00186]\nParent Container EcuMAlarmClock\nDescription This ID identifies this alarmclock.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMAlarmClockTimeOut [ECUC_EcuM_00188]\nParent Container EcuMAlarmClock\nDescription This parameter allows to define a timeout for this alarm clock.\nMultiplicity 1\nType EcucFloatParamDef\nRange [0 .. INF]\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMAlarmClockUser [ECUC_EcuM_00195]\nParent Container EcuMAlarmClock\nDescription This parameter allows an alarm to be assigned to a user.\nMultiplicity 1\nType Symbolic name reference to EcuMFlexUserConfig\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n203 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\n\n### EcuMDriverInitListBswM\n\nEcuMFlexUserConfig: \nEcucParamConfContainerDef\nlowerMultiplicity = 1\nupperMultiplicity = 256\nEcuMFlexUser: \nEcucIntegerParamDef\nmin = 0\nmax = 255\nsymbolicNameValue = true\nEcuMFlexEcucPartitionRef: \nEcucReferenceDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcucPartition: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\n+destination\n+parameter\n+reference\nFigure 10.12: EcuMFlexUserConfig configuration overview\nSWS Item [ECUC_EcuM_00201]\nContainer Name EcuMFlexUserConfig\nParent Container EcuMFlexConfiguration\nDescription These containers describe the identifiers that are needed to refer to a\nsoftware component or another appropriate entity in the system which\nuses the EcuMFlex Interfaces.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMFlexUser [ECUC_EcuM_00146]\nParent Container EcuMFlexUserConfig\nDescription Parameter used to identify one user.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nName EcuMFlexEcucPartitionRef [ECUC_EcuM_00203]\nParent Container EcuMFlexUserConfig\nDescription Denotes in which \"EcucPartition\" the user of the EcuM is executed.\nMultiplicity 0..1\nType Reference to EcucPartition\nPost-Build Variant\nMultiplicity\nfalse\n204 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\nEcuMFlexConfiguration: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nEcuMDriverInitItem: \nEcucParamConfContainerDef\nupperMultiplicity = *\nlowerMultiplicity = 1\nrequiresIndex = true\nEcuMModuleService: \nEcucStringParamDef\nlowerMultiplicity = 0\nupperMultiplicity = 1\nARElement\nEcucModuleConfigurationValues\n+ ecucDefEdition: RevisionLabelString [0..1]\n+ implementationConfigVariant: EcucConfigurationVariantEnum [0..1]\n+ postBuildVariantUsed: Boolean [0..1]\nEcuMModuleRef: EcucForeignReferenceDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\ndestinationType = ECUC-MODULE-CONFIGURATION-VALUES\nEcuMModuleParameter: \nEcucEnumerationParamDef\nlowerMultiplicity = 1\nupperMultiplicity = 1\nPOSTBUILD_PTR: \nEcucEnumerationLiteralDef\nNULL_PTR: \nEcucEnumerationLiteralDef\nVOID: \nEcucEnumerationLiteralDef\nEcuMDriverInitListBswM: \nEcucParamConfContainerDef\nlowerMultiplicity = 0\nupperMultiplicity = *\n+reference\n+literal\n+subContainer\n+literal\n+literal\n+subContainer\n+parameter\n+parameter\nFigure 10.13: EcuMFlexDriverInitListBswM configuration overview\nSWS Item [ECUC_EcuM_00226]\nContainer Name EcuMDriverInitListBswM\nParent Container EcuMFlexConfiguration\nDescription This container holds a list of modules to be initialized by the BswM.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\n205 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nIncluded Containers\nContainer Name Multiplicity Scope / Dependency\nEcuMDriverInitItem 1..* These containers describe the entries in a driver init list.\n\n### EcuMGoDownAllowedUsers\n\nSWS Item [ECUC_EcuM_00206]\nContainer Name EcuMGoDownAllowedUsers\nParent Container EcuMFlexConfiguration\nDescription This container describes the collection of allowed users which are\nallowed to call the EcuM_GoDownHaltPoll API (only applies in the case\nthat the previously set shutdown target is TARGET_RESET or\nTARGET_OFF).\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMGoDownAllowedUserRef [ECUC_EcuM_00207]\nParent Container EcuMGoDownAllowedUsers\nDescription This references an allowed user.\nMultiplicity 1..*\nType Symbolic name reference to EcuMFlexUserConfig\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n\n### EcuMResetMode\n\nSWS Item [ECUC_EcuM_00172]\n206 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nContainer Name EcuMResetMode\nParent Container EcuMFlexConfiguration\nDescription These containers describe the configured reset modes. The name of\nthese containers allows one of the following symbolic names to be\ngiven to the different reset modes:\n• ECUM_RESET_MCU\n• ECUM_RESET_WDG\n• ECUM_RESET_IO.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMResetModeId [ECUC_EcuM_00173]\nParent Container EcuMResetMode\nDescription This ID identifies this reset mode in services like\nEcuM_SelectShutdownTarget.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n\n### EcuMSetClockAllowedUsers\n\nSWS Item [ECUC_EcuM_00175]\nContainer Name EcuMShutdownCause\nParent Container EcuMFlexConfiguration\n207 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nDescription These containers describe the configured shut down or reset causes.\nThe name of these containers allows to give one of the following\nsymbolic names to the different shut down causes:\n• ECUM_CAUSE_ECU_STATE - ECU state machine entered a\nstate for shutdown,\n• ECUM_CAUSE_WDGM - WdgM detected failure,\n• ECUM_CAUSE_DCM - Dcm requests shutdown (split into UDS\nservices?),\n• and values from configuration.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\nName EcuMShutdownCauseId [ECUC_EcuM_00176]\nParent Container EcuMShutdownCause\nDescription This ID identifies this shut down cause.\nMultiplicity 1\nType EcucIntegerParamDef (Symbolic Name generated for this parameter)\nRange 0 .. 255\nDefault Value\nPost-Build Variant\nValue\nfalse\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\nSWS Item [ECUC_EcuM_00197]\nContainer Name EcuMSetClockAllowedUsers\nParent Container EcuMFlexConfiguration\nDescription This container describes the collection of allowed users which are\nallowed to call the EcuM_SetClock API.\nPost-Build Variant\nMultiplicity\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nConfiguration Parameters\n208 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nName EcuMSetClockAllowedUserRef [ECUC_EcuM_00198]\nParent Container EcuMSetClockAllowedUsers\nDescription These parameters describe the references to the users which are\nallowed to call the EcuM_SetClock API.\nMultiplicity 1..*\nType Symbolic name reference to EcuMFlexUserConfig\nPost-Build Variant\nMultiplicity\nfalse\nPost-Build Variant\nValue\nfalse\nMultiplicity\nConfiguration Class\nPre-compile time X All Variants\nLink time –\nPost-build time –\nValue Configuration\nClass\nPre-compile time X All Variants\nLink time –\nPost-build time –\nScope / Dependency scope: local\nNo Included Containers\n\n## Published Information\n\nCurrently there exists no published information except the ones specified in SWS BSW\nGeneral.\n209 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager\n\nSpecification of ECU State Manager\nAUTOSAR CP R20-11\nA Not applicable requirements\n[SWS_EcuM_NA_00000] ⌈These requirements are not applicable to this specifica-\ntion.⌋(SRS_BSW_00159, SRS_BSW_00167, SRS_BSW_00406, SRS_BSW_00437,\nSRS_BSW_00168, SRS_BSW_00426, SRS_BSW_00427, SRS_BSW_00432, SRS_-\nBSW_00417, SRS_BSW_00422, SRS_BSW_00161, SRS_BSW_00162, SRS_-\nBSW_00005, SRS_BSW_00415, SRS_BSW_00325, SRS_BSW_00164, SRS_-\nBSW_00160, SRS_BSW_00453, SRS_BSW_00413, SRS_BSW_00347, SRS_-\nBSW_00307, SRS_BSW_00450, SRS_BSW_00410, SRS_BSW_00314, SRS_-\nBSW_00348, SRS_BSW_00353, SRS_BSW_00361, SRS_BSW_00439, SRS_-\nBSW_00449, SRS_BSW_00308, SRS_BSW_00309, SRS_BSW_00330, SRS_-\nBSW_00010, SRS_BSW_00341, SRS_BSW_00334)\n210 of 210 Document ID 78: AUTOSAR_SWS_ECUStateManager"
  }
}